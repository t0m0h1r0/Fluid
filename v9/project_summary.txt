# .

## Directory Structure

- ./
  - .venv/
  - simulations/
    - initializer.py
    - config/
      - output.py
      - interface.py
      - base.py
      - interfaces.py
      - boundary.py
      - simulation.py
      - __init__.py
      - numerical.py
      - __pycache__/
      - physics.py
    - state.py
    - simulation.py
    - __init__.py
    - __pycache__/
  - visualization/
    - core/
      - base.py
      - exporter.py
      - renderer.py
      - __init__.py
      - __pycache__/
    - interfaces.py
    - utils/
      - colormap.py
      - camera.py
    - renderer_strategy.py
    - renderers/
      - vector2d.py
      - vector3d.py
      - __init__.py
      - __pycache__/
      - scalar2d.py
      - scalar3d.py
    - visualizer.py
    - __init__.py
    - __pycache__/
    - multiview.py
  - numerics/
    - spatial/
      - stencil.py
      - base.py
      - schemes/
        - central.py
      - __init__.py
    - weno/
      - smoothness.py
      - coefficients.py
      - weights.py
      - base.py
      - schemes/
        - weno3.py
        - __init__.py
        - weno5.py
        - weno7.py
      - __init__.py
    - time_evolution/
      - runge_kutta.py
      - euler.py
      - base.py
      - __init__.py
      - __pycache__/
    - poisson/
      - solver.py
      - base.py
      - config.py
      - __init__.py
      - __pycache__/
      - methods/
        - __pycache__/
        - sor.py
        - cg.py
  - core/
    - boundary/
      - dirichlet.py
      - base.py
      - periodic.py
      - neumann.py
      - __init__.py
      - __pycache__/
    - solver/
      - base.py
      - temporal.py
      - iterative.py
      - __init__.py
      - __pycache__/
    - field/
      - scalar.py
      - vector.py
      - field.py
      - __init__.py
      - __pycache__/
  - config.yaml
  - results/
    - visualization/
      - simulation_state_pressure_xy_slice_0.50_0.000_0.000000.png (binary file)
      - simulation_state_levelset_yz_slice_0.50_0.000_0.000000.png (binary file)
      - simulation_state_pressure_yz_slice_0.50_0.000_0.000000.json
      - simulation_state_velocity_xz_slice_0.50_0.000_0.000000.json
      - simulation_state_pressure_xz_slice_0.50_0.000_0.000000.png (binary file)
      - simulation_state_velocity_yz_slice_0.50_0.000_0.000000.png (binary file)
      - checkpoints/
        - initial_checkpoint.npz (binary file)
      - simulation_state_pressure_xz_slice_0.50_0.000_0.000000.json
      - simulation_state_velocity_xz_slice_0.50_0.000_0.000000.png (binary file)
      - simulation_state_velocity_xy_slice_0.50_0.000_0.000000.png (binary file)
      - simulation_state_levelset_xy_slice_0.50_0.000_0.000000.json
      - simulation_state_pressure_xy_slice_0.50_0.000_0.000000.json
      - simulation_state_levelset_xy_slice_0.50_0.000_0.000000.png (binary file)
      - simulation_state_pressure_yz_slice_0.50_0.000_0.000000.png (binary file)
      - diagnostics/
        - diagnostics_0.000000.json
      - simulation_state_levelset_yz_slice_0.50_0.000_0.000000.json
      - simulation_state_levelset_xz_slice_0.50_0.000_0.000000.png (binary file)
      - simulation_state_velocity_xy_slice_0.50_0.000_0.000000.json
      - simulation_state_levelset_xz_slice_0.50_0.000_0.000000.json
      - simulation_state_velocity_yz_slice_0.50_0.000_0.000000.json
  - physics/
    - pressure/
      - poisson.py
      - terms/
        - force.py
        - base.py
        - advection.py
        - viscous.py
        - __init__.py
        - __pycache__/
        - pressure.py
      - __init__.py
      - __pycache__/
    - continuity/
      - continuity.py
      - __init__.py
      - __pycache__/
    - multiphase/
      - interface.py
      - operators/
        - initialization.py
        - indicator.py
        - reinitialization.py
        - __init__.py
        - geometry.py
        - __pycache__/
      - __init__.py
      - __pycache__/
    - navier_stokes/
      - solver.py
      - terms/
        - base.py
        - advection.py
        - acceleration.py
        - diffusion.py
        - __init__.py
        - __pycache__/
        - pressure.py
      - __init__.py
      - __pycache__/
  - main2.py
  - .vscode/
  - .ruff_cache/

## File Contents

### simulations/initializer.py

```
"""シミュレーションの初期化を担当するモジュール

このモジュールは、二相流シミュレーションの初期状態を設定します。
設定ファイルに基づいて、速度場、圧力場、界面関数などを
適切に初期化します。
"""

import numpy as np

from core.field import VectorField, ScalarField
from physics.multiphase import InterfaceOperations
from .config import SimulationConfig
from .state import SimulationState


class SimulationInitializer:
    """シミュレーション初期化クラス"""

    def __init__(self, config: SimulationConfig):
        """初期化クラスを構築

        Args:
            config: シミュレーション設定
        """
        self.config = config
        self._validate_config()

        # グリッド間隔の計算
        self.dx = np.array(
            [
                size / (dim - 1)
                for size, dim in zip(
                    self.config.domain.size, self.config.domain.dimensions
                )
            ]
        )

        # InterfaceOperationsの初期化
        self._interface_ops = InterfaceOperations(
            dx=self.dx,
            epsilon=self.config.numerical.get("interface", {}).get("epsilon", 1e-2),
        )

        # 追加の初期化パラメータ
        self._init_parameters = {
            "time": 0.0,
            "shape": tuple(self.config.domain.dimensions),
        }

    def _validate_config(self):
        """設定の妥当性を検証"""
        if not self.config.domain:
            raise ValueError("領域設定が存在しません")
        if not self.config.physics:
            raise ValueError("物理設定が存在しません")
        if not self.config.initial_conditions:
            raise ValueError("初期条件が存在しません")

    def create_initial_state(self) -> SimulationState:
        """初期状態を生成

        Returns:
            初期化されたシミュレーション状態
        """
        # 基本フィールドの初期化
        velocity = VectorField(self._init_parameters["shape"], self.dx)
        levelset = ScalarField(self._init_parameters["shape"], self.dx)
        pressure = ScalarField(self._init_parameters["shape"], self.dx)

        # 速度場の初期化
        self._initialize_velocity(velocity)

        # 界面関数の初期化
        self._initialize_interface(levelset)

        # 状態の構築
        state = SimulationState(
            time=self._init_parameters["time"],
            velocity=velocity,
            levelset=levelset,
            pressure=pressure,
        )

        return state

    def _initialize_velocity(self, velocity: VectorField) -> None:
        """速度場を初期化

        Args:
            velocity: 初期化対象の速度場
        """
        velocity_config = self.config.initial_conditions.velocity

        if velocity_config["type"] == "zero":
            # ゼロ速度場（デフォルト）
            pass
        elif velocity_config["type"] == "uniform":
            # 一様流れ
            direction = velocity_config.get("direction", [1.0, 0.0, 0.0])
            magnitude = velocity_config.get("magnitude", 1.0)
            for i, comp in enumerate(velocity.components):
                comp.data.fill(direction[i] * magnitude)
        elif velocity_config["type"] == "vortex":
            # 渦流れ
            center = velocity_config.get("center", [0.5, 0.5, 0.5])
            strength = velocity_config.get("strength", 1.0)
            coords = np.meshgrid(
                *[np.linspace(0, 1, s) for s in velocity.shape], indexing="ij"
            )
            r = np.sqrt(
                sum((c - cent) ** 2 for c, cent in zip(coords[:-1], center[:-1]))
            )
            velocity.components[0].data = -strength * (coords[1] - center[1]) / r
            velocity.components[1].data = strength * (coords[0] - center[0]) / r

    def _initialize_interface(self, levelset: ScalarField) -> None:
        """界面関数を初期化

        Args:
            levelset: 初期化対象の界面関数
        """
        # 界面設定の取得
        initial_conditions = self.config.initial_conditions
        background_phase = initial_conditions.background.get("phase")  # 背景相の取得

        # 最初のオブジェクトに基づいて界面を生成
        objects = initial_conditions.objects if initial_conditions.objects else []
        if objects:
            first_obj = objects[0]
            if first_obj.get("type") == "plate":
                height = first_obj.get("height", 0.5)
                phase = first_obj.get(
                    "phase", background_phase
                )  # オブジェクトの相を取得
                if phase == background_phase:
                    normal = [0, 0, 1]  # 背景相と同じ場合、正の高さ
                else:
                    normal = [0, 0, -1]  # 背景相と異なる場合、負の高さ
                point = [0.5, 0.5, height]
                levelset_data = self._interface_ops.create_plane(
                    shape=levelset.shape, normal=normal, point=point
                )
                levelset.data = levelset_data.data
            elif first_obj.get("type") == "sphere":
                center = first_obj.get("center", [0.5, 0.5, 0.5])
                radius = first_obj.get("radius", 0.1)
                phase = first_obj.get(
                    "phase", background_phase
                )  # オブジェクトの相を取得
                sign = (
                    1.0 if phase != background_phase else -1.0
                )  # 背景相と異なる場合は正の距離関数
                levelset_data = sign * self._interface_ops.create_sphere(
                    shape=levelset.shape, center=center, radius=radius
                )
                levelset.data = levelset_data.data
        else:
            # フォールバック: デフォルトの平面界面
            levelset_data = self._interface_ops.create_plane(
                shape=levelset.shape, normal=[0, 0, 1], point=[0.5, 0.5, 0.5]
            )
            levelset.data = levelset_data.data

        # 残りのオブジェクトを組み合わせる
        for obj in objects[1:]:
            if obj.get("type") == "plate":
                height = obj.get("height", 0.5)
                phase = obj.get("phase", background_phase)  # オブジェクトの相を取得
                if phase == background_phase:
                    normal = [0, 0, 1]
                else:
                    normal = [0, 0, -1]
                point = [0.5, 0.5, height]
                plate = self._interface_ops.create_plane(
                    shape=levelset.shape, normal=normal, point=point
                )
                levelset_data = self._interface_ops.combine_interfaces(
                    levelset, plate, "union"
                )
                levelset.data = levelset_data.data
            elif obj.get("type") == "sphere":
                center = obj.get("center", [0.5, 0.5, 0.5])
                radius = obj.get("radius", 0.1)
                phase = obj.get("phase", background_phase)  # オブジェクトの相を取得
                sign = 1.0 if phase != background_phase else -1.0
                sphere = sign * self._interface_ops.create_sphere(
                    shape=levelset.shape, center=center, radius=radius
                )
                levelset_data = self._interface_ops.combine_interfaces(
                    levelset, sphere, "union"
                )
                levelset.data = levelset_data.data

```

### simulations/config/output.py

```
"""出力設定を管理するモジュール"""

from dataclasses import dataclass, field
from typing import Dict, Any, List, Union
from pathlib import Path
from .base import BaseConfig, load_config_safely


@dataclass
class OutputConfig(BaseConfig):
    """出力の設定を保持するクラス"""

    output_dir: Union[str, Path] = Path("results/visualization")
    format: str = "png"
    dpi: int = 300
    colormap: str = "viridis"
    show_colorbar: bool = True
    show_axes: bool = True
    show_grid: bool = False
    slices: Dict[str, List[Union[str, float]]] = field(
        default_factory=lambda: {"axes": ["xy", "xz", "yz"], "positions": [0.5]}
    )
    fields: Dict[str, Dict[str, Any]] = field(
        default_factory=lambda: {
            "velocity": {
                "enabled": True,
                "plot_types": ["vector", "magnitude"],
                "scale": 1.0,
                "density": 20,
                "color": "black",
                "alpha": 0.7,
            },
            "pressure": {
                "enabled": True,
                "plot_types": ["scalar", "contour"],
                "levels": 20,
                "alpha": 0.5,
            },
            "levelset": {
                "enabled": True,
                "plot_types": ["interface", "contour"],
                "levels": [0],
                "colors": ["black"],
                "linewidth": 2.0,
            },
        }
    )

    def __post_init__(self):
        """初期化後の処理"""
        # パスをPath型に変換
        if isinstance(self.output_dir, str):
            self.output_dir = Path(self.output_dir)

        # 出力ディレクトリの作成（存在しない場合）
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        # 出力ディレクトリのバリデーション
        if not self.output_dir:
            raise ValueError("出力ディレクトリは空にできません")

        # 解像度のバリデーション
        if self.dpi <= 0:
            raise ValueError("dpiは正の値である必要があります")

        # スライス軸のバリデーション
        valid_axes = {"xy", "xz", "yz"}
        if not all(axis in valid_axes for axis in self.slices.get("axes", [])):
            raise ValueError(f"無効なスライス軸。有効な値: {valid_axes}")

        # スライス位置のバリデーション
        if not all(0 <= pos <= 1 for pos in self.slices.get("positions", [])):
            raise ValueError("スライス位置は0から1の間である必要があります")

    def load(self, config_dict: Dict[str, Any]) -> "OutputConfig":
        """辞書から設定を読み込む"""
        # デフォルト値を設定しつつ、入力された値で上書き
        merged_config = load_config_safely(
            config_dict,
            {
                "output_dir": "results/visualization",
                "format": "png",
                "dpi": 300,
                "colormap": "viridis",
                "show_colorbar": True,
                "show_axes": True,
                "show_grid": False,
                "slices": {"axes": ["xy", "xz", "yz"], "positions": [0.5]},
                "fields": {
                    "velocity": {
                        "enabled": True,
                        "plot_types": ["vector", "magnitude"],
                        "scale": 1.0,
                        "density": 20,
                        "color": "black",
                        "alpha": 0.7,
                    },
                    "pressure": {
                        "enabled": True,
                        "plot_types": ["scalar", "contour"],
                        "levels": 20,
                        "alpha": 0.5,
                    },
                    "levelset": {
                        "enabled": True,
                        "plot_types": ["interface", "contour"],
                        "levels": [0],
                        "colors": ["black"],
                        "linewidth": 2.0,
                    },
                },
            },
        )

        return OutputConfig(
            output_dir=Path(merged_config.get("output_dir", "results/visualization")),
            format=merged_config.get("format", "png"),
            dpi=merged_config.get("dpi", 300),
            colormap=merged_config.get("colormap", "viridis"),
            show_colorbar=merged_config.get("show_colorbar", True),
            show_axes=merged_config.get("show_axes", True),
            show_grid=merged_config.get("show_grid", False),
            slices=merged_config.get(
                "slices", {"axes": ["xy", "xz", "yz"], "positions": [0.5]}
            ),
            fields=merged_config.get(
                "fields",
                {
                    "velocity": {
                        "enabled": True,
                        "plot_types": ["vector", "magnitude"],
                        "scale": 1.0,
                        "density": 20,
                        "color": "black",
                        "alpha": 0.7,
                    },
                    "pressure": {
                        "enabled": True,
                        "plot_types": ["scalar", "contour"],
                        "levels": 20,
                        "alpha": 0.5,
                    },
                    "levelset": {
                        "enabled": True,
                        "plot_types": ["interface", "contour"],
                        "levels": [0],
                        "colors": ["black"],
                        "linewidth": 2.0,
                    },
                },
            ),
        )

    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        return {
            "output_dir": str(self.output_dir),
            "format": self.format,
            "dpi": self.dpi,
            "colormap": self.colormap,
            "show_colorbar": self.show_colorbar,
            "show_axes": self.show_axes,
            "show_grid": self.show_grid,
            "slices": self.slices,
            "fields": self.fields,
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "OutputConfig":
        """辞書から設定を復元"""
        return cls().load(config_dict)

```

### simulations/config/interface.py

```
"""界面の設定を管理するモジュール"""

from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Union
from .base import BaseConfig, Phase, load_config_safely


@dataclass
class InitialConditionConfig(BaseConfig):
    """初期条件の設定を保持するクラス"""

    background: Dict[str, str] = field(default_factory=lambda: {"phase": "nitrogen"})
    objects: List[Dict[str, Any]] = field(default_factory=list)
    velocity: Dict[str, str] = field(default_factory=lambda: {"type": "zero"})

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        # 背景相のバリデーション
        if "phase" not in self.background:
            raise ValueError("背景相には相の指定が必要です")

        # オブジェクトのバリデーション
        for obj in self.objects:
            InterfaceConfig(**obj).validate()

        # 速度場のバリデーション
        if "type" not in self.velocity:
            raise ValueError("初期速度場の種類の指定が必要です")

    def load(self, config_dict: Dict[str, Any]) -> "InitialConditionConfig":
        """辞書から設定を読み込む"""
        # デフォルト値を設定しつつ、入力された値で上書き
        merged_config = load_config_safely(
            config_dict,
            {
                "background": {"phase": "nitrogen"},
                "objects": [],
                "velocity": {"type": "zero"},
            },
        )

        return InitialConditionConfig(
            background=merged_config.get("background", {"phase": "nitrogen"}),
            objects=[
                {k: (str(v) if k == "type" else v) for k, v in obj.items()}
                for obj in merged_config.get("objects", [])
            ],
            velocity=merged_config.get("velocity", {"type": "zero"}),
        )

    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        return {
            "background": self.background,
            "objects": self.objects,
            "velocity": self.velocity,
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "InitialConditionConfig":
        """辞書から設定を復元"""
        return cls().load(config_dict)


@dataclass
class InterfaceConfig(BaseConfig):
    """界面の設定を保持するクラス"""

    phase: Phase = Phase.WATER
    object_type: str = "background"  # "background", "plate", "sphere"
    height: Optional[float] = None  # レイヤー用
    center: Optional[List[float]] = None  # 球体用
    radius: Optional[float] = None  # 球体用

    def __init__(
        self,
        phase: Optional[Union[str, Phase]] = None,
        object_type: Optional[str] = None,
        type: Optional[str] = None,  # 追加
        height: Optional[float] = None,
        center: Optional[List[float]] = None,
        radius: Optional[float] = None,
    ):
        """インターフェース設定を初期化

        `type` キーワードを `object_type` として処理
        """
        if type is not None and object_type is None:
            object_type = type

        # Phase の変換
        if isinstance(phase, str):
            phase = Phase[phase.upper()]

        # デフォルト値の設定
        self.phase = phase or Phase.WATER
        self.object_type = object_type or "background"
        self.height = height
        self.center = center
        self.radius = radius

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        if self.object_type == "background":
            if any([self.height, self.center, self.radius]):
                raise ValueError("背景相には高さ、中心、半径は指定できません")
        elif self.object_type == "plate":
            if self.height is not None and not 0 <= self.height <= 1:
                raise ValueError("高さは0から1の間である必要があります")
            if any([self.center, self.radius]):
                raise ValueError("レイヤーには高さのみ指定してください")
        elif self.object_type == "sphere":
            if not self.center or len(self.center) != 3:
                raise ValueError("球体には3次元の中心座標が必要です")
            if not self.radius or self.radius <= 0:
                raise ValueError("球体には正の半径が必要です")
            if self.height is not None:
                raise ValueError("球体には高さは指定できません")
        else:
            raise ValueError(f"未対応のオブジェクトタイプ: {self.object_type}")

    def load(self, config_dict: Dict[str, Any]) -> "InterfaceConfig":
        """辞書から設定を読み込む"""
        # 'type' キーを 'object_type' に変換
        if "type" in config_dict:
            config_dict["object_type"] = config_dict.pop("type")

        # デフォルト値を設定しつつ、入力された値で上書き
        merged_config = load_config_safely(
            config_dict,
            {
                "phase": "water",
                "object_type": "background",
                "height": None,
                "center": None,
                "radius": None,
            },
        )

        return InterfaceConfig(
            phase=Phase[merged_config.get("phase", "water").upper()],
            object_type=merged_config.get("object_type", "background"),
            height=merged_config.get("height"),
            center=merged_config.get("center"),
            radius=merged_config.get("radius"),
        )

    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        return {
            "phase": self.phase.name.lower(),
            "type": self.object_type,
            "height": self.height,
            "center": self.center,
            "radius": self.radius,
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "InterfaceConfig":
        """辞書から設定を復元"""
        return cls().load(config_dict)

```

### simulations/config/base.py

```
"""設定の基本的な列挙型と基底クラス"""

from enum import Enum, auto
from typing import Dict, Any, Optional
from dataclasses import dataclass, asdict
from .interfaces import ConfigValidator, ConfigLoader, ConfigSerializer


class Phase(Enum):
    """流体の相を表す列挙型"""

    WATER = auto()
    NITROGEN = auto()
    GAS = auto()
    LIQUID = auto()


class BoundaryType(Enum):
    """境界条件の種類を表す列挙型"""

    PERIODIC = "periodic"
    NEUMANN = "neumann"
    DIRICHLET = "dirichlet"


@dataclass
class BaseConfig(ConfigValidator, ConfigLoader, ConfigSerializer):
    """設定の基底クラス"""

    def validate(self) -> None:
        """デフォルトの検証メソッド（サブクラスでオーバーライド）"""
        pass

    def load(self, config_dict: Dict[str, Any]) -> "BaseConfig":
        """デフォルトの読み込みメソッド（サブクラスでオーバーライド）"""
        raise NotImplementedError("サブクラスで実装する必要があります")

    def to_dict(self) -> Dict[str, Any]:
        """オブジェクトを辞書に変換"""
        return asdict(self)

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "BaseConfig":
        """辞書からオブジェクトを生成（サブクラスでオーバーライド）"""
        raise NotImplementedError("サブクラスで実装する必要があります")

    def __getitem__(self, key: str) -> Any:
        """辞書風のインデックスアクセスを可能にする"""
        try:
            return getattr(self, key)
        except AttributeError:
            raise KeyError(
                f"'{self.__class__.__name__}' オブジェクトに '{key}' は存在しません"
            )

    def get(self, key: str, default: Optional[Any] = None) -> Any:
        """辞書風のgetメソッドを実装"""
        try:
            return getattr(self, key)
        except AttributeError:
            return default

    def __contains__(self, key: str) -> bool:
        """in演算子をサポート"""
        return hasattr(self, key)


def load_config_safely(
    config_dict: Dict[str, Any], default_dict: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    設定辞書を安全に読み込む

    Args:
        config_dict: 読み込む設定辞書
        default_dict: デフォルト値の辞書

    Returns:
        マージされた設定辞書
    """
    # デフォルト値の設定
    if default_dict is None:
        default_dict = {}

    # 再帰的にデフォルト値をマージ
    def deep_merge(default, override):
        if isinstance(default, dict) and isinstance(override, dict):
            merged = default.copy()
            for key, value in override.items():
                merged[key] = deep_merge(merged.get(key, {}), value)
            return merged
        return override

    return deep_merge(default_dict, config_dict)

```

### simulations/config/interfaces.py

```
"""設定のインターフェースと抽象基底クラス"""

from abc import ABC, abstractmethod
from typing import Dict, Any, TypeVar, Generic


T = TypeVar("T")


class ConfigValidator(ABC, Generic[T]):
    """設定検証のための抽象基底クラス"""

    @abstractmethod
    def validate(self) -> None:
        """設定値の妥当性を検証"""
        pass


class ConfigLoader(ABC, Generic[T]):
    """設定読み込みのための抽象基底クラス"""

    @abstractmethod
    def load(self, config_dict: Dict[str, Any]) -> T:
        """辞書から設定を読み込む"""
        pass


class ConfigSerializer(ABC, Generic[T]):
    """設定のシリアライズ/デシリアライズのインターフェース"""

    @abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        pass

    @classmethod
    @abstractmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> T:
        """辞書から設定を復元"""
        pass

```

### simulations/config/boundary.py

```
"""境界条件の設定を管理するモジュール"""

from dataclasses import dataclass, field
from typing import Dict, Any
from .base import BaseConfig, BoundaryType, load_config_safely


@dataclass
class BoundaryConfig(BaseConfig):
    """境界条件の設定を保持するクラス"""

    x: Dict[str, str] = field(
        default_factory=lambda: {
            "left": BoundaryType.PERIODIC.value,
            "right": BoundaryType.PERIODIC.value,
        }
    )
    y: Dict[str, str] = field(
        default_factory=lambda: {
            "front": BoundaryType.PERIODIC.value,
            "back": BoundaryType.PERIODIC.value,
        }
    )
    z: Dict[str, str] = field(
        default_factory=lambda: {
            "bottom": BoundaryType.NEUMANN.value,
            "top": BoundaryType.NEUMANN.value,
        }
    )

    def validate(self) -> None:
        """境界条件の妥当性を検証"""
        valid_types = {bt.value for bt in BoundaryType}

        # 各方向の境界条件を検証
        for direction_name, direction in [("x", self.x), ("y", self.y), ("z", self.z)]:
            for side, boundary_type in direction.items():
                if boundary_type not in valid_types:
                    raise ValueError(
                        f"{direction_name}方向の{side}境界で無効な境界条件: {boundary_type}"
                    )

    def load(self, config_dict: Dict[str, Any]) -> "BoundaryConfig":
        """辞書から設定を読み込む"""
        # デフォルト値を設定しつつ、入力された値で上書き
        merged_config = load_config_safely(
            config_dict,
            {
                "x": {
                    "left": BoundaryType.PERIODIC.value,
                    "right": BoundaryType.PERIODIC.value,
                },
                "y": {
                    "front": BoundaryType.PERIODIC.value,
                    "back": BoundaryType.PERIODIC.value,
                },
                "z": {
                    "bottom": BoundaryType.NEUMANN.value,
                    "top": BoundaryType.NEUMANN.value,
                },
            },
        )

        return BoundaryConfig(
            x=merged_config.get("x", self.x),
            y=merged_config.get("y", self.y),
            z=merged_config.get("z", self.z),
        )

    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        return {"x": self.x, "y": self.y, "z": self.z}

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "BoundaryConfig":
        """辞書から設定を復元"""
        return cls().load(config_dict)

```

### simulations/config/simulation.py

```
"""シミュレーション全体の設定を管理するモジュール"""

from dataclasses import dataclass, field
from typing import Dict, Any
import yaml

from .base import BaseConfig, load_config_safely
from .physics import PhysicsConfig, DomainConfig
from .numerical import NumericalConfig
from .boundary import BoundaryConfig
from .interface import InterfaceConfig, InitialConditionConfig
from .output import OutputConfig


@dataclass
class SimulationConfig(BaseConfig):
    """シミュレーション全体の設定を保持するクラス"""

    domain: DomainConfig = field(default_factory=DomainConfig)
    physics: PhysicsConfig = field(default_factory=PhysicsConfig)
    boundary_conditions: BoundaryConfig = field(default_factory=BoundaryConfig)
    initial_conditions: InitialConditionConfig = field(
        default_factory=InitialConditionConfig
    )
    numerical: NumericalConfig = field(default_factory=NumericalConfig)
    output: OutputConfig = field(default_factory=OutputConfig)
    interfaces: list[InterfaceConfig] = field(default_factory=list)

    def validate(self) -> None:
        """全体の設定値の妥当性を検証"""
        self.domain.validate()
        self.physics.validate()
        self.boundary_conditions.validate()
        self.initial_conditions.validate()
        self.numerical.validate()
        self.output.validate()

        for interface in self.interfaces:
            interface.validate()

    def load(self, config_dict: Dict[str, Any]) -> "SimulationConfig":
        """辞書から設定を読み込む"""
        # デフォルト値を設定しつつ、入力された値で上書き
        merged_config = load_config_safely(config_dict, {})

        return SimulationConfig(
            domain=DomainConfig.from_dict(merged_config.get("domain", {})),
            physics=PhysicsConfig.from_dict(merged_config.get("physics", {})),
            boundary_conditions=BoundaryConfig.from_dict(
                merged_config.get("boundary_conditions", {})
            ),
            initial_conditions=InitialConditionConfig.from_dict(
                merged_config.get("initial_conditions", {})
            ),
            numerical=NumericalConfig.from_dict(merged_config.get("numerical", {})),
            output=OutputConfig.from_dict(merged_config.get("output", {})),
            interfaces=[
                InterfaceConfig.from_dict(obj)
                for obj in merged_config.get("interfaces", [])
            ],
        )

    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        return {
            "domain": self.domain.to_dict(),
            "physics": self.physics.to_dict(),
            "boundary_conditions": self.boundary_conditions.to_dict(),
            "initial_conditions": self.initial_conditions.to_dict(),
            "numerical": self.numerical.to_dict(),
            "output": self.output.to_dict(),
            "interfaces": [interface.to_dict() for interface in self.interfaces],
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "SimulationConfig":
        """辞書から設定を復元"""
        return cls().load(config_dict)

    @classmethod
    def from_yaml(cls, filepath: str) -> "SimulationConfig":
        """YAMLファイルから設定を読み込む"""
        with open(filepath, "r", encoding="utf-8") as f:
            config_dict = yaml.safe_load(f)
        return cls.from_dict(config_dict)

```

### simulations/config/__init__.py

```
"""設定管理パッケージの初期化"""

from .base import BaseConfig, Phase, BoundaryType, load_config_safely
from .interfaces import ConfigValidator, ConfigLoader, ConfigSerializer
from .physics import PhysicsConfig, DomainConfig
from .numerical import NumericalConfig
from .boundary import BoundaryConfig
from .interface import InterfaceConfig, InitialConditionConfig
from .output import OutputConfig
from .simulation import SimulationConfig

__all__ = [
    # 基本的な設定クラス
    "SimulationConfig",
    # 基底クラスとインターフェース
    "BaseConfig",
    "ConfigValidator",
    "ConfigLoader",
    "ConfigSerializer",
    # 列挙型
    "Phase",
    "BoundaryType",
    # 個別の設定クラス
    "PhysicsConfig",
    "DomainConfig",
    "NumericalConfig",
    "BoundaryConfig",
    "InterfaceConfig",
    "InitialConditionConfig",
    "OutputConfig",
    # ユーティリティ関数
    "load_config_safely",
]

```

### simulations/config/numerical.py

```
"""数値計算の設定を管理するモジュール"""

from dataclasses import dataclass
from typing import Dict, Any
from .base import BaseConfig, load_config_safely


@dataclass
class NumericalConfig(BaseConfig):
    """数値計算の設定を保持するクラス"""

    time_integrator: str = "euler"
    max_time: float = 2.0
    initial_dt: float = 0.001
    save_interval: float = 0.01
    cfl: float = 0.5
    min_dt: float = 1.0e-6
    max_dt: float = 1.0
    level_set_epsilon: float = 1.0e-2
    level_set_reinit_interval: int = 10  # より適切なデフォルト値に更新
    level_set_reinit_steps: int = 2

    def validate(self) -> None:
        """数値設定の妥当性を検証"""
        # 時間積分器のバリデーション
        if self.time_integrator not in ["euler", "rk4"]:
            raise ValueError("time_integratorはeulerまたはrk4である必要があります")

        # 時間関連パラメータのバリデーション
        if self.max_time <= 0:
            raise ValueError("max_timeは正の値である必要があります")
        if self.initial_dt <= 0:
            raise ValueError("initial_dtは正の値である必要があります")
        if self.save_interval <= 0:
            raise ValueError("save_intervalは正の値である必要があります")
        if not 0 < self.cfl <= 1:
            raise ValueError("cflは0から1の間である必要があります")
        if self.min_dt <= 0:
            raise ValueError("min_dtは正の値である必要があります")
        if self.max_dt <= self.min_dt:
            raise ValueError("max_dtはmin_dtより大きい必要があります")

        # Level Set関連パラメータのバリデーション
        if self.level_set_epsilon <= 0:
            raise ValueError("level_set_epsilonは正の値である必要があります")
        if self.level_set_reinit_interval <= 0:
            raise ValueError("level_set_reinit_intervalは正の値である必要があります")
        if self.level_set_reinit_steps <= 0:
            raise ValueError("level_set_reinit_stepsは正の値である必要があります")

    def load(self, config_dict: Dict[str, Any]) -> "NumericalConfig":
        """辞書から設定を読み込む"""
        # デフォルト値を設定しつつ、入力された値で上書き
        merged_config = load_config_safely(
            config_dict,
            {
                "time_integrator": "euler",
                "max_time": 2.0,
                "initial_dt": 0.001,
                "save_interval": 0.01,
                "cfl": 0.5,
                "min_dt": 1.0e-6,
                "max_dt": 1.0,
                "level_set": {
                    "epsilon": 1.0e-2,
                    "reinit_interval": 10,  # デフォルト値を更新
                    "reinit_steps": 2,
                },
            },
        )

        # Level Set関連パラメータの特別な処理
        level_set_config = merged_config.get("level_set", {})

        return NumericalConfig(
            time_integrator=merged_config.get("time_integrator", "euler"),
            max_time=merged_config.get("max_time", 2.0),
            initial_dt=merged_config.get("initial_dt", 0.001),
            save_interval=merged_config.get("save_interval", 0.01),
            cfl=merged_config.get("cfl", 0.5),
            min_dt=merged_config.get("min_dt", 1.0e-6),
            max_dt=merged_config.get("max_dt", 1.0),
            level_set_epsilon=level_set_config.get("epsilon", 1.0e-2),
            level_set_reinit_interval=level_set_config.get(
                "reinit_interval", 10
            ),  # デフォルト値を更新
            level_set_reinit_steps=level_set_config.get("reinit_steps", 2),
        )

    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        return {
            "time_integrator": self.time_integrator,
            "max_time": self.max_time,
            "initial_dt": self.initial_dt,
            "save_interval": self.save_interval,
            "cfl": self.cfl,
            "min_dt": self.min_dt,
            "max_dt": self.max_dt,
            "level_set": {
                "epsilon": self.level_set_epsilon,
                "reinit_interval": self.level_set_reinit_interval,
                "reinit_steps": self.level_set_reinit_steps,
            },
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "NumericalConfig":
        """辞書から設定を復元"""
        return cls().load(config_dict)

```

### simulations/config/physics.py

```
"""物理パラメータの設定を管理するモジュール"""

from dataclasses import dataclass, field
from typing import Dict, Any, List
from .base import BaseConfig


@dataclass
class PhaseConfig(BaseConfig):
    """流体の物性値を保持するクラス"""

    phase: str  # 相の名前
    density: float = 1000.0  # 密度 [kg/m³]
    viscosity: float = 1.0e-3  # 動粘性係数 [Pa·s]
    surface_tension: float = 0.0  # 表面張力係数 [N/m]

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        if not self.phase:
            raise ValueError("相の名前は必須です")
        if self.density <= 0:
            raise ValueError("密度は正の値である必要があります")
        if self.viscosity <= 0:
            raise ValueError("粘性は正の値である必要があります")
        if self.surface_tension < 0:
            raise ValueError("表面張力は非負である必要があります")

    def load(self, config_dict: Dict[str, Any]) -> "PhaseConfig":
        """辞書から設定を読み込む"""
        # phaseは必須なので、渡されていない場合は現在の値を使用
        phase = config_dict.get("phase", self.phase)
        return PhaseConfig(
            phase=phase,
            density=config_dict.get("density", self.density),
            viscosity=config_dict.get("viscosity", self.viscosity),
            surface_tension=config_dict.get("surface_tension", self.surface_tension),
        )

    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        return {
            "phase": self.phase,
            "density": self.density,
            "viscosity": self.viscosity,
            "surface_tension": self.surface_tension,
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "PhaseConfig":
        """辞書から設定を復元"""
        if "phase" not in config_dict:
            raise ValueError("相の名前(phase)は必須です")
        return cls(
            phase=config_dict["phase"],
            density=config_dict.get("density", 1000.0),
            viscosity=config_dict.get("viscosity", 1.0e-3),
            surface_tension=config_dict.get("surface_tension", 0.0),
        )


@dataclass
class PhysicsConfig(BaseConfig):
    """物理パラメータの設定を保持するクラス"""

    gravity: float = 9.81  # 重力加速度 [m/s²]
    surface_tension: float = 0.072  # 表面張力係数 [N/m]
    phases: List[PhaseConfig] = field(default_factory=list)  # 相の設定リスト

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        if self.gravity <= 0:
            raise ValueError("重力加速度は正の値である必要があります")
        if self.surface_tension < 0:
            raise ValueError("表面張力係数は非負である必要があります")
        for phase in self.phases:
            phase.validate()

    def load(self, config_dict: Dict[str, Any]) -> "PhysicsConfig":
        """辞書から設定を読み込む"""
        phases = []
        for phase_dict in config_dict.get("phases", []):
            phase = PhaseConfig.from_dict(phase_dict)
            phases.append(phase)

        return PhysicsConfig(
            gravity=config_dict.get("gravity", self.gravity),
            surface_tension=config_dict.get("surface_tension", self.surface_tension),
            phases=phases,
        )

    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        return {
            "gravity": self.gravity,
            "surface_tension": self.surface_tension,
            "phases": [phase.to_dict() for phase in self.phases],
        }

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "PhysicsConfig":
        """辞書から設定を復元"""
        return cls().load(config_dict)

    def get_phase_by_name(self, name: str) -> PhaseConfig:
        """名前で相の設定を取得"""
        for phase in self.phases:
            if phase.phase.lower() == name.lower():
                return phase
        raise ValueError(f"指定された相が見つかりません: {name}")


@dataclass
class DomainConfig(BaseConfig):
    """計算領域の設定を保持するクラス"""

    dimensions: List[int] = field(
        default_factory=lambda: [32, 32, 32]
    )  # [nx, ny, nz]の格子点数
    size: List[float] = field(
        default_factory=lambda: [1.0, 1.0, 1.0]
    )  # [Lx, Ly, Lz]の物理サイズ [m]

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        if not all(isinstance(dim, int) and dim > 0 for dim in self.dimensions):
            raise ValueError("格子点数は正の整数である必要があります")
        if not all(isinstance(size, (int, float)) and size > 0 for size in self.size):
            raise ValueError("領域サイズは正の値である必要があります")
        if len(self.dimensions) != len(self.size):
            raise ValueError("dimensionsとsizeは同じ次元数である必要があります")
        if not (2 <= len(self.dimensions) <= 3):
            raise ValueError("2次元または3次元である必要があります")

    def load(self, config_dict: Dict[str, Any]) -> "DomainConfig":
        """辞書から設定を読み込む"""
        return DomainConfig(
            dimensions=config_dict.get("dimensions", self.dimensions),
            size=[float(s) for s in config_dict.get("size", self.size)],
        )

    def to_dict(self) -> Dict[str, Any]:
        """設定を辞書形式にシリアライズ"""
        return {"dimensions": self.dimensions, "size": self.size}

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "DomainConfig":
        """辞書から設定を復元"""
        return cls().load(config_dict)

```

### simulations/state.py

```
"""
シミュレーションの状態を管理するモジュール

このモジュールは、二相流シミュレーションの状態（速度場、界面関数、圧力場など）を
管理するためのデータクラスを提供します。
"""

from dataclasses import dataclass
from typing import Dict, Any
import numpy as np

from core.field import VectorField, ScalarField
from physics.multiphase import InterfaceOperations


@dataclass
class SimulationState:
    """シミュレーションの状態を保持するクラス

    物理量の場や時刻情報を保持し、状態の保存・読み込みも担当します。
    """

    time: float
    velocity: VectorField
    levelset: ScalarField  # ScalarFieldとして定義
    pressure: ScalarField
    diagnostics: Dict[str, Any] = None

    def __post_init__(self):
        """初期化後の処理"""
        if self.diagnostics is None:
            self.diagnostics = {}

        # 界面演算子の初期化（ベクトル化されたdxを使用）
        self._interface_ops = InterfaceOperations(
            dx=self.velocity.dx,  # VectorFieldのdxを使用
            epsilon=1e-2,  # デフォルトのepsilon値
        )

    def validate(self) -> None:
        """状態の妥当性を検証"""
        if self.time < 0:
            raise ValueError("時刻は非負である必要があります")

        shapes = {
            "velocity": self.velocity.shape,
            "levelset": self.levelset.shape,
            "pressure": self.pressure.shape,
        }
        if len(set(shapes.values())) > 1:
            raise ValueError(f"場の形状が一致しません: {shapes}")

    def get_phase_distribution(self) -> ScalarField:
        """密度場を計算"""
        # InterfaceOperationsのメソッドを使用
        return self._interface_ops.get_phase_distribution(self.levelset)

    def get_viscosity(self, physics_config) -> ScalarField:
        """粘性場を計算

        Args:
            physics_config: 物理設定

        Returns:
            粘性場
        """
        # 相の物性値から粘性場を計算
        phases = physics_config.phases
        return self._interface_ops.get_property_field(
            self.levelset, value1=phases[0].viscosity, value2=phases[1].viscosity
        )

    def get_density(self, physics_config) -> ScalarField:
        """密度場を計算

        Args:
            physics_config: 物理設定

        Returns:
            密度場
        """
        # 相の物性値から密度場を計算
        phases = physics_config.phases
        return self._interface_ops.get_property_field(
            self.levelset, value1=phases[0].density, value2=phases[1].density
        )

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        # 界面の診断情報を取得
        interface_diagnostics = self._interface_ops.get_diagnostics(self.levelset)

        return {
            "time": self.time,
            "velocity_max": float(
                np.max([np.abs(v.data).max() for v in self.velocity.components])
            ),
            "pressure_max": float(np.abs(self.pressure.data).max()),
            "levelset_min": float(self.levelset.data.min()),
            "levelset_max": float(self.levelset.data.max()),
            "interface_geometry": interface_diagnostics,
            **self.diagnostics,
        }

    def copy(self) -> "SimulationState":
        """状態の深いコピーを作成

        Returns:
            コピーされた状態
        """
        return SimulationState(
            time=self.time,
            velocity=self.velocity.copy(),
            levelset=ScalarField(
                self.levelset.shape, self.levelset.dx, self.levelset.data.copy()
            ),
            pressure=self.pressure.copy(),
            diagnostics=self.diagnostics.copy() if self.diagnostics else None,
        )

    def update(self, derivative: "SimulationState", dt: float) -> None:
        """状態を更新

        Args:
            derivative: 時間微分
            dt: 時間刻み幅
        """
        self.time += dt
        for i, comp in enumerate(self.velocity.components):
            comp.data += dt * derivative.velocity.components[i].data
        self.levelset.data += dt * derivative.levelset.data
        self.pressure.data += dt * derivative.pressure.data

    def save_state(self, filepath: str) -> None:
        """状態をファイルに保存

        Args:
            filepath: 保存先のファイルパス
        """
        np.savez_compressed(
            filepath,
            time=self.time,
            velocity_data=[v.data for v in self.velocity.components],
            levelset_data=self.levelset.data,
            pressure_data=self.pressure.data,
            diagnostics=self.diagnostics,
        )

    @classmethod
    def load_state(cls, filepath: str) -> "SimulationState":
        """ファイルから状態を読み込み

        Args:
            filepath: 読み込むファイルのパス

        Returns:
            読み込まれたシミュレーション状態
        """
        data = np.load(filepath)

        # 速度場の再構築
        velocity_shape = data["velocity_data"][0].shape
        velocity = VectorField(velocity_shape)
        for i, v_data in enumerate(data["velocity_data"]):
            velocity.components[i].data = v_data

        # 界面関数の再構築
        levelset = ScalarField(data["levelset_data"].shape)
        levelset.data = data["levelset_data"]

        # 圧力場の再構築
        pressure = ScalarField(data["pressure_data"].shape)
        pressure.data = data["pressure_data"]

        return cls(
            time=float(data["time"]),
            velocity=velocity,
            levelset=levelset,
            pressure=pressure,
            diagnostics=data["diagnostics"].item(),
        )

```

### simulations/simulation.py

```
"""
二相流シミュレーションの統合的な実装

このモジュールは、Level Set法を用いた二相流体シミュレーションの
物理過程を統合的に取り扱います。

主な機能:
1. ScalarFieldからの物性値計算
2. 外力（表面張力・重力）の計算
3. 圧力ポアソン方程式の解法
4. Navier-Stokes方程式の解法
5. 界面関数の時間発展
"""

from __future__ import annotations
from typing import Dict, Any, Optional, Tuple
import numpy as np

from core.field import VectorField, ScalarField
from core.solver import TemporalSolver
from numerics.time_evolution import ForwardEuler

from physics.multiphase import InterfaceOperations
from physics.navier_stokes import NavierStokesSolver
from physics.pressure import PressurePoissonSolver
from physics.continuity import ContinuityEquation

from .config import SimulationConfig
from .state import SimulationState
from .initializer import SimulationInitializer


class TwoPhaseFlowSimulator:
    """
    二相流シミュレーションの統合的なソルバー

    複雑な物理過程を統合的に解くための高度なシミュレーションフレームワーク。
    """

    def __init__(
        self, config: SimulationConfig, time_integrator: Optional[TemporalSolver] = None
    ):
        """
        シミュレータを初期化

        Args:
            config: シミュレーション設定
            time_integrator: 時間積分器（指定しない場合は自動選択）
        """
        self.config = config
        self._state: Optional[SimulationState] = None
        self._diagnostics: Dict[str, Any] = {}

        # グリッド間隔の計算
        self.dx = np.array(
            [
                size / (dim - 1)
                for size, dim in zip(
                    self.config.domain.size, self.config.domain.dimensions
                )
            ]
        )

        # InterfaceOperationsの初期化
        interface_config = config.numerical.get("interface", {})
        self._interface_ops = InterfaceOperations(
            dx=self.dx,
            epsilon=interface_config.get("epsilon", 1e-2),
        )

        # 時間積分器の設定
        self._time_solver = time_integrator or ForwardEuler(
            cfl=config.numerical.cfl,
            min_dt=config.numerical.min_dt,
            max_dt=config.numerical.max_dt,
        )

        # ソルバーの初期化
        self._setup_solvers()

    def _setup_solvers(self):
        """
        物理計算用のソルバーを初期化
        """
        # 表面張力係数の計算
        surface_tension_coeff = 0.0
        if len(self.config.physics.phases) >= 2:
            surface_tension_coeff = abs(
                self.config.physics.phases[0].surface_tension
                - self.config.physics.phases[1].surface_tension
            )

        # ソルバーの初期化
        self._navier_stokes_solver = NavierStokesSolver()
        self._pressure_solver = PressurePoissonSolver()
        self._continuity_solver = ContinuityEquation()

    def step_forward(
        self, state: Optional[SimulationState] = None, dt: Optional[float] = None
    ) -> Tuple[SimulationState, Dict[str, Any]]:
        """
        シミュレーションを1ステップ進める

        Args:
            state: 現在の状態（Noneの場合は内部状態を使用）
            dt: 時間刻み幅（Noneの場合は自動計算）

        Returns:
            (更新された状態, 診断情報)のタプル
        """
        # 状態の確認と取得
        if state is None:
            state = self._state
            if state is None:
                raise ValueError("シミュレーション状態が初期化されていません")

        # 時間刻み幅の計算
        if dt is None:
            dt = self._time_solver.compute_timestep(state.velocity)

        # 物性値の計算
        density = state.get_density(self.config.physics)
        viscosity = state.get_viscosity(self.config.physics)

        # 外力の計算
        external_forces = self._compute_external_forces(state)

        # 圧力場の計算
        pressure, pressure_diagnostics = self._compute_pressure(
            state.velocity, density, viscosity, external_forces
        )

        # 速度とレベルセットの時間微分を計算
        velocity_derivative = self._navier_stokes_solver.compute(
            velocity=state.velocity,
            density=density,
            viscosity=viscosity,
            pressure=pressure,
            force=external_forces,
        )

        levelset_derivative = self._continuity_solver.compute_derivative(
            field=state.levelset, velocity=state.velocity
        )

        # 時間積分
        new_velocity = self._time_solver.integrate(
            field=state.velocity, derivative=velocity_derivative, dt=dt
        )
        new_levelset = self._time_solver.integrate(
            field=state.levelset, derivative=levelset_derivative, dt=dt
        )

        # レベルセット関数の再初期化
        if self._should_reinitialize(state):
            new_levelset.data = self._interface_ops.reinitialize(
                new_levelset,
                n_steps=self.config.numerical.get("interface", {}).get(
                    "reinit_steps", 2
                ),
            ).data

        # 新しい状態の作成
        new_state = SimulationState(
            time=state.time + dt,
            velocity=new_velocity,
            levelset=new_levelset,
            pressure=pressure,
        )

        # 診断情報の更新
        diagnostics = {
            "time": new_state.time,
            "dt": dt,
            **pressure_diagnostics,
        }
        self._diagnostics = diagnostics

        # 現在の状態を更新
        self._state = new_state

        return new_state, diagnostics

    def _compute_external_forces(self, state: SimulationState) -> VectorField:
        """外力（重力と界面張力）を計算

        Args:
            state: シミュレーション状態

        Returns:
            外力のベクトル場
        """
        # base_shape を使用して、追加の次元を除外
        base_shape = state.velocity.shape[:-1]  # 最後の次元を除外
        gravity_force = VectorField(base_shape, self.dx)
        density = state.get_density(self.config.physics)

        for i, comp in enumerate(gravity_force.components):
            # 最後の次元（z方向）にのみ重力を適用
            if (
                i == len(state.velocity.shape) - 2
            ):  # -2 because shape has an extra dimension
                comp.data = -self.config.physics.gravity * density.data
            else:
                comp.data = np.zeros(density.shape)

        # TODO: 界面張力の計算が必要な場合は追加
        return gravity_force

    def _compute_pressure(
        self,
        velocity: VectorField,
        density: ScalarField,
        viscosity: ScalarField,
        external_force: VectorField,
    ) -> Tuple[ScalarField, Dict[str, Any]]:
        """
        圧力場を計算

        Args:
            velocity: 速度場
            density: 密度場
            viscosity: 粘性場
            external_force: 外力場

        Returns:
            (圧力場, 診断情報)のタプル
        """
        # 圧力場の計算
        pressure, solver_diagnostics = self._pressure_solver.solve(
            density=density.data,
            velocity=velocity,
            viscosity=viscosity,
            external_force=external_force,
        )

        # 診断情報の更新
        self._diagnostics.update(solver_diagnostics)

        return pressure, solver_diagnostics

    def _should_reinitialize(self, state: SimulationState) -> bool:
        """
        界面関数の再初期化が必要か判定

        Args:
            state: シミュレーション状態

        Returns:
            再初期化が必要かどうか
        """
        interface_config = self.config.numerical.get("interface", {})
        reinit_interval = interface_config.get("reinit_interval", 10)
        if reinit_interval <= 0:
            return False

        # 時間ベースでの再初期化チェック
        current_step = int(state.time / self.config.numerical.initial_dt)
        return current_step % reinit_interval == 0

    def initialize(self, state: Optional[SimulationState] = None):
        """
        シミュレーションを初期化

        Args:
            state: 初期状態（Noneの場合は設定から自動生成）
        """
        if state is None:
            initializer = SimulationInitializer(self.config)
            state = initializer.create_initial_state()

        self._state = state

    def get_state(self) -> Tuple[SimulationState, Dict[str, Any]]:
        """
        現在のシミュレーション状態を取得

        Returns:
            (現在の状態, 診断情報)のタプル
        """
        if self._state is None:
            raise ValueError("シミュレーション状態が初期化されていません")

        return self._state, self._state.get_diagnostics()

    def save_checkpoint(self, filepath: str):
        """
        現在の状態をチェックポイントとして保存

        Args:
            filepath: 保存先のファイルパス
        """
        if self._state is None:
            raise ValueError("シミュレーション状態が初期化されていません")

        self._state.save_state(filepath)

    def load_checkpoint(self, filepath: str) -> SimulationState:
        """
        チェックポイントから状態を読み込み

        Args:
            filepath: 読み込むチェックポイントファイルのパス

        Returns:
            読み込まれた状態
        """
        return SimulationState.load_state(filepath)

```

### simulations/__init__.py

```
from .simulation import TwoPhaseFlowSimulator
from .state import SimulationState
from .initializer import SimulationInitializer
from .config import (
    DomainConfig,
    PhysicsConfig,
    InterfaceConfig,
    SimulationConfig,
)

__all__ = [
    "TwoPhaseFlowSimulator",
    "SimulationState",
    "SimulationInitializer",
    "SimulationConfig",
    "DomainConfig",
    "PhysicsConfig",
    "InterfaceConfig",
    "SimulationConfig",
]

```

### visualization/core/base.py

```
"""可視化システムの基本クラスとインターフェースを提供するモジュール

このモジュールは可視化システムの設定とインターフェースを定義します。すべての
可視化コンポーネントの基盤となります。
"""

from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Union, Tuple
from pathlib import Path


@dataclass
class ViewConfig:
    """可視化の表示設定

    3D表示やスライス表示の視点・断面を制御します。

    Attributes:
        elevation: 仰角（度）
        azimuth: 方位角（度）
        distance: 視点距離
        focal_point: 注視点座標 (x, y, z)
        slice_positions: 各軸でのスライス位置 [0-1]
        slice_axes: 表示する断面の軸 (例: ["xy", "yz", "xz"])
    """

    elevation: float = 30.0
    azimuth: float = 45.0
    distance: float = 10.0
    focal_point: Tuple[float, float, float] = (0.5, 0.5, 0.5)
    slice_positions: List[float] = field(default_factory=lambda: [0.5, 0.5, 0.5])
    slice_axes: List[str] = field(default_factory=lambda: ["xy", "yz", "xz"])

    def validate(self):
        """設定値の検証"""
        if len(self.slice_positions) != 3:
            raise ValueError("slice_positionsは3つの要素を持つ必要があります")
        if any(not 0 <= pos <= 1 for pos in self.slice_positions):
            raise ValueError("slice_positionsは0から1の間である必要があります")
        valid_axes = {"xy", "yz", "xz", "yx", "zy", "zx"}
        if any(axis not in valid_axes for axis in self.slice_axes):
            raise ValueError(f"無効なslice_axes: {valid_axes}から選択してください")


@dataclass
class VisualizationConfig:
    """可視化の基本設定

    出力形式や表示オプションを制御します。

    Attributes:
        output_dir: 出力ディレクトリ
        format: 出力フォーマット
        dpi: 解像度
        colormap: デフォルトのカラーマップ
        show_colorbar: カラーバーの表示
        show_axes: 軸の表示
        show_grid: グリッドの表示
        fields: フィールドごとの可視化設定
    """

    output_dir: Union[str, Path] = "results/visualization"
    format: str = "png"
    dpi: int = 300
    colormap: str = "viridis"
    show_colorbar: bool = True
    show_axes: bool = True
    show_grid: bool = False

    # フィールドごとの可視化設定
    fields: Dict[str, Dict[str, Any]] = field(
        default_factory=lambda: {
            "velocity": {
                "enabled": True,
                "plot_types": ["vector", "magnitude"],
                "scale": 1.0,
                "density": 20,
                "color": "black",
                "alpha": 0.7,
            },
            "pressure": {
                "enabled": True,
                "plot_types": ["scalar", "contour"],
                "levels": 20,
                "alpha": 0.5,
            },
            "levelset": {
                "enabled": True,
                "plot_types": ["interface", "contour"],
                "levels": [0],
                "colors": ["black"],
                "linewidth": 2.0,
            },
        }
    )

    def __post_init__(self):
        """設定の後処理と検証"""
        if isinstance(self.output_dir, str):
            self.output_dir = Path(self.output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def get_output_path(self, name: str, timestamp: Optional[float] = None) -> Path:
        """出力ファイルパスを生成

        Args:
            name: ベース名
            timestamp: タイムスタンプ（オプション）

        Returns:
            生成されたパス
        """
        if timestamp is not None:
            filename = f"{name}_{timestamp:.6f}.{self.format}"
        else:
            filename = f"{name}.{self.format}"
        return self.output_dir / filename

    def get_field_config(
        self, section: str, default: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """指定されたセクションの設定を取得

        Args:
            section: 設定セクション名
            default: デフォルト値（オプション）

        Returns:
            設定辞書（存在しない場合はデフォルト設定）
        """
        import yaml
        import os

        # コンフィグファイルの読み込み
        config_path = os.path.join(os.getcwd(), "config.yaml")

        try:
            with open(config_path, "r") as f:
                full_config = yaml.safe_load(f)

            # 指定されたセクションの設定を取得
            section_config = full_config.get(section, {})
            return section_config
        except Exception as e:
            print(f"設定ファイルの読み込み中にエラー: {e}")
            return default or {}

    @classmethod
    def from_dict(cls, config: Dict[str, Any]) -> "VisualizationConfig":
        """辞書から設定を作成

        Args:
            config: 設定辞書

        Returns:
            設定インスタンス
        """
        # 基本設定の取得
        base_config = {
            "output_dir": config.get("output_dir", "results/visualization"),
            "format": config.get("format", "png"),
            "dpi": config.get("dpi", 300),
            "colormap": config.get("colormap", "viridis"),
            "show_colorbar": config.get("show_colorbar", True),
            "show_axes": config.get("show_axes", True),
            "show_grid": config.get("show_grid", False),
        }

        # フィールド設定の取得とマージ
        fields = {}
        for field_name, field_config in config.get("fields", {}).items():
            fields[field_name] = {
                "enabled": field_config.get("enabled", True),
                "plot_types": field_config.get("plot_types", ["scalar"]),
                **field_config,
            }

        return cls(**base_config, fields=fields)


class Exporter:
    """エクスポーターの基底クラス

    描画結果をファイルとして出力する基底クラス
    """

    def __init__(self, config: VisualizationConfig):
        """エクスポーターを初期化

        Args:
            config: 可視化設定
        """
        self.config = config

    def export(
        self, figure: Any, filepath: Path, metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """描画結果を出力

        Args:
            figure: 描画結果
            filepath: 出力パス
            metadata: メタデータ（オプション）
        """
        raise NotImplementedError("サブクラスで実装する必要があります")

```

### visualization/core/exporter.py

```
"""可視化結果のエクスポートを提供するモジュール

このモジュールは、Matplotlibの描画結果を画像ファイルとして
出力する機能を実装します。
"""

import json
from pathlib import Path
from typing import Dict, Any, Optional
import matplotlib.pyplot as plt

from .base import Exporter, VisualizationConfig


class ImageExporter(Exporter):
    """画像エクスポーター

    Matplotlibの描画結果を画像ファイルとして出力します。
    メタデータもJSONファイルとして保存できます。
    """

    def __init__(self, config: VisualizationConfig):
        """画像エクスポーターを初期化"""
        super().__init__(config)

    def export(
        self,
        figure: plt.Figure,
        filepath: Path,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> None:
        """描画結果を画像として出力

        Args:
            figure: Matplotlibの図
            filepath: 出力ファイルパス
            metadata: メタデータ（オプション）
        """
        # 出力ディレクトリの作成
        filepath.parent.mkdir(parents=True, exist_ok=True)

        # 画像として保存
        figure.savefig(
            filepath,
            dpi=self.config.dpi,
            format=self.config.format,
            bbox_inches="tight",
        )

        # メタデータの保存
        if metadata is not None:
            metadata_path = filepath.with_suffix(".json")
            with open(metadata_path, "w", encoding="utf-8") as f:
                json.dump(metadata, f, indent=2, ensure_ascii=False)

        # 図のクリーンアップ
        plt.close(figure)

```

### visualization/core/renderer.py

```
"""レンダリングエンジンの基底クラスを提供するモジュール

このモジュールは、2D/3Dレンダリングの基本機能を提供します。
matplotlibを使用した描画処理の共通部分を実装します。
"""

from abc import ABC, abstractmethod
from typing import Tuple, Dict, Any, Optional, List, Union, TYPE_CHECKING
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.axes import Axes
from matplotlib import colormaps
from matplotlib.colors import Normalize, LinearSegmentedColormap
from matplotlib.collections import QuadMesh

if TYPE_CHECKING:
    from .base import VisualizationConfig, ViewConfig


class BaseRenderer(ABC):
    """レンダラーの基底クラス

    全てのレンダラーに共通の機能を提供します。
    """

    def __init__(self, config: "VisualizationConfig"):
        """レンダラーを初期化

        Args:
            config: 可視化設定
        """
        self.config = config

    def create_figure(
        self, projection: Optional[str] = None, figsize: Tuple[float, float] = (10, 8)
    ) -> Tuple[Figure, Axes]:
        """図とAxesを作成

        Args:
            projection: プロジェクションの種類
            figsize: 図のサイズ

        Returns:
            (図, Axes)のタプル
        """
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection=projection)

        # 軸の設定
        if not self.config.show_axes:
            ax.set_axis_off()

        # グリッドの設定
        if self.config.show_grid:
            ax.grid(True)

        return fig, ax

    def setup_colorbar(
        self,
        mappable: Union[QuadMesh, plt.cm.ScalarMappable],
        ax: Axes,
        label: str = "",
        orientation: str = "vertical",
    ) -> Optional[Any]:
        """カラーバーを設定

        Args:
            mappable: カラーマップを持つオブジェクト
            ax: 対象のAxes
            label: カラーバーのラベル
            orientation: カラーバーの向き

        Returns:
            作成されたカラーバー
        """
        if self.config.show_colorbar:
            return plt.colorbar(mappable, ax=ax, label=label, orientation=orientation)
        return None

    def compute_data_range(
        self,
        data: np.ndarray,
        symmetric: bool = False,
        robust: bool = True,
        percentile: float = 2.0,
    ) -> Tuple[float, float]:
        """データの範囲を計算

        Args:
            data: 入力データ
            symmetric: 対称な範囲にするかどうか
            robust: 外れ値に対してロバストな範囲を使用するか
            percentile: ロバスト範囲計算時のパーセンタイル

        Returns:
            (最小値, 最大値)のタプル
        """
        valid_data = data[np.isfinite(data)]
        if len(valid_data) == 0:
            return 0.0, 1.0

        if robust:
            vmin = np.percentile(valid_data, percentile)
            vmax = np.percentile(valid_data, 100 - percentile)
        else:
            vmin = np.min(valid_data)
            vmax = np.max(valid_data)

        if symmetric:
            abs_max = max(abs(vmin), abs(vmax))
            return -abs_max, abs_max

        return vmin, vmax

    def create_normalizer(
        self, data: np.ndarray, symmetric: bool = False, robust: bool = True
    ) -> Normalize:
        """データの正規化オブジェクトを作成

        Args:
            data: 入力データ
            symmetric: 対称な範囲にするかどうか
            robust: 外れ値に対してロバストな範囲を使用するか

        Returns:
            正規化オブジェクト
        """
        vmin, vmax = self.compute_data_range(data, symmetric, robust)
        return Normalize(vmin=vmin, vmax=vmax)

    def create_colormap(
        self,
        name: Optional[str] = None,
        colors: Optional[List[str]] = None,
        reverse: bool = False,
    ) -> LinearSegmentedColormap:
        """カラーマップを作成

        Args:
            name: カラーマップ名（Noneの場合はcolorsを使用）
            colors: カラーのリスト
            reverse: カラーマップを反転するかどうか

        Returns:
            作成されたカラーマップ
        """
        if colors is not None:
            cmap = LinearSegmentedColormap.from_list("custom", colors)
        else:
            cmap = colormaps[name or self.config.colormap]

        if reverse:
            return LinearSegmentedColormap.from_list(
                f"{cmap.name}_r", cmap(np.linspace(1, 0, cmap.N))
            )
        return cmap

    @abstractmethod
    def render(self, *args, **kwargs) -> Tuple[Figure, Dict[str, Any]]:
        """描画を実行

        Args:
            *args: 位置引数
            **kwargs: キーワード引数

        Returns:
            (図, メタデータの辞書)のタプル
        """
        pass


class Renderer2D(BaseRenderer):
    """2Dレンダラーの基底クラス"""

    def setup_2d_axes(
        self,
        ax: Axes,
        extent: Optional[Tuple[float, float, float, float]] = None,
        aspect: str = "equal",
    ) -> None:
        """2D軸を設定

        Args:
            ax: 対象のAxes
            extent: データの表示範囲 [xmin, xmax, ymin, ymax]
            aspect: アスペクト比の設定
        """
        if extent is not None:
            ax.set_xlim(extent[0], extent[1])
            ax.set_ylim(extent[2], extent[3])

        ax.set_aspect(aspect)

        if self.config.show_axes:
            ax.set_xlabel("X")
            ax.set_ylabel("Y")

    def create_slice(self, data: np.ndarray, axis: int, position: float) -> np.ndarray:
        """3Dデータから2Dスライスを抽出

        Args:
            data: 3Dデータ
            axis: スライスする軸
            position: スライス位置（0-1）

        Returns:
            抽出された2Dスライス
        """
        if data.ndim != 3:
            raise ValueError("3Dデータが必要です")

        # スライスインデックスを計算
        idx = int(position * (data.shape[axis] - 1))

        # データのスライスを取得
        slices = [slice(None)] * 3
        slices[axis] = slice(idx, idx + 1)
        slice_data = data[tuple(slices)]

        # 余分な次元を削除
        return np.squeeze(slice_data)


class Renderer3D(BaseRenderer):
    """3Dレンダラーの基底クラス"""

    def setup_3d_axes(
        self,
        ax: Axes,
        view: Optional["ViewConfig"] = None,
        bounds: Optional[Tuple[np.ndarray, np.ndarray]] = None,
    ) -> None:
        """3D軸を設定

        Args:
            ax: 対象のAxes
            view: 視点設定
            bounds: データの境界 [(xmin, ymin, zmin), (xmax, ymax, zmax)]
        """
        if view is not None:
            ax.view_init(elev=view.elevation, azim=view.azimuth)
            ax.dist = view.distance

        if bounds is not None:
            min_point, max_point = bounds
            ax.set_xlim(min_point[0], max_point[0])
            ax.set_ylim(min_point[1], max_point[1])
            ax.set_zlim(min_point[2], max_point[2])

        if self.config.show_axes:
            ax.set_xlabel("X")
            ax.set_ylabel("Y")
            ax.set_zlabel("Z")

```

### visualization/core/__init__.py

```
"""可視化システムのコアモジュール

このパッケージは、可視化システムの中核となる基底クラスとインターフェースを提供します。
"""

# 基本的な設定とインターフェースを先にインポート
from .base import VisualizationConfig, ViewConfig

# その後でレンダラーをインポート
from .renderer import BaseRenderer, Renderer2D, Renderer3D
from .exporter import ImageExporter

__all__ = [
    "VisualizationConfig",
    "ViewConfig",
    "BaseRenderer",
    "Renderer2D",
    "Renderer3D",
    "ImageExporter",
]

```

### visualization/interfaces.py

```
"""可視化のためのインターフェースと抽象クラス"""

from abc import ABC, abstractmethod
from typing import Any, Optional, Dict
from .core.base import ViewConfig


class VisualizationStrategy(ABC):
    """可視化戦略の抽象基底クラス"""

    @abstractmethod
    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """データを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        pass


class MultiFieldVisualizationStrategy(VisualizationStrategy):
    """複数のフィールドを同時に可視化する戦略"""

    @abstractmethod
    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        pass


class VisualizationContext:
    """可視化のコンテキストを管理するクラス"""

    def __init__(self, strategy: VisualizationStrategy):
        """可視化戦略を設定

        Args:
            strategy: 使用する可視化戦略
        """
        self._strategy = strategy

    def set_strategy(self, strategy: VisualizationStrategy):
        """可視化戦略を動的に変更

        Args:
            strategy: 新しい可視化戦略
        """
        self._strategy = strategy

    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """データを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        return self._strategy.visualize(data, name, timestamp, view, **kwargs)

    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        if isinstance(self._strategy, MultiFieldVisualizationStrategy):
            return self._strategy.visualize_combined(
                fields, name, timestamp, view, **kwargs
            )
        raise NotImplementedError(
            "現在の可視化戦略は複数フィールドの可視化をサポートしていません"
        )


class VisualizationFactory:
    """可視化戦略を生成するファクトリクラス"""

    @staticmethod
    def create_strategy(
        strategy_type: str, config: Dict[str, Any]
    ) -> VisualizationStrategy:
        """指定された型の可視化戦略を生成

        Args:
            strategy_type: 可視化戦略の種類
            config: 設定辞書

        Returns:
            生成された可視化戦略
        """
        from .renderer_strategy import (
            Renderer2DVisualizationStrategy,
            Renderer3DVisualizationStrategy,
        )

        strategies = {
            "2d": Renderer2DVisualizationStrategy,
            "3d": Renderer3DVisualizationStrategy,
        }

        if strategy_type.lower() not in strategies:
            raise ValueError(f"未知の可視化戦略: {strategy_type}")

        return strategies[strategy_type.lower()](config)

```

### visualization/utils/colormap.py

```
"""カラーマップ操作のユーティリティを提供するモジュール

このモジュールは、データの可視化に使用するカラーマップの
生成と操作に関する機能を提供します。
"""

from typing import List, Optional
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap, Normalize


def create_custom_colormap(
    colors: List[str], name: str = "custom", n_bins: int = 256
) -> LinearSegmentedColormap:
    """カスタムカラーマップを作成

    Args:
        colors: カラーのリスト
        name: カラーマップの名前
        n_bins: 色の分割数

    Returns:
        作成されたカラーマップ
    """
    return LinearSegmentedColormap.from_list(name, colors, N=n_bins)


def create_diverging_colormap(
    neutral_point: float = 0.0,
    vmin: float = -1.0,
    vmax: float = 1.0,
    colors: Optional[List[str]] = None,
) -> LinearSegmentedColormap:
    """発散型カラーマップを作成

    Args:
        neutral_point: 中立点の値
        vmin: 最小値
        vmax: 最大値
        colors: カラーのリスト（省略時は blue-white-red）

    Returns:
        作成されたカラーマップ
    """
    if colors is None:
        colors = ["blue", "white", "red"]

    # 中立点の相対位置を計算
    total_range = vmax - vmin
    if total_range <= 0:
        raise ValueError("無効なデータ範囲です")

    neutral_pos = (neutral_point - vmin) / total_range
    neutral_pos = np.clip(neutral_pos, 0, 1)

    # カラーマップの作成
    if neutral_pos == 0.5:
        # 対称なカラーマップ
        return create_custom_colormap(colors)
    else:
        # 非対称なカラーマップ
        positions = [0, neutral_pos, 1]
        return LinearSegmentedColormap.from_list(
            "diverging", list(zip(positions, colors))
        )


def apply_colormap(
    data: np.ndarray,
    vmin: Optional[float] = None,
    vmax: Optional[float] = None,
    cmap: str = "viridis",
    symmetric: bool = False,
    alpha: Optional[float] = None,
) -> np.ndarray:
    """データにカラーマップを適用

    Args:
        data: 入力データ
        vmin: 最小値（省略時は自動計算）
        vmax: 最大値（省略時は自動計算）
        cmap: カラーマップ名
        symmetric: 対称な範囲にするかどうか
        alpha: 透明度

    Returns:
        RGBA形式のカラー配列
    """
    # データ範囲の計算
    if vmin is None:
        vmin = np.nanmin(data)
    if vmax is None:
        vmax = np.nanmax(data)

    if symmetric:
        abs_max = max(abs(vmin), abs(vmax))
        vmin, vmax = -abs_max, abs_max

    # 正規化とカラーマップの適用
    norm = Normalize(vmin=vmin, vmax=vmax)
    mapper = plt.get_cmap(cmap)
    colors = mapper(norm(data))

    # 透明度の設定
    if alpha is not None:
        colors[..., 3] = alpha

    return colors

```

### visualization/utils/camera.py

```
"""カメラ設定を管理するモジュール

このモジュールは、3D可視化におけるカメラパラメータの
管理と変換を担当します。
"""

from dataclasses import dataclass, field
import numpy as np
from typing import Tuple, Optional

from ..core.base import ViewConfig


@dataclass
class CameraState:
    """カメラの状態を表すクラス

    位置、方向、上方向ベクトルなどを保持します。
    """

    position: np.ndarray = field(default_factory=lambda: np.zeros(3))
    target: np.ndarray = field(default_factory=lambda: np.zeros(3))
    up: np.ndarray = field(default_factory=lambda: np.array([0, 0, 1]))

    @property
    def direction(self) -> np.ndarray:
        """視線方向を取得"""
        d = self.target - self.position
        return d / np.linalg.norm(d)

    @property
    def right(self) -> np.ndarray:
        """右方向を取得"""
        r = np.cross(self.direction, self.up)
        return r / np.linalg.norm(r)


class CameraController:
    """カメラ制御クラス

    ビュー設定とカメラ状態の変換や、
    カメラの移動・回転などの操作を提供します。
    """

    @staticmethod
    def view_to_camera(
        view: ViewConfig, bounds: Optional[Tuple[np.ndarray, np.ndarray]] = None
    ) -> CameraState:
        """ビュー設定からカメラ状態を計算

        Args:
            view: ビュー設定
            bounds: データの境界ボックス (最小点, 最大点)

        Returns:
            カメラ状態
        """
        # 注視点の設定
        if bounds is not None:
            min_point, max_point = bounds
            center = (min_point + max_point) / 2
            target = center
        else:
            target = np.array(view.focal_point)

        # 球面座標からカメラ位置を計算
        theta = np.radians(view.azimuth)  # 方位角
        phi = np.radians(90 - view.elevation)  # 極角（天頂角）

        # 単位球面上の位置
        x = np.sin(phi) * np.cos(theta)
        y = np.sin(phi) * np.sin(theta)
        z = np.cos(phi)

        # スケーリングと平行移動
        position = target + view.distance * np.array([x, y, z])

        return CameraState(position=position, target=target)

    @staticmethod
    def camera_to_view(camera: CameraState) -> ViewConfig:
        """カメラ状態からビュー設定を計算

        Args:
            camera: カメラ状態

        Returns:
            ビュー設定
        """
        # カメラから注視点へのベクトル
        direction = camera.target - camera.position
        distance = np.linalg.norm(direction)

        # 方位角と仰角を計算
        x, y, z = direction / distance

        azimuth = np.degrees(np.arctan2(y, x))
        elevation = 90 - np.degrees(np.arccos(z))

        return ViewConfig(
            elevation=elevation,
            azimuth=azimuth,
            distance=distance,
            focal_point=tuple(camera.target),
        )

    @staticmethod
    def orbit_camera(
        camera: CameraState, delta_azimuth: float, delta_elevation: float
    ) -> CameraState:
        """カメラを軌道運動させる

        Args:
            camera: 現在のカメラ状態
            delta_azimuth: 方位角の変化量（度）
            delta_elevation: 仰角の変化量（度）

        Returns:
            新しいカメラ状態
        """
        # 現在のビュー設定を取得
        view = CameraController.camera_to_view(camera)

        # 角度を更新
        view.azimuth += delta_azimuth
        view.elevation = np.clip(view.elevation + delta_elevation, -89, 89)

        # 新しいカメラ状態を計算
        return CameraController.view_to_camera(view)

    @staticmethod
    def zoom_camera(camera: CameraState, zoom_factor: float) -> CameraState:
        """カメラをズームする

        Args:
            camera: 現在のカメラ状態
            zoom_factor: ズーム倍率（1より大きい場合はズームイン）

        Returns:
            新しいカメラ状態
        """
        # 現在の距離を取得
        view = CameraController.camera_to_view(camera)

        # 距離を更新
        view.distance /= zoom_factor

        # 新しいカメラ状態を計算
        return CameraController.view_to_camera(view)

    @staticmethod
    def pan_camera(camera: CameraState, delta_x: float, delta_y: float) -> CameraState:
        """カメラをパンする

        Args:
            camera: 現在のカメラ状態
            delta_x: 水平方向の移動量
            delta_y: 垂直方向の移動量

        Returns:
            新しいカメラ状態
        """
        # 移動ベクトルを計算
        right = camera.right
        up = camera.up
        offset = delta_x * right + delta_y * up

        # カメラと注視点を移動
        new_position = camera.position + offset
        new_target = camera.target + offset

        return CameraState(position=new_position, target=new_target, up=camera.up)

```

### visualization/renderer_strategy.py

```
"""可視化戦略の実装"""

from typing import Any, Optional, Dict
from .core.base import ViewConfig, VisualizationConfig
from .interfaces import MultiFieldVisualizationStrategy
from .visualizer import Visualizer


class Renderer2DVisualizationStrategy(MultiFieldVisualizationStrategy):
    """2Dレンダラーを使用した可視化戦略"""

    def __init__(self, config: Dict[str, Any]):
        """戦略を初期化

        Args:
            config: 可視化設定
        """
        # SimulationConfigからVisualizationConfigを作成
        if isinstance(config, dict):
            visualization_config = VisualizationConfig.from_dict(config)
        else:
            # outputセクションをVisualizationConfigに変換
            visualization_config = VisualizationConfig.from_dict(config.output.__dict__)

        self.visualizer = Visualizer(visualization_config)

    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """2Dデータを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        if isinstance(data, list):  # ベクトル場
            return self.visualizer.visualize_vector(
                data, name, timestamp, view, **kwargs
            )
        else:  # スカラー場
            return self.visualizer.visualize_scalar(
                data, name, timestamp, view, **kwargs
            )

    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        # マップされたフィールドを準備
        scalar_data = fields.get("scalar") or fields.get("pressure")
        vector_data = fields.get("vector")

        return self.visualizer.visualize_combined(
            scalar_data=scalar_data,
            vector_components=vector_data,
            name=name,
            timestamp=timestamp,
            view=view,
            **kwargs,
        )


class Renderer3DVisualizationStrategy(MultiFieldVisualizationStrategy):
    """3Dレンダラーを使用した可視化戦略"""

    def __init__(self, config: Dict[str, Any]):
        """戦略を初期化

        Args:
            config: 可視化設定
        """
        # SimulationConfigからVisualizationConfigを作成
        if isinstance(config, dict):
            visualization_config = VisualizationConfig.from_dict(config)
        else:
            # outputセクションをVisualizationConfigに変換
            visualization_config = VisualizationConfig.from_dict(config.output.__dict__)

        self.visualizer = Visualizer(visualization_config)

    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """3Dデータを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        if isinstance(data, list):  # ベクトル場
            return self.visualizer.visualize_vector(
                data, name, timestamp, view, **kwargs
            )
        else:  # スカラー場
            return self.visualizer.visualize_scalar(
                data, name, timestamp, view, **kwargs
            )

    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        # マップされたフィールドを準備
        scalar_data = fields.get("scalar") or fields.get("pressure")
        vector_data = fields.get("vector")
        levelset_data = fields.get("levelset")

        # レベルセットを追加の可視化オプションに含める
        if levelset_data is not None:
            if "scalar_options" not in kwargs:
                kwargs["scalar_options"] = {}
            kwargs["scalar_options"]["levelset"] = levelset_data

        return self.visualizer.visualize_combined(
            scalar_data=scalar_data,
            vector_components=vector_data,
            name=name,
            timestamp=timestamp,
            view=view,
            **kwargs,
        )

```

### visualization/renderers/vector2d.py

```
"""2Dベクトル場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any, List
from matplotlib.axes import Axes
from matplotlib.figure import Figure


class Vector2DRenderer:
    """2Dベクトル場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def render(
        self, vector_components: List[np.ndarray], ax: Optional[Axes] = None, **kwargs
    ) -> Tuple[Figure, Dict[str, Any]]:
        """2Dベクトル場を描画

        Args:
            vector_components: ベクトル場の各成分 [u, v]
            ax: 既存のAxes（Noneの場合は新規作成）
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力バリデーション
        if len(vector_components) != 2:
            raise ValueError("2次元ベクトル場には2つの成分が必要です")

        u, v = vector_components

        # 図とAxesの準備
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.figure

        # ベクトルの大きさを計算
        magnitude = np.sqrt(u**2 + v**2)

        # デフォルトのパラメータ設定
        density = kwargs.get("density", 20)
        scale = kwargs.get("scale", 1.0)
        skip = max(1, min(u.shape) // density)

        # メタデータの準備
        metadata = {
            "data_range": {
                "min_magnitude": float(np.min(magnitude)),
                "max_magnitude": float(np.max(magnitude)),
            },
            "display_type": ["vector"],
        }

        # グリッドの生成
        nx, ny = u.shape
        x = np.arange(nx)
        y = np.arange(ny)
        X, Y = np.meshgrid(x, y, indexing="ij")

        # ベクトル場の描画
        ax.quiver(
            X[::skip, ::skip],
            Y[::skip, ::skip],
            u[::skip, ::skip],
            v[::skip, ::skip],
            color="blue",  # 単純な静的な色
            scale=scale,
            alpha=kwargs.get("alpha", 0.7),
        )

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # アスペクト比と軸ラベル
        ax.set_aspect("equal")
        ax.set_xlabel("X")
        ax.set_ylabel("Y")

        return fig, metadata

```

### visualization/renderers/vector3d.py

```
"""3Dベクトル場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any, List
from matplotlib.axes import Axes


class Vector3DRenderer:
    """3Dベクトル場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def _get_slice(
        self, data: np.ndarray, slice_axis: str, slice_pos: float
    ) -> Tuple[np.ndarray, ...]:
        """指定された軸とスライス位置でデータをスライス

        Args:
            data: 入力データ配列
            slice_axis: スライス軸 ('xy', 'xz', 'yz')
            slice_pos: スライス位置 (0-1)

        Returns:
            スライスされたデータと座標
        """
        # データの形状を取得
        nx, ny, nz = data.shape

        # スライス位置のインデックスを計算
        if slice_axis == "xy":
            slice_idx = int(slice_pos * (nz - 1))
            slice_data = data[:, :, slice_idx]
            x, y = np.meshgrid(np.arange(nx), np.arange(ny), indexing="ij")
            z = np.full_like(x, slice_idx)
        elif slice_axis == "xz":
            slice_idx = int(slice_pos * (ny - 1))
            slice_data = data[:, slice_idx, :]
            x, z = np.meshgrid(np.arange(nx), np.arange(nz), indexing="ij")
            y = np.full_like(x, slice_idx)
        elif slice_axis == "yz":
            slice_idx = int(slice_pos * (nx - 1))
            slice_data = data[slice_idx, :, :]
            y, z = np.meshgrid(np.arange(ny), np.arange(nz), indexing="ij")
            x = np.full_like(y, slice_idx)
        else:
            raise ValueError(f"無効なスライス軸: {slice_axis}")

        return slice_data, x, y, z

    def render(
        self,
        vector_components: List[np.ndarray],
        ax: Optional[Axes] = None,
        view: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> Tuple[plt.Figure, Dict[str, Any]]:
        """3Dベクトル場を描画

        Args:
            vector_components: ベクトル場の各成分 [u, v, w]
            ax: 既存のAxes（Noneの場合は新規作成）
            view: スライス情報
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力バリデーション
        if len(vector_components) != 3:
            raise ValueError("3次元ベクトル場には3つの成分が必要です")

        u, v, w = vector_components

        # スライス情報の取得
        slice_axis = view.get("slice_axes", ["xy"])[0] if view else "xy"
        slice_pos = view.get("slice_positions", [0.5])[0] if view else 0.5

        # 図とAxesの準備
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="3d")
        else:
            fig = ax.figure

        # スライスの取得
        slice_data_list = []
        for component in [u, v, w]:
            slice_data, x, y, z = self._get_slice(component, slice_axis, slice_pos)
            slice_data_list.append(slice_data)

        # メタデータの準備
        metadata = {
            "data_range": {
                "min_magnitude": float(np.min(slice_data_list[0])),
                "max_magnitude": float(np.max(slice_data_list[0])),
            },
            "display_type": ["vector", "slice"],
            "slice_info": {"axis": slice_axis, "position": slice_pos},
        }

        # ベクトル場の描画
        ax.quiver(
            x,
            y,
            z,
            slice_data_list[0],
            slice_data_list[1],
            slice_data_list[2],
            color="blue",
            alpha=kwargs.get("alpha", 0.7),
        )

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # 軸ラベルの設定
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")

        return fig, metadata

```

### visualization/renderers/__init__.py

```
"""可視化レンダラーパッケージの初期化"""

from .scalar2d import Scalar2DRenderer
from .scalar3d import Scalar3DRenderer
from .vector2d import Vector2DRenderer
from .vector3d import Vector3DRenderer

__all__ = [
    "Scalar2DRenderer",
    "Scalar3DRenderer",
    "Vector2DRenderer",
    "Vector3DRenderer",
]

```

### visualization/renderers/scalar2d.py

```
"""2Dスカラー場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any
from matplotlib.axes import Axes
from matplotlib.figure import Figure


class Scalar2DRenderer:
    """2Dスカラー場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def render(
        self, data: np.ndarray, ax: Optional[Axes] = None, **kwargs
    ) -> Tuple[Figure, Dict[str, Any]]:
        """2Dスカラー場を描画

        Args:
            data: スカラー場データ
            ax: 既存のAxes（Noneの場合は新規作成）
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力バリデーション
        if data.ndim != 2:
            raise ValueError("2次元データが必要です")

        # 図とAxesの準備
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.figure

        # デフォルトのパラメータ設定
        cmap = kwargs.get("cmap", "viridis")
        interpolation = kwargs.get("interpolation", "nearest")

        # メタデータの準備
        metadata = {
            "data_range": {
                "min": float(np.nanmin(data)),
                "max": float(np.nanmax(data)),
            },
            "display_type": ["scalar"],
        }

        # スカラー場の描画
        im = ax.imshow(
            data.T,
            origin="lower",
            cmap=cmap,
            interpolation=interpolation,
            alpha=kwargs.get("alpha", 1.0),
        )

        # カラーバーの追加
        if kwargs.get("colorbar", True):
            plt.colorbar(im, ax=ax)

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # 軸ラベルの追加
        ax.set_xlabel(kwargs.get("xlabel", "X"))
        ax.set_ylabel(kwargs.get("ylabel", "Y"))

        return fig, metadata

```

### visualization/renderers/scalar3d.py

```
"""3Dスカラー場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any, Union
from matplotlib.axes import Axes


class Scalar3DRenderer:
    """3Dスカラー場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def render(
        self,
        data: Union[np.ndarray, int],
        ax: Optional[Axes] = None,
        view: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> Tuple[plt.Figure, Dict[str, Any]]:
        """3Dスカラー場を描画

        Args:
            data: スカラー場データ
            ax: 既存のAxes（Noneの場合は新規作成）
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力データのチェック
        if isinstance(data, int):
            raise ValueError("データは数値ではなく、numpy配列である必要があります")

        # 入力バリデーション
        if data.ndim != 3:
            raise ValueError("3次元データが必要です")

        # 図とAxesの準備
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="3d")
        else:
            fig = ax.figure

        # スライス位置の決定
        _ = {"yz": 0, "xz": 1, "xy": 2}
        if view is None:
            slice_axis = 2
            slice_pos = data.shape[0] // 2
        else:
            slice_axis = _[view.slice_axes[0]]
            slice_pos = int(view.slice_positions[0] * data.shape[0])

        # スライスの抽出
        slices = [slice(None)] * 3
        slices[slice_axis] = slice_pos
        slice_data = data[tuple(slices)].T

        # メタデータの準備
        metadata = {
            "data_range": {
                "min": float(np.nanmin(data)),
                "max": float(np.nanmax(data)),
            },
            "display_type": ["scalar", "slice"],
        }

        # グリッドの生成
        nx, ny = slice_data.shape
        x = np.arange(nx)
        y = np.arange(ny)
        X, Y = np.meshgrid(x, y)

        # 座標の調整
        if slice_axis == 0:
            X, Y, Z = slice_pos * np.ones_like(X), X, Y
        elif slice_axis == 1:
            X, Y, Z = X, slice_pos * np.ones_like(X), Y
        else:
            X, Y, Z = X, Y, slice_pos * np.ones_like(X)

        # カラーマップと色の設定
        cmap = kwargs.get("cmap", "viridis")

        # データの正規化（ゼロ除算を防ぐ）
        min_val = slice_data.min()
        max_val = slice_data.max()

        if min_val == max_val:
            # すべての値が同じ場合
            normalized_data = np.ones_like(slice_data)
        else:
            normalized_data = (slice_data - min_val) / (max_val - min_val)

        im = ax.plot_surface(
            X,
            Y,
            Z,
            facecolors=plt.cm.get_cmap(cmap)(normalized_data),
            alpha=kwargs.get("alpha", 0.7),
        )

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # 軸ラベルの設定
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")

        return fig, metadata

```

### visualization/visualizer.py

```
"""可視化システムのメインクラスを提供するモジュール

このモジュールは、2次元・3次元の物理場の可視化機能を統合的に提供します。
"""

from typing import Optional, Dict, Any, Union, List

import numpy as np
from matplotlib import pyplot as plt

from .core.base import VisualizationConfig, ViewConfig
from .core.exporter import ImageExporter
from .renderers.scalar2d import Scalar2DRenderer
from .renderers.vector2d import Vector2DRenderer
from .renderers.scalar3d import Scalar3DRenderer
from .renderers.vector3d import Vector3DRenderer


class Visualizer:
    """可視化システムのメインクラス

    2次元・3次元の物理場の可視化を統合的に管理します。
    """

    def __init__(self, config: Union[VisualizationConfig, Dict[str, Any]]):
        """可視化システムを初期化

        Args:
            config: 設定（VisualizationConfigまたは辞書）
        """
        if isinstance(config, dict):
            self.config = VisualizationConfig.from_dict(config)
        else:
            self.config = config

        self.exporter = ImageExporter(self.config)

        # レンダラーの初期化
        self._renderers = {
            "2D": {
                "scalar": Scalar2DRenderer(self.config),
                "vector": Vector2DRenderer(self.config),
            },
            "3D": {
                "scalar": Scalar3DRenderer(self.config),
                "vector": Vector3DRenderer(self.config),
            },
        }

    def visualize_scalar(
        self,
        data: np.ndarray,
        name: str,
        timestamp: Optional[float] = None,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """スカラー場を可視化"""
        # データの次元に応じてレンダラーを選択
        renderer = self._renderers["3D" if data.ndim == 3 else "2D"]["scalar"]

        # 描画を実行
        fig, metadata = renderer.render(data, view=view, **kwargs)

        # 出力パスの生成
        filepath = self.config.get_output_path(name, timestamp)

        # 描画結果の出力
        self.exporter.export(fig, filepath, metadata)

        return str(filepath)

    def visualize_vector(
        self,
        vector_components: List[np.ndarray],
        name: str,
        timestamp: Optional[float] = None,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """ベクトル場を可視化"""
        # データの次元に応じてレンダラーを選択
        ndim = len(vector_components)
        renderer = self._renderers["3D" if ndim == 3 else "2D"]["vector"]

        # 描画を実行
        fig, metadata = renderer.render(vector_components, **kwargs)

        # 出力パスの生成
        filepath = self.config.get_output_path(name, timestamp)

        # 描画結果の出力
        self.exporter.export(fig, filepath, metadata)

        return str(filepath)

    def visualize_combined(
        self,
        scalar_data: Optional[np.ndarray] = None,
        vector_components: Optional[List[np.ndarray]] = None,
        name: str = "combined",
        timestamp: Optional[float] = None,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """スカラー場とベクトル場を重ねて可視化"""
        if scalar_data is not None:
            ndim = scalar_data.ndim
        elif vector_components is not None:
            ndim = len(vector_components)
        else:
            raise ValueError("スカラー場またはベクトル場が必要です")

        # 図の作成
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection="3d" if ndim == 3 else None)

        metadata = {}

        # スカラー場の描画
        if scalar_data is not None:
            renderer = self._renderers["3D" if ndim == 3 else "2D"]["scalar"]
            _, scalar_metadata = renderer.render(
                scalar_data, ax=ax, **kwargs.get("scalar_options", {})
            )
            metadata["scalar"] = scalar_metadata

        # ベクトル場の描画
        if vector_components is not None:
            renderer = self._renderers["3D" if ndim == 3 else "2D"]["vector"]
            _, vector_metadata = renderer.render(
                vector_components, ax=ax, **kwargs.get("vector_options", {})
            )
            metadata["vector"] = vector_metadata

        # 出力パスの生成
        filepath = self.config.get_output_path(name, timestamp)

        # 描画結果の出力
        self.exporter.export(fig, filepath, metadata)

        return str(filepath)

```

### visualization/__init__.py

```
"""可視化システムのメインモジュール

このパッケージは、2次元・3次元の物理場の可視化機能を統合的に提供します。
"""

from .core.base import VisualizationConfig, ViewConfig
from .visualizer import Visualizer
from .interfaces import VisualizationFactory, VisualizationContext
from .renderer_strategy import (
    Renderer2DVisualizationStrategy,
    Renderer3DVisualizationStrategy,
)

# レンダラー
from .renderers import (
    Scalar2DRenderer,
    Scalar3DRenderer,
    Vector2DRenderer,
    Vector3DRenderer,
)

# エクスポーター
from .core.exporter import ImageExporter

# 可視化関数
from .multiview import visualize_simulation_state, create_multiview_visualization

__all__ = [
    # 設定関連
    "VisualizationConfig",
    "ViewConfig",
    # メインクラス
    "Visualizer",
    # インターフェースと戦略
    "VisualizationFactory",
    "VisualizationContext",
    "Renderer2DVisualizationStrategy",
    "Renderer3DVisualizationStrategy",
    # レンダラー
    "Scalar2DRenderer",
    "Scalar3DRenderer",
    "Vector2DRenderer",
    "Vector3DRenderer",
    # エクスポーター
    "ImageExporter",
    # 可視化関数
    "visualize_simulation_state",
    "create_multiview_visualization",
]

```

### visualization/multiview.py

```
"""可視化システムの多視点可視化モジュール

このモジュールは、シミュレーション状態の多視点可視化を提供します。
"""

from pathlib import Path
from typing import List

from .core.base import VisualizationConfig, ViewConfig
from .interfaces import VisualizationContext, VisualizationFactory


def create_multiview_visualization(
    state,
    config: VisualizationConfig,
    timestamp: float = 0.0,
    base_name: str = "simulation_state",
) -> List[str]:
    """シミュレーション状態の多視点可視化を生成"""
    # 出力ディレクトリの作成
    if hasattr(config, "output_dir"):
        output_dir = Path(config.output_dir)
    elif isinstance(config, dict):
        output_dir = Path(config.get("output_dir", "results/visualization"))
    else:
        output_dir = Path("results/visualization")

    output_dir.mkdir(parents=True, exist_ok=True)
    output_files = []

    # 可視化戦略の選択（次元数に基づく）
    ndim = len(state.velocity.components[0].data.shape)
    strategy_type = "3d" if ndim == 3 else "2d"
    viz_context = VisualizationContext(
        VisualizationFactory.create_strategy(strategy_type, config)
    )

    # 可視化設定とフィールド設定の取得を修正
    if isinstance(config, dict):
        viz_config = config.get("visualization", {})
        fields_config = viz_config.get("fields", {})
        slice_config = viz_config.get("slices", {})
    elif hasattr(config, "output"):
        viz_config = config.output
        fields_config = viz_config.fields
        slice_config = getattr(viz_config, "slices", {})
    else:
        viz_config = {}
        fields_config = {}
        slice_config = {}

    # スライス設定の取得
    slice_axes = slice_config.get("axes", ["xy"])
    slice_positions = slice_config.get("positions", [0.5])

    # 可視化する物理量の設定
    physics_fields = []

    # 速度場の設定
    if fields_config.get("velocity", {}).get("enabled", True):
        physics_fields.append(
            {
                "name": "velocity",
                "data": [comp.data for comp in state.velocity.components],
                "plot_type": "vector",
            }
        )

    # 圧力場の設定
    if fields_config.get("pressure", {}).get("enabled", True):
        physics_fields.append(
            {"name": "pressure", "data": state.pressure.data, "plot_type": "scalar"}
        )

    # レベルセット場の設定
    if fields_config.get("levelset", {}).get("enabled", True):
        physics_fields.append(
            {"name": "levelset", "data": state.levelset.data, "plot_type": "scalar"}
        )

    # physics_fieldsが空の場合のデフォルト設定
    if not physics_fields:
        physics_fields = [
            {
                "name": "velocity",
                "data": [comp.data for comp in state.velocity.components],
                "plot_type": "vector",
            },
            {"name": "pressure", "data": state.pressure.data, "plot_type": "scalar"},
            {"name": "levelset", "data": state.levelset.data, "plot_type": "scalar"},
        ]

    # 可視化の実行
    for field in physics_fields:
        for slice_axis in slice_axes:
            for slice_pos in slice_positions:
                try:
                    # ViewConfigの作成
                    view_config = ViewConfig(
                        slice_axes=[slice_axis], slice_positions=[slice_pos]
                    )

                    # ファイル名の生成
                    filename = (
                        f"{base_name}_{field['name']}"
                        f"_{slice_axis}_slice_{slice_pos:.2f}_{timestamp:.3f}"
                    )

                    # 可視化の実行
                    filepath = viz_context.visualize(
                        field["data"],
                        name=filename,
                        timestamp=timestamp,
                        view=view_config,
                    )

                    output_files.append(filepath)

                except Exception as e:
                    print(f"可視化中にエラー発生: {e}")
                    import traceback

                    traceback.print_exc()

    return output_files


def visualize_simulation_state(state, config, timestamp: float = 0.0) -> List[str]:
    """シミュレーション状態を可視化

    Args:
        state: シミュレーション状態
        config: 可視化設定
        timestamp: 現在の時刻

    Returns:
        生成された可視化ファイルのパス一覧
    """
    # 設定が辞書の場合、VisualizationConfigに変換
    if isinstance(config, dict):
        config = VisualizationConfig.from_dict(config)

    return create_multiview_visualization(state, config, timestamp=timestamp)

```

### numerics/spatial/stencil.py

```
"""差分ステンシルを定義するモジュール

このモジュールは、各種の差分スキームで使用されるステンシルを定義します。
2次、4次、6次の中心差分と、境界での特殊なステンシルを提供します。
"""

import numpy as np
from dataclasses import dataclass


@dataclass
class StencilCoefficients:
    """差分ステンシルの係数を保持するクラス

    Attributes:
        points: ステンシル点の相対位置
        coefficients: 各点での係数
    """

    points: np.ndarray
    coefficients: np.ndarray

    def validate(self):
        """ステンシル係数の妥当性を検証"""
        if len(self.points) != len(self.coefficients):
            raise ValueError("点の数と係数の数が一致しません")


class DifferenceStencils:
    """差分ステンシルの定義を提供するクラス"""

    # 1階微分の中心差分ステンシル
    CENTRAL_FIRST = {
        2: StencilCoefficients(  # 2次精度
            points=np.array([-1, 0, 1]),
            coefficients=np.array([-1 / 2, 0, 1 / 2]),
        ),
        4: StencilCoefficients(  # 4次精度
            points=np.array([-2, -1, 0, 1, 2]),
            coefficients=np.array([1 / 12, -2 / 3, 0, 2 / 3, -1 / 12]),
        ),
        6: StencilCoefficients(  # 6次精度
            points=np.array([-3, -2, -1, 0, 1, 2, 3]),
            coefficients=np.array([-1 / 60, 3 / 20, -3 / 4, 0, 3 / 4, -3 / 20, 1 / 60]),
        ),
    }

    # 2階微分の中心差分ステンシル
    CENTRAL_SECOND = {
        2: StencilCoefficients(  # 2次精度
            points=np.array([-1, 0, 1]),
            coefficients=np.array([1, -2, 1]),
        ),
        4: StencilCoefficients(  # 4次精度
            points=np.array([-2, -1, 0, 1, 2]),
            coefficients=np.array([-1 / 12, 4 / 3, -5 / 2, 4 / 3, -1 / 12]),
        ),
        6: StencilCoefficients(  # 6次精度
            points=np.array([-3, -2, -1, 0, 1, 2, 3]),
            coefficients=np.array(
                [1 / 90, -3 / 20, 3 / 2, -49 / 18, 3 / 2, -3 / 20, 1 / 90]
            ),
        ),
    }

    # 境界での1階微分ステンシル（前方差分）
    FORWARD_FIRST = {
        2: StencilCoefficients(  # 2次精度
            points=np.array([0, 1, 2]),
            coefficients=np.array([-3 / 2, 2, -1 / 2]),
        ),
        4: StencilCoefficients(  # 4次精度
            points=np.array([0, 1, 2, 3, 4]),
            coefficients=np.array([-25 / 12, 4, -3, 4 / 3, -1 / 4]),
        ),
    }

    # 境界での1階微分ステンシル（後方差分）
    BACKWARD_FIRST = {
        2: StencilCoefficients(  # 2次精度
            points=np.array([-2, -1, 0]),
            coefficients=np.array([1 / 2, -2, 3 / 2]),
        ),
        4: StencilCoefficients(  # 4次精度
            points=np.array([-4, -3, -2, -1, 0]),
            coefficients=np.array([1 / 4, -4 / 3, 3, -4, 25 / 12]),
        ),
    }

    @classmethod
    def get_first_derivative_stencil(
        cls, order: int, boundary: bool = False, side: int = 0
    ) -> StencilCoefficients:
        """1階微分のステンシルを取得

        Args:
            order: 精度次数
            boundary: 境界用のステンシルかどうか
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシル係数
        """
        if not boundary:
            if order not in cls.CENTRAL_FIRST:
                raise ValueError(f"未対応の次数です: {order}")
            return cls.CENTRAL_FIRST[order]
        else:
            if order not in cls.FORWARD_FIRST:
                raise ValueError(f"境界では未対応の次数です: {order}")
            if side == 0:
                return cls.FORWARD_FIRST[order]
            else:
                return cls.BACKWARD_FIRST[order]

    @classmethod
    def get_second_derivative_stencil(cls, order: int) -> StencilCoefficients:
        """2階微分のステンシルを取得

        Args:
            order: 精度次数

        Returns:
            ステンシル係数
        """
        if order not in cls.CENTRAL_SECOND:
            raise ValueError(f"未対応の次数です: {order}")
        return cls.CENTRAL_SECOND[order]

    @staticmethod
    def apply_stencil(
        data: np.ndarray, stencil: StencilCoefficients, axis: int, dx: float
    ) -> np.ndarray:
        """ステンシルを適用して微分を計算

        Args:
            data: 入力データ
            stencil: 適用するステンシル
            axis: 微分を計算する軸
            dx: グリッド間隔

        Returns:
            計算された微分
        """
        result = np.zeros_like(data)
        for point, coef in zip(stencil.points, stencil.coefficients):
            result += coef * np.roll(data, point, axis=axis)
        return result / (dx ** len(stencil.points))

```

### numerics/spatial/base.py

```
"""空間微分スキームの基底クラスを提供するモジュール（改良版）"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Tuple, Optional
import numpy as np
from dataclasses import dataclass
from core.field import ScalarField


@dataclass
class DifferentiationConfig:
    """空間微分の設定クラス"""

    order: int = 2
    padding_mode: str = "reflect"
    boundary_order: Optional[int] = None

    def validate(self):
        """設定値の妥当性を検証"""
        if self.order not in [2, 4, 6]:
            raise ValueError("差分近似の次数は2, 4, 6のいずれかである必要があります")

        valid_padding_modes = ["reflect", "constant", "nearest", "mirror"]
        if self.padding_mode not in valid_padding_modes:
            raise ValueError(f"無効なpadding_mode。選択肢: {valid_padding_modes}")

        if self.boundary_order is not None and self.boundary_order > self.order:
            raise ValueError("境界での近似次数は内部の次数以下である必要があります")


class SpatialDerivative(ABC):
    """空間微分の基底クラス（改良版）"""

    def __init__(self, config: Optional[DifferentiationConfig] = None):
        """空間微分計算器を初期化

        Args:
            config: 微分計算の設定
        """
        self.config = config or DifferentiationConfig()
        self.config.validate()

    @abstractmethod
    def __call__(self, field: ScalarField, axis: int, dx: float) -> ScalarField:
        """空間微分を計算（改良版）

        Args:
            field: 入力スカラー場
            axis: 微分を計算する軸
            dx: グリッド間隔

        Returns:
            微分値を格納した新しいスカラー場
        """
        pass

    @abstractmethod
    def get_stencil(self) -> Tuple[np.ndarray, np.ndarray]:
        """差分ステンシルを取得

        Returns:
            (points, coefficients) - ステンシルの位置と係数のタプル
        """
        pass

    def _validate_input(self, field: ScalarField, axis: int, dx: float):
        """入力データの妥当性を検証

        Args:
            field: 入力スカラー場
            axis: 微分を計算する軸
            dx: グリッド間隔

        Raises:
            ValueError: 無効な入力が指定された場合
        """
        if not isinstance(field, ScalarField):
            raise ValueError("fieldはScalarFieldである必要があります")

        if not 0 <= axis < field.ndim:
            raise ValueError(f"無効な軸です: {axis}")

        if dx <= 0:
            raise ValueError("グリッド間隔は正の値である必要があります")

    def get_padding_width(self) -> int:
        """必要なパディング幅を取得

        Returns:
            パディングが必要な点の数
        """
        return self.config.order // 2

    def apply_padding(
        self, field: ScalarField, axis: int, width: Optional[int] = None
    ) -> ScalarField:
        """スカラー場にパディングを適用（改良版）

        Args:
            field: 入力スカラー場
            axis: パディングを適用する軸
            width: パディング幅（Noneの場合は次数から自動決定）

        Returns:
            パディングが適用された新しいスカラー場
        """
        width = width or self.get_padding_width()
        # 新しい演算子を活用したパディング
        return field.pad(axis, width, mode=self.config.padding_mode)

    def get_boundary_stencil(self, side: int) -> Tuple[np.ndarray, np.ndarray]:
        """境界での差分ステンシルを取得（改良版）

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            (points, coefficients) - 境界ステンシルの位置と係数のタプル
        """
        return self.get_stencil()

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得（改良版）"""
        return {
            "order": self.config.order,
            "padding_mode": self.config.padding_mode,
            "boundary_order": self.config.boundary_order,
            "stencil_points": self.get_stencil()[0].tolist(),
            "stencil_coefficients": self.get_stencil()[1].tolist(),
        }

```

### numerics/spatial/schemes/central.py

```
"""中心差分スキームを提供するモジュール

このモジュールは、2次、4次、6次の中心差分スキームを実装します。
"""

from typing import Dict, Any
from ..base import SpatialDerivative, DifferentiationConfig
from ..stencil import DifferenceStencils, StencilCoefficients
from core.field import ScalarField


class CentralDifference(SpatialDerivative):
    """中心差分による空間微分計算クラス

    2次、4次、6次の中心差分スキームを提供します。
    """

    def __init__(
        self,
        config: DifferentiationConfig = None,
        derivative_order: int = 1,
    ):
        """中心差分計算器を初期化

        Args:
            config: 差分計算の設定
            derivative_order: 微分の階数（1または2）
        """
        super().__init__(config)
        if derivative_order not in [1, 2]:
            raise ValueError("微分の階数は1または2である必要があります")
        self.derivative_order = derivative_order

    def __call__(self, field: ScalarField, axis: int, dx: float) -> ScalarField:
        """中心差分により微分を計算

        Args:
            field: 入力スカラー場
            axis: 微分を計算する軸
            dx: グリッド間隔

        Returns:
            微分値を格納した新しいスカラー場
        """
        self._validate_input(field, axis, dx)

        # パディングの適用
        padded_field = self.apply_padding(field, axis)

        # ステンシルの取得と適用
        stencil = self.get_stencil()
        derivative = DifferenceStencils.apply_stencil(padded_field, stencil, axis, dx)

        # パディング部分の除去
        result = derivative.trim([axis], [self.get_padding_width()])

        return result

    def get_stencil(self) -> StencilCoefficients:
        """差分ステンシルを取得

        Returns:
            ステンシル係数
        """
        if self.derivative_order == 1:
            return DifferenceStencils.get_first_derivative_stencil(self.config.order)
        else:  # derivative_order == 2
            return DifferenceStencils.get_second_derivative_stencil(self.config.order)

    def get_boundary_stencil(self, side: int) -> StencilCoefficients:
        """境界での差分ステンシルを取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界用のステンシル係数
        """
        if self.derivative_order == 1:
            order = self.config.boundary_order or self.config.order
            return DifferenceStencils.get_first_derivative_stencil(
                order, boundary=True, side=side
            )
        else:
            # 2階微分の場合は中心差分を使用
            return self.get_stencil()

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得

        Returns:
            診断情報の辞書
        """
        diag = super().get_diagnostics()
        diag.update(
            {
                "derivative_order": self.derivative_order,
                "method": "central",
                "stencil_width": self.get_padding_width() * 2 + 1,
            }
        )
        return diag

```

### numerics/spatial/__init__.py

```
"""空間微分計算パッケージ

このパッケージは、空間微分の計算に必要な各種スキームを提供します。
"""

from .base import SpatialDerivative, DifferentiationConfig
from .stencil import DifferenceStencils, StencilCoefficients
from .schemes.central import CentralDifference

__all__ = [
    # 基底クラスと設定
    "SpatialDerivative",
    "DifferentiationConfig",
    # ステンシル定義
    "DifferenceStencils",
    "StencilCoefficients",
    # 差分スキーム
    "CentralDifference",
]

```

### numerics/weno/smoothness.py

```
"""WENOスキームの滑らかさ指標を計算するモジュール

このモジュールは、WENOスキームで使用される滑らかさ指標（smoothness indicators）の
計算を担当します。
"""

from typing import List, Optional
import numpy as np
import numpy.typing as npt


class SmoothnessIndicator:
    """WENOスキームの滑らかさ指標を計算するクラス"""

    def __init__(self, dx: float = 1.0):
        """滑らかさ指標計算器を初期化

        Args:
            dx: グリッド間隔
        """
        self._dx = dx
        self._cache: Optional[List[npt.NDArray[np.float64]]] = None

    def compute(
        self,
        data: npt.NDArray[np.float64],
        coeffs: List[np.ndarray],
        axis: int = -1,
    ) -> List[npt.NDArray[np.float64]]:
        """滑らかさ指標を計算

        Args:
            data: 入力データ配列
            coeffs: 滑らかさ指標の計算係数
            axis: 計算を行う軸

        Returns:
            各ステンシルの滑らかさ指標のリスト
        """
        # 軸の正規化
        axis = axis if axis >= 0 else data.ndim + axis

        # 結果を格納するリスト
        beta = []

        # 各ステンシルについて滑らかさ指標を計算
        for stencil_coeffs in coeffs:
            # このステンシルの滑らかさ指標を初期化
            beta_r = np.zeros_like(data, dtype=np.float64)

            # 各微分の次数について
            for k, deriv_coeffs in enumerate(stencil_coeffs):
                # 差分近似の計算
                diff = np.zeros_like(data)
                for j, coeff in enumerate(deriv_coeffs):
                    diff += coeff * np.roll(data, j - 1, axis=axis)

                # スケーリング係数（dx^(2k-1)）
                scale = self._dx ** (2 * k - 1)

                # 滑らかさ指標に寄与を加算
                beta_r += scale * diff * diff

            beta.append(beta_r)

        # キャッシュの更新
        self._cache = beta

        return beta

    def compute_normalized(
        self,
        data: npt.NDArray[np.float64],
        coeffs: List[np.ndarray],
        axis: int = -1,
        p: float = 2.0,
    ) -> List[npt.NDArray[np.float64]]:
        """正規化された滑らかさ指標を計算

        Args:
            data: 入力データ配列
            coeffs: 滑らかさ指標の計算係数
            axis: 計算を行う軸
            p: 正規化のための指数（デフォルト: 2.0）

        Returns:
            正規化された滑らかさ指標のリスト
        """
        # 滑らかさ指標の計算
        beta = self.compute(data, coeffs, axis)

        # 最大値による正規化
        beta_max = max(np.max(b) for b in beta)
        if beta_max > 0:
            beta = [b / beta_max for b in beta]

        # べき乗による強調
        if p != 1.0:
            beta = [b**p for b in beta]

        return beta

    def get_last_computed(self) -> Optional[List[npt.NDArray[np.float64]]]:
        """最後に計算された滑らかさ指標を取得"""
        return self._cache

    def clear_cache(self) -> None:
        """キャッシュをクリア"""
        self._cache = None

```

### numerics/weno/coefficients.py

```
"""WENOスキームの補間係数を管理するモジュール

このモジュールは、WENOスキームで使用される線形補間係数と
非線形重み係数の計算および管理を担当します。
"""

from typing import Dict, List, Tuple
import numpy as np
from functools import lru_cache


class WENOCoefficients:
    """WENOスキームの補間係数を管理するクラス"""

    def __init__(self):
        """WENO係数管理クラスを初期化"""
        self._coeff_cache: Dict[int, Tuple[np.ndarray, np.ndarray]] = {}
        self._optimal_weights_cache: Dict[int, np.ndarray] = {}

    @lru_cache(maxsize=8)
    def get_interpolation_coefficients(
        self, order: int
    ) -> Tuple[np.ndarray, np.ndarray]:
        """指定された次数のWENO補間係数を取得

        Args:
            order: WENOスキームの次数

        Returns:
            (補間係数, 理想重み係数)のタプル

        Raises:
            ValueError: 未対応の次数が指定された場合
        """
        if order not in [3, 5, 7]:
            raise ValueError(f"未対応のWENO次数です: {order}")

        if order not in self._coeff_cache:
            self._coeff_cache[order] = self._compute_coefficients(order)

        return self._coeff_cache[order]

    def _compute_coefficients(self, order: int) -> Tuple[np.ndarray, np.ndarray]:
        """WENO補間係数を計算

        Args:
            order: WENOスキームの次数

        Returns:
            (補間係数, 理想重み係数)のタプル
        """
        if order == 3:
            return self._compute_weno3_coefficients()
        elif order == 5:
            return self._compute_weno5_coefficients()
        else:  # order == 7
            return self._compute_weno7_coefficients()

    def _compute_weno3_coefficients(self) -> Tuple[np.ndarray, np.ndarray]:
        """WENO3の補間係数を計算"""
        # 3次精度WENOの補間係数（2つのステンシル）
        coeffs = np.array(
            [
                [-1 / 2, 3 / 2],  # ステンシル0の係数
                [1 / 2, 1 / 2],  # ステンシル1の係数
            ]
        )

        # 理想重み係数
        optimal_weights = np.array([1 / 3, 2 / 3])

        return coeffs, optimal_weights

    def _compute_weno5_coefficients(self) -> Tuple[np.ndarray, np.ndarray]:
        """WENO5の補間係数を計算"""
        # 5次精度WENOの補間係数（3つのステンシル）
        coeffs = np.array(
            [
                [1 / 3, -7 / 6, 11 / 6],  # ステンシル0の係数
                [-1 / 6, 5 / 6, 1 / 3],  # ステンシル1の係数
                [1 / 3, 5 / 6, -1 / 6],  # ステンシル2の係数
            ]
        )

        # 理想重み係数
        optimal_weights = np.array([0.1, 0.6, 0.3])

        return coeffs, optimal_weights

    def _compute_weno7_coefficients(self) -> Tuple[np.ndarray, np.ndarray]:
        """WENO7の補間係数を計算"""
        # 7次精度WENOの補間係数（4つのステンシル）
        coeffs = np.array(
            [
                [-1 / 4, 13 / 12, -23 / 12, 25 / 12],  # ステンシル0の係数
                [1 / 12, -5 / 12, 13 / 12, 1 / 4],  # ステンシル1の係数
                [-1 / 12, 7 / 12, 7 / 12, -1 / 12],  # ステンシル2の係数
                [1 / 4, 13 / 12, -5 / 12, 1 / 12],  # ステンシル3の係数
            ]
        )

        # 理想重み係数
        optimal_weights = np.array([1 / 20, 9 / 20, 9 / 20, 1 / 20])

        return coeffs, optimal_weights

    def get_smoothness_coefficients(self, order: int) -> List[np.ndarray]:
        """滑らかさ指標の計算に使用する係数を取得

        Args:
            order: WENOスキームの次数

        Returns:
            各ステンシルの滑らかさ指標計算用係数のリスト
        """
        if order == 3:
            return [
                np.array([[1, -2, 1]]),  # β_0
                np.array([[1, -2, 1]]),  # β_1
            ]
        elif order == 5:
            return [
                np.array([[1, -2, 1], [1, -4, 3]]),  # β_0
                np.array([[1, -2, 1], [1, -2, 1]]),  # β_1
                np.array([[1, -2, 1], [3, -4, 1]]),  # β_2
            ]
        elif order == 7:
            return [
                np.array([[1, -2, 1], [1, -4, 3], [1, -6, 5]]),  # β_0
                np.array([[1, -2, 1], [1, -4, 3], [1, -4, 3]]),  # β_1
                np.array([[1, -2, 1], [1, -2, 1], [1, -2, 1]]),  # β_2
                np.array([[1, -2, 1], [3, -4, 1], [5, -6, 1]]),  # β_3
            ]
        else:
            raise ValueError(f"未対応のWENO次数です: {order}")

```

### numerics/weno/weights.py

```
"""WENOスキームの重み係数を計算するモジュール（改良版）"""

from typing import List, Tuple, Optional, Dict, Any
import numpy as np
import numpy.typing as npt
from core.field import ScalarField


class WeightCalculator:
    """WENOスキームの重み係数を計算するクラス（改良版）"""

    def __init__(self, epsilon: float = 1e-6, p: float = 2.0):
        """重み係数計算器を初期化

        Args:
            epsilon: ゼロ除算を防ぐための小さな値
            p: 非線形重みの指数
        """
        self._epsilon = epsilon
        self._p = p
        self._cache: Dict[str, Any] = {}

    def compute_weights(
        self,
        beta: List[npt.NDArray[np.float64]],
        optimal_weights: npt.NDArray[np.float64],
    ) -> Tuple[List[npt.NDArray[np.float64]], npt.NDArray[np.float64]]:
        """非線形重み係数を計算（改良版）

        Args:
            beta: 各ステンシルの滑らかさ指標
            optimal_weights: 理想重み係数

        Returns:
            (非線形重み係数のリスト, 正規化係数）のタプル
        """
        # ScalarFieldを活用した計算
        alpha = []
        for b, d in zip(beta, optimal_weights):
            beta_field = ScalarField(b.shape, np.ones(len(b.shape)), initial_value=b)
            # 新しい演算子を活用した計算
            alpha_k = d / ((self._epsilon + beta_field) ** self._p)
            alpha.append(alpha_k.data)

        # 正規化係数の計算（新しい演算子を活用）
        omega_sum = sum(a for a in alpha)

        # 正規化された重み係数の計算
        omega = [a / omega_sum for a in alpha]

        # 結果をキャッシュ
        self._cache = {"alpha": alpha, "omega": omega, "omega_sum": omega_sum}

        return omega, omega_sum

    def compute_mapped_weights(
        self,
        beta: List[npt.NDArray[np.float64]],
        optimal_weights: npt.NDArray[np.float64],
        mapping_function: Optional[str] = None,
    ) -> Tuple[List[npt.NDArray[np.float64]], npt.NDArray[np.float64]]:
        """マッピング関数を使用して非線形重み係数を計算（改良版）

        Args:
            beta: 各ステンシルの滑らかさ指標
            optimal_weights: 理想重み係数
            mapping_function: マッピング関数の種類

        Returns:
            (非線形重み係数のリスト, 正規化係数）のタプル
        """
        # まず通常の重み係数を計算
        omega, omega_sum = self.compute_weights(beta, optimal_weights)

        if mapping_function is None:
            return omega, omega_sum

        # マッピング関数の適用（新しい演算子を活用）
        if mapping_function == "henrick":
            omega = self._henrick_mapping(omega, optimal_weights)
        elif mapping_function == "borges":
            omega = self._borges_mapping(omega, optimal_weights)
        else:
            raise ValueError(f"未知のマッピング関数です: {mapping_function}")

        # 正規化係数の再計算
        omega_sum = sum(o for o in omega)

        return omega, omega_sum

    def _henrick_mapping(
        self,
        omega: List[npt.NDArray[np.float64]],
        optimal_weights: npt.NDArray[np.float64],
    ) -> List[npt.NDArray[np.float64]]:
        """Henrickのマッピング関数を適用（改良版）"""
        mapped_omega = []
        for w, d in zip(omega, optimal_weights):
            # ScalarFieldを活用した計算
            w_field = ScalarField(w.shape, np.ones(len(w.shape)), initial_value=w)
            numerator = w_field * (d + d * d - 3 * d * w_field + w_field * w_field)
            denominator = d * d + w_field * (1 - 2 * d)
            mapped_omega.append((numerator / denominator).data)
        return mapped_omega

    def _borges_mapping(
        self,
        omega: List[npt.NDArray[np.float64]],
        optimal_weights: npt.NDArray[np.float64],
    ) -> List[npt.NDArray[np.float64]]:
        """Borgesのマッピング関数を適用（改良版）"""
        mapped_omega = []
        for w, d in zip(omega, optimal_weights):
            # ScalarFieldを活用した計算
            w_field = ScalarField(w.shape, np.ones(len(w.shape)), initial_value=w)
            numerator = d * ((d + d - 3) * w_field * w_field + (3 - 2 * d) * w_field)
            denominator = d * d + w_field * (1 - 2 * d)
            mapped_omega.append((numerator / denominator).data)
        return mapped_omega

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得（改良版）"""
        return {
            "epsilon": self._epsilon,
            "p": self._p,
            "cache_size": len(self._cache),
            "last_weights": self._cache.get("omega"),
            "last_alpha": self._cache.get("alpha"),
            "mapping_stats": {
                "min_weight": min(np.min(w) for w in self._cache.get("omega", [0]))
                if "omega" in self._cache
                else None,
                "max_weight": max(np.max(w) for w in self._cache.get("omega", [0]))
                if "omega" in self._cache
                else None,
            },
        }

    def clear_cache(self) -> None:
        """キャッシュをクリア"""
        self._cache.clear()

```

### numerics/weno/base.py

```
"""WENOスキームの基底クラスと抽象インターフェースを提供

このモジュールは、Weighted Essentially Non-Oscillatory (WENO) スキームの
基本的なインターフェースと共通機能を定義します。

References:
    [1] Shu, Chi-Wang. "High order weighted essentially nonoscillatory
        schemes for convection dominated problems."
        SIAM review 51.1 (2009): 82-126.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Sequence
import numpy as np
import numpy.typing as npt


class WENOBase(ABC):
    """WENOスキームの基底クラス

    このクラスは、WENOスキームの基本的なインターフェースを定義し、
    共通の機能を提供します。
    """

    def __init__(self, order: int = 5, epsilon: float = 1e-6):
        """WENOスキームを初期化

        Args:
            order: スキームの次数（デフォルト: 5）
            epsilon: ゼロ除算を防ぐための小さな値
        """
        self._order = order
        self._epsilon = epsilon
        self._stencil_size = (order + 1) // 2
        self._cache: Dict[str, Any] = {}

    @property
    def order(self) -> int:
        """スキームの次数を取得"""
        return self._order

    @property
    def stencil_size(self) -> int:
        """ステンシルサイズを取得"""
        return self._stencil_size

    @abstractmethod
    def reconstruct(
        self, data: npt.NDArray[np.float64], axis: int = -1
    ) -> npt.NDArray[np.float64]:
        """WENOスキームによる再構成を実行

        Args:
            data: 入力データ配列
            axis: 再構成を行う軸

        Returns:
            再構成された値の配列
        """
        pass

    @abstractmethod
    def compute_smoothness_indicators(
        self, data: npt.NDArray[np.float64], axis: int = -1
    ) -> Sequence[npt.NDArray[np.float64]]:
        """滑らかさ指標を計算

        Args:
            data: 入力データ配列
            axis: 計算を行う軸

        Returns:
            各ステンシルの滑らかさ指標
        """
        pass

    def _validate_input(self, data: npt.NDArray[np.float64], axis: int) -> None:
        """入力データの妥当性を検証

        Args:
            data: 入力データ配列
            axis: 処理する軸

        Raises:
            ValueError: 無効な入力が指定された場合
        """
        if not isinstance(data, np.ndarray):
            raise ValueError("入力はNumPy配列である必要があります")

        if data.ndim < 1:
            raise ValueError("入力は少なくとも1次元である必要があります")

        if not -data.ndim <= axis < data.ndim:
            raise ValueError(f"無効な軸です: {axis}")

        if data.shape[axis] < self._stencil_size:
            raise ValueError(
                f"軸{axis}のサイズ({data.shape[axis]})が"
                f"ステンシルサイズ({self._stencil_size})より小さいです"
            )

    def clear_cache(self) -> None:
        """キャッシュをクリア"""
        self._cache.clear()

    def get_status(self) -> Dict[str, Any]:
        """WENOスキームの状態を取得"""
        return {
            "order": self._order,
            "stencil_size": self._stencil_size,
            "epsilon": self._epsilon,
            "cache_size": len(self._cache),
        }

```

### numerics/weno/schemes/weno3.py

```
import numpy as np
import numpy.typing as npt
from typing import List

from ..base import WENOBase
from ..coefficients import WENOCoefficients
from ..smoothness import SmoothnessIndicator
from ..weights import WeightCalculator


class WENO3(WENOBase):
    """3次精度WENOスキームのクラス（演算子改善版）"""

    def __init__(self, epsilon: float = 1e-6, p: float = 2.0):
        super().__init__(order=3, epsilon=epsilon)
        self._coeffs = WENOCoefficients()
        self._smoother = SmoothnessIndicator()
        self._weight_calc = WeightCalculator(epsilon=epsilon, p=p)
        self._interpolation_coeffs, self._optimal_weights = (
            self._coeffs.get_interpolation_coefficients(3)
        )

    def reconstruct(
        self, field: npt.NDArray[np.float64], axis: int = -1
    ) -> npt.NDArray[np.float64]:
        """WENO3による再構成を実行（新しい演算子を活用）"""
        self._validate_input(field, axis)

        # 滑らかさ指標の計算（新しい演算子を活用）
        smoothness_coeffs = self._coeffs.get_smoothness_coefficients(3)
        beta = self._smoother.compute(field, smoothness_coeffs, axis)

        # 非線形重み係数の計算
        omega, _ = self._weight_calc.compute_weights(beta, self._optimal_weights)

        # 各ステンシルの寄与を計算（新しい演算子を活用）
        result = np.zeros_like(field)
        for k in range(len(omega)):
            # このステンシルの補間値を計算
            stencil_value = np.zeros_like(field)
            for j, coeff in enumerate(self._interpolation_coeffs[k]):
                stencil_value += coeff * np.roll(field, j - 1, axis=axis)
            # 重み付き加算（新しい * 演算子を活用）
            result += omega[k] * stencil_value

        return result

    def compute_smoothness_indicators(
        self, field: npt.NDArray[np.float64], axis: int = -1
    ) -> List[npt.NDArray[np.float64]]:
        """滑らかさ指標を計算（新しい演算子を活用）"""
        smoothness_coeffs = self._coeffs.get_smoothness_coefficients(3)
        return self._smoother.compute(field, smoothness_coeffs, axis)

```

### numerics/weno/schemes/__init__.py

```
"""WENOスキームの実装を提供するパッケージ

このパッケージは、異なる次数のWENOスキームの具体的な実装を提供します。
"""

from .weno3 import WENO3
from .weno5 import WENO5
from .weno7 import WENO7

__all__ = [
    "WENO3",
    "WENO5",
    "WENO7",
]

```

### numerics/weno/schemes/weno5.py

```
"""5次精度WENOスキームの実装

このモジュールは、5次精度のWeighted Essentially Non-Oscillatory (WENO5)
スキームを実装します。これは最も一般的に使用されるWENOスキームの一つです。
"""

import numpy as np
import numpy.typing as npt
from typing import List, Dict, Any

from ..base import WENOBase
from ..coefficients import WENOCoefficients
from ..smoothness import SmoothnessIndicator
from ..weights import WeightCalculator


class WENO5(WENOBase):
    """5次精度WENOスキームのクラス"""

    def __init__(self, epsilon: float = 1e-6, p: float = 2.0, mapping: str = "none"):
        """WENO5スキームを初期化

        Args:
            epsilon: ゼロ除算を防ぐための小さな値
            p: 非線形重みの指数
            mapping: 重み係数のマッピング方法
                    ("none", "henrick", "borges"のいずれか)
        """
        super().__init__(order=5, epsilon=epsilon)

        # 係数と計算機の初期化
        self._coeffs = WENOCoefficients()
        self._smoother = SmoothnessIndicator()
        self._weight_calc = WeightCalculator(epsilon=epsilon, p=p)
        self._mapping = mapping if mapping != "none" else None

        # 補間係数と理想重み係数の取得
        self._interpolation_coeffs, self._optimal_weights = (
            self._coeffs.get_interpolation_coefficients(5)
        )

    def reconstruct(
        self, data: npt.NDArray[np.float64], axis: int = -1
    ) -> npt.NDArray[np.float64]:
        """WENO5による再構成を実行

        Args:
            data: 入力データ配列
            axis: 再構成を行う軸

        Returns:
            再構成された値の配列
        """
        # 入力の検証
        self._validate_input(data, axis)

        # 滑らかさ指標の計算
        smoothness_coeffs = self._coeffs.get_smoothness_coefficients(5)
        beta = self._smoother.compute(data, smoothness_coeffs, axis)

        # 非線形重み係数の計算（マッピング関数を考慮）
        if self._mapping:
            omega, _ = self._weight_calc.compute_mapped_weights(
                beta, self._optimal_weights, self._mapping
            )
        else:
            omega, _ = self._weight_calc.compute_weights(beta, self._optimal_weights)

        # 各ステンシルの寄与を計算
        result = np.zeros_like(data)

        # 各ステンシルについて
        for k in range(len(omega)):
            # このステンシルの補間値を計算
            stencil_value = np.zeros_like(data)
            for j, coeff in enumerate(self._interpolation_coeffs[k]):
                stencil_value += coeff * np.roll(data, j - 2, axis=axis)

            # 重み付きで加算
            result += omega[k] * stencil_value

        return result

    def compute_smoothness_indicators(
        self, data: npt.NDArray[np.float64], axis: int = -1
    ) -> List[npt.NDArray[np.float64]]:
        """滑らかさ指標を計算

        Args:
            data: 入力データ配列
            axis: 計算を行う軸

        Returns:
            各ステンシルの滑らかさ指標
        """
        smoothness_coeffs = self._coeffs.get_smoothness_coefficients(5)
        return self._smoother.compute(data, smoothness_coeffs, axis)

    def get_status(self) -> Dict[str, Any]:
        """WENOスキームの状態を取得"""
        status = super().get_status()
        status.update(
            {
                "coefficients": {
                    "interpolation": self._interpolation_coeffs.tolist(),
                    "optimal_weights": self._optimal_weights.tolist(),
                },
                "weight_calculator": self._weight_calc.get_diagnostics(),
                "mapping": self._mapping or "none",
            }
        )
        return status

```

### numerics/weno/schemes/weno7.py

```
"""3次精度WENOスキームの実装

このモジュールは、3次精度のWeighted Essentially Non-Oscillatory (WENO3)
スキームを実装します。
"""

import numpy as np
import numpy.typing as npt
from typing import List, Dict, Any

from ..base import WENOBase
from ..coefficients import WENOCoefficients
from ..smoothness import SmoothnessIndicator
from ..weights import WeightCalculator


class WENO3(WENOBase):
    """3次精度WENOスキームのクラス"""

    def __init__(self, epsilon: float = 1e-6, p: float = 2.0):
        """WENO3スキームを初期化

        Args:
            epsilon: ゼロ除算を防ぐための小さな値
            p: 非線形重みの指数
        """
        super().__init__(order=3, epsilon=epsilon)

        # 係数と計算機の初期化
        self._coeffs = WENOCoefficients()
        self._smoother = SmoothnessIndicator()
        self._weight_calc = WeightCalculator(epsilon=epsilon, p=p)

        # 補間係数と理想重み係数の取得
        self._interpolation_coeffs, self._optimal_weights = (
            self._coeffs.get_interpolation_coefficients(3)
        )

    def reconstruct(
        self, data: npt.NDArray[np.float64], axis: int = -1
    ) -> npt.NDArray[np.float64]:
        """WENO3による再構成を実行

        Args:
            data: 入力データ配列
            axis: 再構成を行う軸

        Returns:
            再構成された値の配列
        """
        # 入力の検証
        self._validate_input(data, axis)

        # 滑らかさ指標の計算
        smoothness_coeffs = self._coeffs.get_smoothness_coefficients(3)
        beta = self._smoother.compute(data, smoothness_coeffs, axis)

        # 非線形重み係数の計算
        omega, _ = self._weight_calc.compute_weights(beta, self._optimal_weights)

        # 各ステンシルの寄与を計算
        result = np.zeros_like(data)

        # 各ステンシルについて
        for k in range(len(omega)):
            # このステンシルの補間値を計算
            stencil_value = np.zeros_like(data)
            for j, coeff in enumerate(self._interpolation_coeffs[k]):
                stencil_value += coeff * np.roll(data, j - 1, axis=axis)

            # 重み付きで加算
            result += omega[k] * stencil_value

        return result

    def compute_smoothness_indicators(
        self, data: npt.NDArray[np.float64], axis: int = -1
    ) -> List[npt.NDArray[np.float64]]:
        """滑らかさ指標を計算

        Args:
            data: 入力データ配列
            axis: 計算を行う軸

        Returns:
            各ステンシルの滑らかさ指標
        """
        smoothness_coeffs = self._coeffs.get_smoothness_coefficients(3)
        return self._smoother.compute(data, smoothness_coeffs, axis)

    def get_status(self) -> Dict[str, Any]:
        """WENOスキームの状態を取得"""
        status = super().get_status()
        status.update(
            {
                "coefficients": {
                    "interpolation": self._interpolation_coeffs.tolist(),
                    "optimal_weights": self._optimal_weights.tolist(),
                },
                "weight_calculator": self._weight_calc.get_diagnostics(),
            }
        )
        return status

```

### numerics/weno/__init__.py

```
"""WENOスキームを提供するパッケージ

このパッケージは、Weighted Essentially Non-Oscillatory (WENO) スキームの
実装を提供します。WENOスキームは、不連続性を含む問題に対して高次精度の
数値解を得るための手法です。

主な機能:
- 3次、5次、7次精度のWENOスキーム
- 滑らかさ指標の計算
- 非線形重み係数の計算
- 様々なマッピング関数のサポート

Example:
    ```python
    import numpy as np
    from numerics.weno import WENO5

    # データの準備
    x = np.linspace(-1, 1, 100)
    data = np.tanh(20 * x)  # 急峻な勾配を持つデータ

    # WENO5スキームの初期化
    weno = WENO5(epsilon=1e-6, mapping="henrick")

    # データの再構成
    reconstructed = weno.reconstruct(data)
    ```
"""

from .base import WENOBase
from .coefficients import WENOCoefficients
from .smoothness import SmoothnessIndicator
from .weights import WeightCalculator
from .schemes import WENO3, WENO5, WENO7

__version__ = "1.0.0"

__all__ = [
    # スキーム
    "WENO3",
    "WENO5",
    "WENO7",
    # 基底クラスとコンポーネント
    "WENOBase",
    "WENOCoefficients",
    "SmoothnessIndicator",
    "WeightCalculator",
]

```

### numerics/time_evolution/runge_kutta.py

```
"""4次のRunge-Kutta法による時間積分を提供するモジュール（改良版）"""

from typing import List, Union
from dataclasses import dataclass

from .base import TimeIntegrator, FieldType
from core.field import ScalarField, VectorField


@dataclass
class RKStage:
    """Runge-Kutta法の各ステージの情報"""

    coefficient: float
    weight: float


class RungeKutta4(TimeIntegrator):
    """4次のRunge-Kutta法による時間積分器（改良版）"""

    def __init__(
        self,
        cfl: float = 0.5,
        min_dt: float = 1e-6,
        max_dt: float = 1.0,
        tolerance: float = 1e-6,
    ):
        super().__init__(
            cfl=cfl,
            min_dt=min_dt,
            max_dt=max_dt,
            tolerance=tolerance,
            stability_limit=2.8,
        )
        self._stages = [
            RKStage(coefficient=0.0, weight=1 / 6),
            RKStage(coefficient=0.5, weight=1 / 3),
            RKStage(coefficient=0.5, weight=1 / 3),
            RKStage(coefficient=1.0, weight=1 / 6),
        ]

    def integrate(
        self,
        field: FieldType,
        dt: float,
        derivative: FieldType,
    ) -> FieldType:
        """4次Runge-Kutta法で時間積分を実行（新しい演算子を活用）"""
        if not isinstance(derivative, type(field)):
            raise TypeError("derivativeはfieldと同じ型である必要があります")

        try:
            if isinstance(field, (ScalarField, VectorField)):
                return self._integrate_field(field, dt, derivative)
            else:
                raise ValueError("Unsupported field type")

        except Exception as e:
            raise RuntimeError(f"RK4積分中にエラー: {e}")

    def _integrate_field(
        self,
        field: Union[ScalarField, VectorField],
        dt: float,
        derivative: Union[ScalarField, VectorField],
    ) -> Union[ScalarField, VectorField]:
        """ScalarFieldまたはVectorFieldの時間積分（新しい演算子を活用）"""
        k_values = []
        temp_field = field.copy()

        # 各ステージの計算（新しい演算子を活用）
        k_values.append(derivative)  # k1 = derivative

        # k2の計算（新しい * と + 演算子を活用）
        temp_field = field + (dt * 0.5) * k_values[0]
        k_values.append(k_values[0].copy())

        # k3の計算
        temp_field = field + (dt * 0.5) * k_values[1]
        k_values.append(k_values[1].copy())

        # k4の計算
        temp_field = field + dt * k_values[2]
        k_values.append(k_values[2].copy())

        # 最終的な更新（新しい演算子を活用）
        result = field.copy()
        for k, stage in zip(k_values, self._stages):
            result += dt * stage.weight * k

        # 誤差の推定
        self._estimate_error(k_values, dt)
        return result

    def _estimate_error(self, k_values: List[FieldType], dt: float) -> None:
        """RK4の誤差を推定（新しい演算子を活用）"""
        error = dt * max(
            comp.norm()
            for k in k_values
            for comp in (k.components if hasattr(k, "components") else [k])
        )
        self._error_history.append(error)

```

### numerics/time_evolution/euler.py

```
"""前進オイラー法による時間積分を提供するモジュール"""

from typing import Union

from .base import TimeIntegrator, FieldType
from core.field import ScalarField, VectorField


class ForwardEuler(TimeIntegrator):
    """前進オイラー法による時間積分器

    簡単だが1次精度の明示的時間積分スキーム。
    条件付き安定で、時間刻み幅に制限があります。
    """

    def __init__(
        self,
        cfl: float = 0.5,
        min_dt: float = 1e-6,
        max_dt: float = 1.0,
        tolerance: float = 1e-6,
    ):
        """前進オイラー法の積分器を初期化"""
        super().__init__(
            cfl=cfl,
            min_dt=min_dt,
            max_dt=max_dt,
            tolerance=tolerance,
            stability_limit=2.0,  # von Neumannの安定性解析による
        )

    def integrate(
        self,
        field: FieldType,
        dt: float,
        derivative: FieldType,
    ) -> FieldType:
        """前進オイラー法で時間積分を実行

        Args:
            field: 現在のフィールド値
            dt: 時間刻み幅
            derivative: フィールドの時間微分（fieldと同じ型）

        Returns:
            更新されたフィールド
        """
        if not isinstance(derivative, type(field)):
            raise TypeError("derivativeはfieldと同じ型である必要があります")

        try:
            if isinstance(field, (ScalarField, VectorField)):
                return self._integrate_field(field, dt, derivative)
            else:
                raise ValueError("Unsupported field type")

        except Exception as e:
            raise RuntimeError(f"Euler積分中にエラー: {e}")

    def _integrate_field(
        self,
        field: Union[ScalarField, VectorField],
        dt: float,
        derivative: Union[ScalarField, VectorField],
    ) -> Union[ScalarField, VectorField]:
        """ScalarFieldまたはVectorFieldの時間積分"""
        # 加算演算子を使用した更新
        new_field = field + dt * derivative

        # 誤差の推定
        error = dt * derivative.norm()
        self._error_history.append(error)

        return new_field

    def compute_timestep(self, field: FieldType, **kwargs) -> float:
        """安定な時間刻み幅を計算"""
        dt = super().compute_timestep(field, **kwargs)
        return self._clip_timestep(dt)

    def get_order(self) -> int:
        """数値スキームの次数を取得"""
        return 1

    def get_error_estimate(self) -> float:
        """誤差の推定値を取得

        前進オイラー法の局所打ち切り誤差は O(dt²)
        """
        if not self._error_history:
            return float("inf")
        return max(self._error_history[-10:])

```

### numerics/time_evolution/base.py

```
"""時間発展ソルバーの基底クラスを提供するモジュール

このモジュールは、数値時間発展計算のための基底クラスとインターフェースを定義します。
"""

from abc import ABC, abstractmethod
from typing import Union, Optional, Dict, Any
from datetime import datetime
import numpy as np

from core.field import ScalarField, VectorField

# 入力として受け付けるフィールドの型
FieldType = Union[ScalarField, VectorField]


class TimeIntegrator(ABC):
    """時間積分の基底クラス"""

    def __init__(
        self,
        cfl: float = 0.5,
        min_dt: float = 1e-6,
        max_dt: float = 1.0,
        tolerance: float = 1e-6,
        stability_limit: float = float("inf"),
    ):
        """時間積分器を初期化

        Args:
            cfl: CFL条件の係数
            min_dt: 最小時間刻み幅
            max_dt: 最大時間刻み幅
            tolerance: 収束判定の許容誤差
            stability_limit: 安定性限界
        """
        self._validate_parameters(cfl, min_dt, max_dt, tolerance)
        self._cfl = cfl
        self._min_dt = min_dt
        self._max_dt = max_dt
        self._tolerance = tolerance
        self._stability_limit = stability_limit
        self._time = 0.0
        self._dt = None
        self._start_time = None
        self._step_count = 0
        self._error_history = []

    def _validate_parameters(
        self, cfl: float, min_dt: float, max_dt: float, tolerance: float
    ) -> None:
        """パラメータの妥当性を検証"""
        if not 0 < cfl <= 1:
            raise ValueError("CFLは0から1の間である必要があります")
        if min_dt <= 0 or max_dt <= 0:
            raise ValueError("時間刻み幅は正である必要があります")
        if min_dt > max_dt:
            raise ValueError("最小時間刻み幅は最大時間刻み幅以下である必要があります")
        if tolerance <= 0:
            raise ValueError("許容誤差は正である必要があります")

    @abstractmethod
    def integrate(
        self,
        field: FieldType,
        dt: float,
        derivative: FieldType,
    ) -> FieldType:
        """時間積分を実行

        Args:
            field: 現在のフィールド値（ScalarFieldまたはVectorField）
            dt: 時間刻み幅
            derivative: フィールドの時間微分（fieldと同じ型）

        Returns:
            更新されたフィールド（fieldと同じ型）
        """
        pass

    def step_forward(
        self,
        field: FieldType,
        derivative: FieldType,
        dt: Optional[float] = None,
    ) -> tuple[FieldType, Dict[str, Any]]:
        """1ステップの時間発展を実行

        Args:
            field: 現在のフィールド値
            derivative: フィールドの時間微分
            dt: 時間刻み幅（Noneの場合は自動計算）

        Returns:
            (更新されたフィールド, 診断情報)のタプル
        """
        if not isinstance(field, (ScalarField, VectorField)):
            raise TypeError("fieldはScalarFieldまたはVectorFieldである必要があります")

        if not isinstance(derivative, type(field)):
            raise TypeError("derivativeはfieldと同じ型である必要があります")

        # 開始時刻の記録
        if self._start_time is None:
            self._start_time = datetime.now()

        # 時間刻み幅の決定
        if dt is None:
            dt = self.compute_timestep(field)
        dt = self._validate_timestep(dt)

        try:
            # 時間発展の実行
            new_field = self.integrate(field, dt, derivative)

            # 時刻の更新
            self._time += dt
            self._dt = dt
            self._step_count += 1

            # 診断情報の収集と返却
            diagnostics = self._create_diagnostics(dt)
            return new_field, diagnostics

        except Exception as e:
            raise RuntimeError(f"時間発展中にエラー: {e}")

    def compute_timestep(self, field: FieldType, **kwargs) -> float:
        """安定な時間刻み幅を計算"""
        return self._max_dt

    def _validate_timestep(self, dt: float) -> float:
        """時間刻み幅の妥当性を検証"""
        if dt <= 0:
            raise ValueError("時間刻み幅は正である必要があります")
        return self._clip_timestep(dt)

    def _clip_timestep(self, dt: float) -> float:
        """時間刻み幅を許容範囲に制限"""
        return np.clip(dt, self._min_dt, self._max_dt)

    def _create_diagnostics(self, dt: float) -> Dict[str, Any]:
        """診断情報を生成"""
        return {
            "time": self._time,
            "dt": dt,
            "method": self.__class__.__name__,
            "order": self.get_order(),
            "step_count": self._step_count,
            "error_estimate": self.get_error_estimate(),
            "elapsed_time": self.elapsed_time,
            "stability_limit": self._stability_limit,
        }

    @property
    def elapsed_time(self) -> Optional[float]:
        """経過時間を計算"""
        if self._start_time is None:
            return None
        return (datetime.now() - self._start_time).total_seconds()

    @abstractmethod
    def get_order(self) -> int:
        """数値スキームの次数を取得"""
        pass

    @abstractmethod
    def get_error_estimate(self) -> float:
        """誤差の推定値を取得"""
        pass

    def reset(self):
        """積分器の状態をリセット"""
        self._time = 0.0
        self._dt = None
        self._start_time = None
        self._step_count = 0
        self._error_history.clear()

```

### numerics/time_evolution/__init__.py

```
"""時間積分パッケージ

このパッケージは、様々な時間積分スキームの実装を提供します。
- TimeIntegrator: 時間積分の基底クラス
- ForwardEuler: 1次精度の前進オイラー法
- RungeKutta4: 4次精度のRunge-Kutta法
"""

from .base import TimeIntegrator
from .euler import ForwardEuler
from .runge_kutta import RungeKutta4

__all__ = [
    # 基底クラス
    "TimeIntegrator",
    # 具体的な実装
    "ForwardEuler",
    "RungeKutta4",
]

```

### numerics/poisson/solver.py

```
"""Poisson方程式のソルバー（改良版）"""

from typing import Optional, Union, List
import numpy as np

from core.field import ScalarField
from core.solver import IterativeSolver
from core.boundary import BoundaryCondition
from .base import PoissonSolverBase, PoissonSolverTerm
from .config import PoissonSolverConfig


class PoissonSolver(PoissonSolverBase, IterativeSolver):
    """Poisson方程式のソルバークラス（改良版）"""

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        boundary_conditions: Optional[List[BoundaryCondition]] = None,
        terms: Optional[List[PoissonSolverTerm]] = None,
        **kwargs,
    ):
        config = config or PoissonSolverConfig()
        kwargs.setdefault("name", "Poisson")
        kwargs.setdefault("tolerance", config.convergence.get("tolerance", 1e-6))
        kwargs.setdefault(
            "max_iterations", config.convergence.get("max_iterations", 1000)
        )

        PoissonSolverBase.__init__(
            self,
            config=config,
            boundary_conditions=boundary_conditions,
            logger=kwargs.get("logger"),
        )
        IterativeSolver.__init__(self, **kwargs)

        self.terms = terms or []
        self._converged = False
        self._initial_residual = None

    def compute_residual(
        self,
        solution: Union[np.ndarray, ScalarField],
        rhs: Union[np.ndarray, ScalarField],
        dx: Union[float, np.ndarray],
    ) -> float:
        """残差を計算（新しい演算子を活用）"""
        if isinstance(solution, ScalarField):
            solution_field = solution
        else:
            solution_field = ScalarField(solution.shape, dx, initial_value=solution)

        if isinstance(rhs, ScalarField):
            rhs_field = rhs
        else:
            rhs_field = ScalarField(rhs.shape, dx, initial_value=rhs)

        # ラプラシアンの計算（新しい演算子を活用）
        laplacian = solution_field.laplacian()

        # 残差の計算（新しい演算子を活用）
        residual = laplacian - rhs_field

        # 境界条件の適用
        if self.boundary_conditions:
            for i, bc in enumerate(self.boundary_conditions):
                if bc is not None:
                    residual = bc.apply_all(residual, i)

        # L2ノルムを計算（新しいnorm()メソッドを活用）
        return max(residual.norm(), 1e-15)

    def iterate(
        self,
        solution: Union[np.ndarray, ScalarField],
        rhs: Union[np.ndarray, ScalarField],
        dx: Union[float, np.ndarray],
    ) -> Union[np.ndarray, ScalarField]:
        """1回の反復を実行（新しい演算子を活用）"""
        if isinstance(solution, np.ndarray):
            solution = ScalarField(solution.shape, dx, initial_value=solution)
        if isinstance(rhs, np.ndarray):
            rhs = ScalarField(rhs.shape, dx, initial_value=rhs)

        # ラプラシアンの計算（新しい演算子を活用）
        laplacian = solution.laplacian()

        # 更新量の計算（新しい演算子を活用）
        update = (rhs - laplacian) * self.omega

        # 解の更新（新しい + 演算子を活用）
        return solution + update

```

### numerics/poisson/base.py

```
"""Poisson方程式ソルバーの基底クラスとプロトコル

このモジュールは、Poisson方程式を解くためのインターフェースと基底クラスを定義します。
"""

from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any, Union
import numpy as np

from core.boundary import BoundaryCondition
from .config import PoissonSolverConfig  # 修正: config から import


class PoissonSolverTerm:
    """Poisson方程式の項のプロトコル"""

    @property
    def name(self) -> str:
        """項の名前"""
        return ""

    def compute(self, solution: np.ndarray, **kwargs) -> np.ndarray:
        """項の寄与を計算"""
        return np.zeros_like(solution)

    def get_diagnostics(self, solution: np.ndarray, **kwargs) -> Dict[str, Any]:
        """診断情報を取得"""
        return {}


class PoissonSolverBase(ABC):
    """Poisson方程式ソルバーの基底抽象クラス"""

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        boundary_conditions: Optional[List[BoundaryCondition]] = None,
        logger=None,
    ):
        """ソルバーを初期化

        Args:
            config: ソルバー設定
            boundary_conditions: 境界条件
            logger: ロガー
        """
        self.config = config or PoissonSolverConfig()
        self.boundary_conditions = boundary_conditions or []
        self.logger = logger

        # 計算状態の追跡
        self._iteration_count = 0
        self._residual_history: List[float] = []
        self._converged = False

    @abstractmethod
    def solve(
        self, rhs: np.ndarray, initial_solution: Optional[np.ndarray] = None, **kwargs
    ) -> np.ndarray:
        """Poisson方程式を解く"""
        pass

    @abstractmethod
    def compute_residual(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> float:
        """残差を計算"""
        pass

    def initialize(self, **kwargs):
        """ソルバーを初期化

        デフォルトの実装では基本的な状態をリセット
        サブクラスでオーバーライド可能
        """
        # 計算状態のリセット
        self._iteration_count = 0
        self._residual_history = []
        self._converged = False

        # ロギング
        if self.logger:
            self.logger.info(f"{self.__class__.__name__}ソルバーを初期化")

    def get_diagnostics(self) -> Dict[str, Any]:
        """ソルバーの診断情報を取得

        Returns:
            診断情報の辞書
        """
        return {
            "iteration_count": self._iteration_count,
            "converged": self._converged,
            "residual_history": self._residual_history,
            "final_residual": (
                self._residual_history[-1] if self._residual_history else None
            ),
        }

    def reset(self):
        """ソルバーの状態をリセット"""
        self._iteration_count = 0
        self._residual_history = []
        self._converged = False

    def log_diagnostics(self):
        """診断情報をログ出力"""
        if self.logger:
            diag = self.get_diagnostics()
            self.logger.info(f"Poissonソルバー診断情報: {diag}")

```

### numerics/poisson/config.py

```
from dataclasses import dataclass, field
from typing import Dict, Any
import yaml


@dataclass
class PoissonSolverConfig:
    """Poisson方程式ソルバーの数値計算パラメータ"""

    # 収束判定パラメータ
    convergence: Dict[str, Any] = field(
        default_factory=lambda: {
            "tolerance": 1e-6,
            "max_iterations": 1000,
            "relative_tolerance": False,
        }
    )

    # ソルバー固有のパラメータ
    solver_specific: Dict[str, Any] = field(
        default_factory=lambda: {
            "relaxation_parameter": 1.5,  # SORなどで使用
            "auto_tune": False,
            "method": "sor",
        }
    )

    # 診断情報の保存設定
    diagnostics: Dict[str, Any] = field(
        default_factory=lambda: {"save_residual_history": True, "log_frequency": 10}
    )

    def validate(self):
        """設定値の妥当性を検証"""
        # 収束判定パラメータの検証
        if not 0 < self.convergence.get("tolerance", 1e-6) < 1:
            raise ValueError("許容誤差は0から1の間である必要があります")

        if not isinstance(self.convergence.get("max_iterations", 1000), int):
            raise ValueError("最大反復回数は整数である必要があります")

        # ソルバー固有のパラメータ検証
        if not 0 < self.solver_specific.get("relaxation_parameter", 1.5) <= 2:
            raise ValueError("緩和パラメータは0から2の間である必要があります")

        # 有効なソルバー方法のチェック
        valid_methods = ["sor", "jacobi", "gauss_seidel"]
        if self.solver_specific.get("method") not in valid_methods:
            raise ValueError(f"無効なソルバー方法。選択肢: {valid_methods}")

    def get_config_for_component(self, component: str) -> Dict[str, Any]:
        """特定のコンポーネントの設定を取得

        Args:
            component: 設定を取得するコンポーネント名

        Returns:
            コンポーネント固有の設定
        """
        component_configs = {
            "convergence": self.convergence,
            "solver_specific": self.solver_specific,
            "diagnostics": self.diagnostics,
        }
        return component_configs.get(component, {})

    def save(self, filepath: str):
        """設定をYAMLファイルに保存

        Args:
            filepath: 保存先のパス
        """
        with open(filepath, "w", encoding="utf-8") as f:
            yaml.dump(
                {
                    "convergence": self.convergence,
                    "solver_specific": self.solver_specific,
                    "diagnostics": self.diagnostics,
                },
                f,
                default_flow_style=False,
            )

    @classmethod
    def from_yaml(cls, filepath: str) -> "PoissonSolverConfig":
        """YAMLファイルから設定を読み込む

        Args:
            filepath: 読み込むYAMLファイルのパス

        Returns:
            読み込まれた設定インスタンス
        """
        with open(filepath, "r", encoding="utf-8") as f:
            config_dict = yaml.safe_load(f)

        # 設定の検証を含めた初期化
        config = cls(
            convergence=config_dict.get("convergence", {}),
            solver_specific=config_dict.get("solver_specific", {}),
            diagnostics=config_dict.get("diagnostics", {}),
        )
        config.validate()
        return config

```

### numerics/poisson/__init__.py

```
"""Poisson方程式のソルバーパッケージ

このパッケージは、Poisson方程式を解くための各種ソルバーを提供します。

主な機能:
- 基本的なPoissonソルバーのインターフェース
- SOR法による反復解法
- 共役勾配法（CG）による反復解法
- 設定管理
"""

from .base import (
    PoissonSolverBase,
    PoissonSolverTerm,
)
from .config import PoissonSolverConfig as PoissonConfig
from .solver import PoissonSolver
from .methods.sor import SORSolver
from .methods.cg import ConjugateGradientSolver

__all__ = [
    # ベースクラスとインターフェース
    "PoissonSolverBase",
    "PoissonSolverTerm",
    "PoissonConfig",
    # ソルバー
    "PoissonSolver",
    "SORSolver",
    "ConjugateGradientSolver",
]

```

### numerics/poisson/methods/sor.py

```
"""
SOR法によるPoissonソルバーの実装

SOR（Successive Over-Relaxation）法は、
Gauss-Seidel法を緩和パラメータ（omega）で加速する反復法です。
"""

import numpy as np
from typing import Optional, List, Dict, Any, Union

from numerics.poisson import PoissonSolver
from core.boundary import BoundaryCondition
from ..base import PoissonSolverTerm
from ..config import PoissonSolverConfig


class SORSolver(PoissonSolver):
    """SOR法によるPoissonソルバー"""

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        boundary_conditions: Optional[List[BoundaryCondition]] = None,
        terms: Optional[List[PoissonSolverTerm]] = None,
        **kwargs,
    ):
        """
        SORソルバーを初期化

        Args:
            config: ソルバー設定
            boundary_conditions: 境界条件のリスト
            terms: 追加の項
            **kwargs: 追加のパラメータ
        """
        # デフォルト設定の取得
        solver_config = config or PoissonSolverConfig()

        # デフォルトのSOR関連パラメータ
        solver_specific = solver_config.get_config_for_component("solver_specific")

        # 緩和係数の取得（デフォルト1.5）
        self.omega = kwargs.get(
            "omega", solver_specific.get("relaxation_parameter", 1.5)
        )

        # 親クラスの初期化
        super().__init__(
            config=solver_config,
            boundary_conditions=boundary_conditions,
            terms=terms,
            **kwargs,
        )

    def iterate(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> np.ndarray:
        """
        SOR法による1回の反復計算

        Args:
            solution: 現在の解
            rhs: 右辺
            dx: グリッド間隔

        Returns:
            更新された解
        """
        # dx の正規化
        if np.isscalar(dx):
            dx = np.full(solution.ndim, dx)
        elif len(dx) != solution.ndim:
            raise ValueError(f"dxは{solution.ndim}次元である必要があります")

        # 計算結果のコピー
        result = solution.copy()

        # 各次元についてSOR更新
        for axis in range(solution.ndim):
            # 各軸方向の近傍点からの寄与を計算
            neighbors_sum = np.roll(result, 1, axis=axis) + np.roll(
                result, -1, axis=axis
            )

            # SOR更新の計算
            correction = (rhs + (neighbors_sum) / (2 * solution.ndim)) / (
                2 / dx[axis] ** 2 + 1e-10
            )

            # 緩和パラメータの適用
            result = (1 - self.omega) * result + self.omega * correction

        # 境界条件の適用
        if self.boundary_conditions:
            for i, bc in enumerate(self.boundary_conditions):
                if bc is not None:
                    result = bc.apply_all(result, i)

        return result

    def get_diagnostics(self) -> Dict[str, Any]:
        """
        診断情報を取得

        Returns:
            診断情報の辞書
        """
        diag = super().get_diagnostics()
        diag.update(
            {
                "method": "SOR",
                "omega": self.omega,
            }
        )
        return diag

```

### numerics/poisson/methods/cg.py

```
"""
共役勾配法（CG）によるPoissonソルバーの実装

このモジュールは、圧力ポアソン方程式を解くための共役勾配法を実装します。
共役勾配法は対称正定値な問題に対して効率的な反復解法です。
"""

import numpy as np
from typing import Optional, Dict, Any, Union
from ..base import PoissonSolverConfig
from ..solver import PoissonSolver


class ConjugateGradientSolver(PoissonSolver):
    """共役勾配法によるPoissonソルバー"""

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        preconditioner: str = "none",
        **kwargs,
    ):
        """共役勾配法ソルバーを初期化

        Args:
            config: ソルバー設定
            preconditioner: 前処理の種類 ('none', 'jacobi', 'ilu')
            **kwargs: 基底クラスに渡すパラメータ
        """
        super().__init__(config=config, **kwargs)
        self.preconditioner = preconditioner
        self._iteration_count = 0
        self._residual_history = []
        self._initial_residual_norm = None

    def solve(
        self,
        rhs: np.ndarray,
        initial_solution: Optional[np.ndarray] = None,
        dx: Union[float, np.ndarray] = 1.0,
    ) -> np.ndarray:
        """Poisson方程式を解く

        Args:
            rhs: 右辺ベクトル
            initial_solution: 初期推定解（オプション）
            dx: グリッド間隔

        Returns:
            計算された解
        """
        # 初期化
        if initial_solution is None:
            solution = np.zeros_like(rhs)
        else:
            solution = initial_solution.copy()

        # 初期残差の計算
        self.residual = rhs - self._apply_operator(solution, dx)
        residual_norm = np.linalg.norm(self.residual)

        # ゼロ右辺のチェック
        rhs_norm = np.linalg.norm(rhs)
        if rhs_norm < 1e-15:
            return np.zeros_like(rhs)

        self._initial_residual_norm = residual_norm
        self._residual_history = [residual_norm]

        # 前処理の適用
        if self.preconditioner == "jacobi":
            self.z = self._apply_jacobi_preconditioner(self.residual, dx)
        else:
            self.z = self.residual.copy()

        # 初期サーチ方向
        self.p = self.z.copy()
        self.rz_old = np.sum(self.residual * self.z)

        # メインの反復ループ
        for i in range(self.max_iterations):
            # Ap の計算
            Ap = self._apply_operator(self.p, dx)
            pAp = np.sum(self.p * Ap)

            # ステップサイズの計算
            if abs(pAp) < 1e-14:
                # サーチ方向が非常に小さい場合
                if residual_norm < self.tolerance * rhs_norm:
                    # 既に十分収束している
                    break
                else:
                    # 新しいサーチ方向で再開
                    self.p = self.residual.copy()
                    Ap = self._apply_operator(self.p, dx)
                    pAp = np.sum(self.p * Ap)
                    if abs(pAp) < 1e-14:
                        raise ValueError("共役勾配法: 適切なサーチ方向が見つかりません")

            alpha = self.rz_old / pAp

            # 解と残差の更新
            solution += alpha * self.p
            self.residual -= alpha * Ap

            # 収束判定
            residual_norm = np.linalg.norm(self.residual)
            self._residual_history.append(residual_norm)

            if residual_norm < self.tolerance * rhs_norm:
                break

            # 前処理の適用
            if self.preconditioner == "jacobi":
                self.z = self._apply_jacobi_preconditioner(self.residual, dx)
            else:
                self.z = self.residual.copy()

            # βの計算
            rz_new = np.sum(self.residual * self.z)
            beta = rz_new / self.rz_old
            self.rz_old = rz_new

            # サーチ方向の更新
            self.p = self.z + beta * self.p

        self._iteration_count = i + 1
        return solution

    def _apply_operator(
        self, v: np.ndarray, dx: Union[float, np.ndarray]
    ) -> np.ndarray:
        """ラプラシアン演算子を適用

        Args:
            v: 入力ベクトル
            dx: グリッド間隔（スカラーまたはベクトル）

        Returns:
            ラプラシアン演算子を適用した結果
        """
        result = np.zeros_like(v)

        # dxをベクトルとして扱う
        if np.isscalar(dx):
            dx_vec = np.full(v.ndim, dx)
        else:
            dx_vec = np.asarray(dx)

        # 各方向のラプラシアンを計算
        for axis in range(v.ndim):
            # 中心差分による2階微分
            forward = np.roll(v, -1, axis=axis)
            backward = np.roll(v, 1, axis=axis)
            result += (forward - 2 * v + backward) / (dx_vec[axis] * dx_vec[axis])

        return result

    def _apply_jacobi_preconditioner(
        self, v: np.ndarray, dx: Union[float, np.ndarray]
    ) -> np.ndarray:
        """Jacobi前処理を適用

        Args:
            v: 入力ベクトル
            dx: グリッド間隔（スカラーまたはベクトル）

        Returns:
            前処理を適用した結果
        """
        # dxをベクトルとして扱う
        if np.isscalar(dx):
            dx_vec = np.full(v.ndim, dx)
        else:
            dx_vec = np.asarray(dx)

        # 対角項の逆数を計算（ラプラシアン演算子の場合）
        diagonal = sum(-2.0 / (dx_i * dx_i) for dx_i in dx_vec)
        return v / (diagonal + 1e-14)  # ゼロ除算防止

    def get_convergence_info(self) -> Dict[str, Any]:
        """収束情報を取得"""
        return {
            "iterations": self._iteration_count,
            "initial_residual": self._initial_residual_norm,
            "final_residual": self._residual_history[-1]
            if self._residual_history
            else None,
            "residual_history": self._residual_history,
            "converged": self._iteration_count < self.max_iterations,
        }

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "method": "Conjugate Gradient",
                "preconditioner": self.preconditioner,
                "convergence_info": self.get_convergence_info(),
            }
        )
        return diag

```

### core/boundary/dirichlet.py

```
"""ディリクレ境界条件を提供するモジュール

このモジュールは、流体シミュレーションで使用されるディリクレ境界条件を実装します。
ディリクレ境界条件では、境界上で物理量の値を指定します。
"""

import numpy as np
from .base import BoundaryCondition, StencilInfo


class DirichletBoundary(BoundaryCondition):
    """ディリクレ境界条件クラス

    ディリクレ境界条件は、境界上で物理量の値を指定します。
    壁面での速度や温度などを指定する場合に使用されます。
    """

    def __init__(self, value: float = 0.0, order: int = 2):
        """ディリクレ境界条件を初期化

        Args:
            value: 境界での値
            order: 差分近似の次数
        """
        super().__init__(order)
        self.value = value

    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """ディリクレ境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()

        # 境界面のスライスを取得
        boundary_slice = self.get_boundary_slice(field, axis, side, 1)

        # 境界値を設定
        result[boundary_slice] = self.value

        return result

    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        # 2次精度の場合
        if self.order == 2:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1, 2]),
                    coefficients=np.array([-3 / 2, 2, -1 / 2]),
                )
            else:
                return StencilInfo(
                    points=np.array([-2, -1, 0]),
                    coefficients=np.array([1 / 2, -2, 3 / 2]),
                )
        # 4次精度の場合
        elif self.order == 4:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1, 2, 3, 4]),
                    coefficients=np.array([-25 / 12, 4, -3, 4 / 3, -1 / 4]),
                )
            else:
                return StencilInfo(
                    points=np.array([-4, -3, -2, -1, 0]),
                    coefficients=np.array([1 / 4, -4 / 3, 3, -4, 25 / 12]),
                )
        else:
            raise ValueError(f"未対応の次数です: {self.order}")

```

### core/boundary/base.py

```
"""境界条件の基底クラスを提供するモジュール

このモジュールは、流体シミュレーションで使用される境界条件の基底クラスを定義します。
すべての具体的な境界条件（周期境界、ディリクレ境界など）は、この基底クラスを継承します。
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Tuple
import numpy as np


@dataclass
class StencilInfo:
    """差分ステンシルの情報を保持するクラス

    Attributes:
        points: ステンシルの位置（中心からの相対位置）
        coefficients: 各点での係数
    """

    points: np.ndarray  # 形状: (N,)
    coefficients: np.ndarray  # 形状: (N,)


class BoundaryCondition(ABC):
    """境界条件の基底クラス

    この抽象基底クラスは、すべての境界条件に共通のインターフェースを定義します。
    """

    def __init__(self, order: int = 2):
        """境界条件を初期化

        Args:
            order: 差分近似の次数（デフォルトは2次精度）
        """
        self.order = order

    @abstractmethod
    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        pass

    @abstractmethod
    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        pass

    def validate_field(self, field: np.ndarray, axis: int) -> None:
        """場の妥当性をチェック

        Args:
            field: チェックする場
            axis: チェックする軸

        Raises:
            ValueError: 無効な場や軸が指定された場合
        """
        if not isinstance(field, np.ndarray):
            raise ValueError("fieldはnumpy配列である必要があります")
        if not 0 <= axis < field.ndim:
            raise ValueError(f"無効な軸です: {axis}")

    def apply_all(self, field: np.ndarray, axis: int) -> np.ndarray:
        """両側の境界に境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()

        # 負側の境界に適用
        result = self.apply(result, axis, 0)

        # 正側の境界に適用
        result = self.apply(result, axis, 1)

        return result

    def get_boundary_slice(
        self, field: np.ndarray, axis: int, side: int, width: int
    ) -> Tuple[slice, ...]:
        """境界領域のスライスを取得

        Args:
            field: 対象の場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）
            width: 境界領域の幅

        Returns:
            境界領域を選択するスライスのタプル
        """
        slices = [slice(None)] * field.ndim
        if side == 0:
            slices[axis] = slice(0, width)
        else:
            slices[axis] = slice(-width, None)
        return tuple(slices)

    def get_ghost_points(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """ゴースト点の座標を取得

        Args:
            field: 対象の場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ゴースト点の座標配列
        """
        # ステンシル情報から必要なゴースト点の数を決定
        stencil = self.get_stencil(side)
        n_ghost = len(stencil.points)

        # 境界に沿った座標グリッドを生成
        shape = list(field.shape)
        shape[axis] = n_ghost
        coordinates = np.empty(shape + [field.ndim])

        # 各次元の座標を設定
        for dim in range(field.ndim):
            if dim == axis:
                if side == 0:
                    coords = np.arange(-n_ghost, 0)
                else:
                    coords = np.arange(field.shape[axis], field.shape[axis] + n_ghost)
            else:
                coords = np.arange(field.shape[dim])
            coordinates[..., dim] = coords

        return coordinates

```

### core/boundary/periodic.py

```
"""周期境界条件を提供するモジュール

このモジュールは、流体シミュレーションで使用される周期境界条件を実装します。
周期境界条件では、計算領域の両端が接続されているとして扱います。
"""

import numpy as np
from .base import BoundaryCondition, StencilInfo


class PeriodicBoundary(BoundaryCondition):
    """周期境界条件クラス

    周期境界条件は、計算領域の両端が接続されているとして扱います。
    物理量は領域の境界で連続的に繰り返されます。
    """

    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """周期境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()

        # ステンシル情報から必要なゴースト点の数を決定
        stencil = self.get_stencil(side)
        n_ghost = len(stencil.points)

        # 境界領域のスライスを取得
        ghost_slice = self.get_boundary_slice(field, axis, side, n_ghost)

        # 反対側の内部領域から値をコピー
        if side == 0:  # 負側の境界
            source_slice = self.get_boundary_slice(field, axis, 1, n_ghost)
            result[ghost_slice] = field[source_slice]
        else:  # 正側の境界
            source_slice = self.get_boundary_slice(field, axis, 0, n_ghost)
            result[ghost_slice] = field[source_slice]

        return result

    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        # 2次精度中心差分の場合
        if self.order == 2:
            return StencilInfo(
                points=np.array([-1, 0, 1]), coefficients=np.array([-0.5, 0.0, 0.5])
            )
        # 4次精度中心差分の場合
        elif self.order == 4:
            return StencilInfo(
                points=np.array([-2, -1, 0, 1, 2]),
                coefficients=np.array([1 / 12, -2 / 3, 0, 2 / 3, -1 / 12]),
            )
        else:
            raise ValueError(f"未対応の次数です: {self.order}")

```

### core/boundary/neumann.py

```
"""ノイマン境界条件を提供するモジュール

このモジュールは、流体シミュレーションで使用されるノイマン境界条件を実装します。
ノイマン境界条件では、境界上で物理量の勾配を指定します。
"""

import numpy as np
from .base import BoundaryCondition, StencilInfo


class NeumannBoundary(BoundaryCondition):
    """ノイマン境界条件クラス

    ノイマン境界条件は、境界上で物理量の勾配を指定します。
    断熱壁や流出境界などで使用されます。
    """

    def __init__(self, gradient: float = 0.0, order: int = 2):
        """ノイマン境界条件を初期化

        Args:
            gradient: 境界での勾配
            order: 差分近似の次数
        """
        super().__init__(order)
        self.gradient = gradient

    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """ノイマン境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()
        dx = 1.0  # 正規化された格子間隔

        # 境界近傍の値を取得
        if side == 0:  # 負側の境界
            interior_slice = self.get_boundary_slice(field, axis, 1, 1)
            interior_value = field[interior_slice]
            # 勾配条件に基づいて境界値を設定
            boundary_slice = self.get_boundary_slice(field, axis, 0, 1)
            result[boundary_slice] = interior_value - self.gradient * dx
        else:  # 正側の境界
            interior_slice = self.get_boundary_slice(field, axis, 0, 1)
            interior_value = field[interior_slice]
            # 勾配条件に基づいて境界値を設定
            boundary_slice = self.get_boundary_slice(field, axis, 1, 1)
            result[boundary_slice] = interior_value + self.gradient * dx

        return result

    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        # 2次精度の場合
        if self.order == 2:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1]), coefficients=np.array([-1.0, 1.0])
                )
            else:
                return StencilInfo(
                    points=np.array([-1, 0]), coefficients=np.array([-1.0, 1.0])
                )
        # 4次精度の場合
        elif self.order == 4:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1, 2, 3]),
                    coefficients=np.array([-11 / 6, 3, -3 / 2, 1 / 3]),
                )
            else:
                return StencilInfo(
                    points=np.array([-3, -2, -1, 0]),
                    coefficients=np.array([-1 / 3, 3 / 2, -3, 11 / 6]),
                )
        else:
            raise ValueError(f"未対応の次数です: {self.order}")

```

### core/boundary/__init__.py

```
"""境界条件パッケージ

このパッケージは、流体シミュレーションで使用される各種境界条件を提供します。
"""

from .base import BoundaryCondition, StencilInfo
from .periodic import PeriodicBoundary
from .dirichlet import DirichletBoundary
from .neumann import NeumannBoundary

__all__ = [
    "BoundaryCondition",
    "StencilInfo",
    "PeriodicBoundary",
    "DirichletBoundary",
    "NeumannBoundary",
]

```

### core/solver/base.py

```
"""ソルバーの基底クラスを提供するモジュール

このモジュールは、数値解法の基底となる抽象クラスを定義します。
全ての具体的なソルバーはこの基底クラスを継承します。
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from datetime import datetime


class Solver(ABC):
    """ソルバーの基底クラス

    この抽象基底クラスは、全てのソルバーに共通のインターフェースと
    基本機能を提供します。
    """

    def __init__(
        self,
        name: str,
        tolerance: float = 1e-6,
        max_iterations: int = 1000,
        logger=None,
        **extra_kwargs,  # 追加のキーワード引数を許可
    ):
        """ソルバーを初期化

        Args:
            name: ソルバーの名前
            tolerance: 収束判定の許容誤差
            max_iterations: 最大反復回数
            logger: ロガー（オプション）
            **extra_kwargs: 追加のキーワード引数（柔軟性のため）
        """
        self.name = name
        self._tolerance = tolerance
        self._max_iterations = max_iterations
        self._iteration_count = 0
        self._residual_history = []
        self._start_time = None
        self._end_time = None
        self._logger = logger

        # 追加のキーワード引数を属性として保存（必要に応じて）
        for key, value in extra_kwargs.items():
            setattr(self, f"_{key}", value)

    @property
    def tolerance(self) -> float:
        """収束判定の許容誤差を取得"""
        return self._tolerance

    @tolerance.setter
    def tolerance(self, value: float):
        """収束判定の許容誤差を設定"""
        if value <= 0:
            raise ValueError("許容誤差は正の値である必要があります")
        self._tolerance = value

    @property
    def max_iterations(self) -> int:
        """最大反復回数を取得"""
        return self._max_iterations

    @max_iterations.setter
    def max_iterations(self, value: int):
        """最大反復回数を設定"""
        if value <= 0:
            raise ValueError("最大反復回数は正の整数である必要があります")
        self._max_iterations = value

    @property
    def iteration_count(self) -> int:
        """現在の反復回数を取得"""
        return self._iteration_count

    @property
    def residual_history(self) -> list:
        """残差の履歴を取得"""
        return self._residual_history.copy()

    @property
    def elapsed_time(self) -> Optional[float]:
        """計算経過時間を取得（秒）"""
        if self._start_time is None:
            return None
        end_time = self._end_time or datetime.now()
        return (end_time - self._start_time).total_seconds()

    @abstractmethod
    def initialize(self, **kwargs) -> None:
        """ソルバーの初期化"""
        pass

    @abstractmethod
    def solve(self, **kwargs) -> Dict[str, Any]:
        """ソルバーを実行"""
        pass

    def reset(self):
        """ソルバーの状態をリセット"""
        self._iteration_count = 0
        self._residual_history = []
        self._start_time = None
        self._end_time = None

    def _start_solving(self):
        """計算開始時の処理"""
        self.reset()
        self._start_time = datetime.now()
        if self._logger:
            self._logger.info(f"{self.name}ソルバーの計算を開始")

    def _end_solving(self):
        """計算終了時の処理"""
        self._end_time = datetime.now()
        if self._logger:
            self._logger.info(
                f"{self.name}ソルバーの計算を終了 (経過時間: {self.elapsed_time:.2f}秒)"
            )

    def get_status(self) -> Dict[str, Any]:
        """ソルバーの現在の状態を取得"""
        return {
            "name": self.name,
            "iteration_count": self.iteration_count,
            "residual": self._residual_history[-1] if self._residual_history else None,
            "elapsed_time": self.elapsed_time,
        }

    def __str__(self) -> str:
        """ソルバーの文字列表現を取得"""
        status = self.get_status()
        return (
            f"Solver: {status['name']}\n"
            f"Iterations: {status['iteration_count']}\n"
            f"Current Residual: {status['residual']}\n"
            f"Elapsed Time: {status['elapsed_time']:.2f}s"
        )

```

### core/solver/temporal.py

```
"""時間発展ソルバーの基底クラスを提供するモジュール

このモジュールは、時間発展問題を解くためのソルバーの基底クラスを定義します。
"""

from abc import abstractmethod
from typing import Dict, Any, Optional
from .base import Solver


class TemporalSolver(Solver):
    """時間発展ソルバーの基底クラス"""

    def __init__(
        self,
        name: str,
        cfl: float = 0.5,
        min_dt: float = 1e-6,
        max_dt: float = 1.0,
        tolerance: float = 1e-6,
        max_iterations: int = 1000,
        logger=None,
    ):
        """時間発展ソルバーを初期化"""
        super().__init__(
            name=name, tolerance=tolerance, max_iterations=max_iterations, logger=logger
        )
        self._time = 0.0
        self._dt = None
        self._cfl = cfl
        self._min_dt = min_dt
        self._max_dt = max_dt
        self._time_history = []

    @property
    def time(self) -> float:
        """現在の時刻を取得"""
        return self._time

    @property
    def dt(self) -> Optional[float]:
        """時間刻み幅を取得"""
        return self._dt

    @property
    def cfl(self) -> float:
        """CFL数を取得"""
        return self._cfl

    @cfl.setter
    def cfl(self, value: float):
        """CFL数を設定"""
        if value <= 0:
            raise ValueError("CFL数は正の値である必要があります")
        self._cfl = value

    @abstractmethod
    def compute_timestep(self, **kwargs) -> float:
        """時間刻み幅を計算"""
        pass

    @abstractmethod
    def advance(self, dt: float, **kwargs) -> Dict[str, Any]:
        """1時間ステップ進める"""
        pass

```

### core/solver/iterative.py

```
"""反復法ソルバーの基底クラスを提供するモジュール

このモジュールは、反復法による方程式求解のための基底クラスを定義します。
"""

from abc import abstractmethod
from typing import Dict, Any
import numpy as np
from .base import Solver


class IterativeSolver(Solver):
    """反復法ソルバーの基底クラス

    この抽象基底クラスは、反復法による求解を行うソルバーに共通の
    機能を提供します。
    """

    def __init__(self, name: str, omega: float = 1.0, **kwargs):
        """反復法ソルバーを初期化

        Args:
            name: ソルバーの名前
            omega: 緩和係数
            **kwargs: 基底クラスに渡すパラメータ
        """
        super().__init__(name, **kwargs)
        self._omega = omega
        self._initial_residual = None
        self._convergence_history = []

    @property
    def omega(self) -> float:
        """緩和係数を取得"""
        return self._omega

    @omega.setter
    def omega(self, value: float):
        """緩和係数を設定

        Args:
            value: 設定する緩和係数

        Raises:
            ValueError: 不適切な値が指定された場合
        """
        if value <= 0 or value > 2:
            raise ValueError("緩和係数は0から2の間である必要があります")
        self._omega = value

    @abstractmethod
    def compute_residual(self, solution: np.ndarray, **kwargs) -> float:
        """残差を計算

        Args:
            solution: 現在の解
            **kwargs: 計算に必要なパラメータ

        Returns:
            計算された残差
        """
        pass

    @abstractmethod
    def iterate(self, solution: np.ndarray, **kwargs) -> np.ndarray:
        """1回の反復を実行

        Args:
            solution: 現在の解
            **kwargs: 計算に必要なパラメータ

        Returns:
            更新された解
        """
        pass

    def check_convergence(self, residual: float) -> bool:
        """収束判定

        Args:
            residual: 現在の残差

        Returns:
            収束したかどうか
        """
        # 初回の残差を記録
        if self._initial_residual is None:
            self._initial_residual = residual
            return False

        # 初期残差が非常に小さい場合の特別な処理
        if self._initial_residual < 1e-15:
            return residual < 1e-10

        # 相対残差による収束判定
        relative_residual = residual / self._initial_residual
        self._convergence_history.append(relative_residual)

        # 相対残差と絶対残差の両方でチェック
        return (relative_residual < self.tolerance) and (residual < 1e-10)

    def solve(self, initial_solution: np.ndarray, **kwargs) -> Dict[str, Any]:
        """反復法で方程式を解く

        Args:
            initial_solution: 初期推定解
            **kwargs: 計算に必要なパラメータ

        Returns:
            計算結果と統計情報を含む辞書

        Raises:
            RuntimeError: 最大反復回数に達しても収束しない場合
        """
        self._start_solving()

        # 初期解のコピー
        solution = initial_solution.copy()

        # 初期残差の計算
        self._initial_residual = self.compute_residual(solution, **kwargs)
        self._residual_history.append(self._initial_residual)

        while self._iteration_count < self.max_iterations:
            # 1回の反復
            solution = self.iterate(solution, **kwargs)

            # 残差の計算
            residual = self.compute_residual(solution, **kwargs)
            self._residual_history.append(residual)

            # 反復回数の更新
            self._iteration_count += 1

            # 収束判定
            if self.check_convergence(residual):
                self._end_solving()
                return {
                    "solution": solution,
                    "converged": True,
                    "iterations": self._iteration_count,
                    "residual": residual,
                    "convergence_history": self._convergence_history,
                    "elapsed_time": self.elapsed_time,
                }

        self._end_solving()
        raise RuntimeError(
            f"ソルバーが収束しませんでした: 残差 = {residual}, "
            f"相対残差 = {residual / self._initial_residual}"
        )

    def get_status(self) -> Dict[str, Any]:
        """ソルバーの状態を取得"""
        status = super().get_status()
        status.update(
            {
                "omega": self._omega,
                "initial_residual": self._initial_residual,
                "current_convergence": self._convergence_history[-1]
                if self._convergence_history
                else None,
            }
        )
        return status

```

### core/solver/__init__.py

```
"""ソルバーパッケージ

このパッケージは、数値計算のための様々なソルバーの基底クラスを提供します。
"""

from .base import Solver
from .temporal import TemporalSolver
from .iterative import IterativeSolver

__all__ = ["Solver", "TemporalSolver", "IterativeSolver"]

```

### core/field/scalar.py

```
"""スカラー場クラスを提供するモジュール

このモジュールは、スカラー量（圧力、温度など）を表現するための場のクラスを定義します。
"""

from __future__ import annotations  # 型アノテーションの評価を延期
from typing import Tuple, Optional, Union, List, Dict, Any, TYPE_CHECKING
import numpy as np
from .field import Field

if TYPE_CHECKING:
    from .vector import VectorField


class ScalarField(Field):
    """スカラー場クラス

    温度、圧力などのスカラー量を表現するためのクラスです。
    基本的な微分演算や補間機能を提供します。
    """

    def __init__(
        self,
        shape: Tuple[int, ...],
        dx: Union[float, np.ndarray] = 1.0,
        initial_value: Union[float, np.ndarray] = 0.0,
    ):
        """スカラー場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔（スカラーまたはベクトル）
            initial_value: 初期値（スカラーまたは配列）
        """
        # スーパークラスの初期化
        Field.__init__(self, shape, dx)

        # データの初期化（以前の実装と同じ）
        if isinstance(initial_value, np.ndarray):
            if initial_value.shape != shape:
                raise ValueError(
                    f"Initial value shape {initial_value.shape} does not match field shape {shape}"
                )
            self._data = initial_value.copy()
        elif isinstance(initial_value, (int, float)):
            if initial_value != 0.0:
                self._data.fill(initial_value)
        else:
            raise TypeError(f"Unsupported initial_value type: {type(initial_value)}")

    @property
    def components(self) -> List[ScalarField]:
        """ScalarFieldは自身を唯一のコンポーネントとして返す"""
        return [self]

    def magnitude(self) -> ScalarField:
        """絶対値の大きさを計算

        Returns:
            絶対値の大きさを表すスカラー場
        """
        result = ScalarField(self.shape, self.dx)
        result.data = np.abs(self.data)
        return result

    def __neg__(self) -> ScalarField:
        """単項マイナス演算子の実装

        データの符号を反転したScalarFieldを返します。
        """
        result = ScalarField(self.shape, self.dx)
        result.data = -self.data
        return result

    def interpolate(self, points: np.ndarray) -> np.ndarray:
        """任意の点での値を線形補間

        Args:
            points: 補間点の座標 (N, ndim)

        Returns:
            補間された値 (N,)
        """
        # 各次元のインデックスと重みを計算
        indices = []
        weights = []

        for dim in range(self.ndim):
            # 座標をインデックスに変換
            idx = points[:, dim] / self._dx[dim]
            idx0 = np.floor(idx).astype(int)
            idx1 = idx0 + 1
            w1 = idx - idx0
            w0 = 1.0 - w1

            # 境界条件の適用
            idx0 = np.clip(idx0, 0, self.shape[dim] - 1)
            idx1 = np.clip(idx1, 0, self.shape[dim] - 1)

            indices.append((idx0, idx1))
            weights.append((w0, w1))

        # 全ての隣接点での重み付き和を計算
        result = np.zeros(len(points))
        for i in range(2**self.ndim):
            # i のビット表現から各次元でのインデックスを決定
            idx = []
            w = 1.0
            for d in range(self.ndim):
                bit = (i >> d) & 1
                idx.append(indices[d][bit])
                w *= weights[d][bit]

            # インデックスでの値を重み付きで加算
            result += w * self._data[tuple(idx)]

        return result

    def gradient(
        self, axis: Optional[int] = None
    ) -> Union[np.ndarray, List[np.ndarray]]:
        """勾配を計算

        Args:
            axis: 勾配を計算する軸（Noneの場合は全軸の勾配を返す）

        Returns:
            指定された軸の勾配、またはすべての軸の勾配のリスト
        """
        if axis is not None:
            # 特定の軸の勾配を計算
            return np.gradient(self._data, self._dx[axis], axis=axis)

        # すべての軸の勾配を計算
        return [np.gradient(self._data, self._dx[i], axis=i) for i in range(self.ndim)]

    def integrate(self) -> float:
        """場の積分値を計算"""
        return np.sum(self._data) * np.prod(self._dx)

    def mean(self) -> float:
        """場の平均値を計算"""
        return np.mean(self._data)

    def min(self) -> float:
        """場の最小値を取得"""
        return np.min(self._data)

    def max(self) -> float:
        """場の最大値を取得"""
        return np.max(self._data)

    def normalize(self):
        """場を正規化

        場の値を[0, 1]の範囲に正規化します。
        """
        min_val = self.min()
        max_val = self.max()
        if max_val > min_val:
            self._data = (self._data - min_val) / (max_val - min_val)

    def clip(self, min_val: Optional[float] = None, max_val: Optional[float] = None):
        """場の値を指定範囲に制限

        Args:
            min_val: 最小値（Noneの場合は制限なし）
            max_val: 最大値（Noneの場合は制限なし）
        """
        self._data = np.clip(self._data, min_val, max_val)

    def smooth(self, sigma: float = 1.0):
        """場をガウシアンフィルタで平滑化

        Args:
            sigma: ガウシアンフィルタの標準偏差
        """
        from scipy.ndimage import gaussian_filter

        self._data = gaussian_filter(self._data, sigma)

    def __add__(self, other: Union[ScalarField, float]) -> ScalarField:
        """加算演算子の実装"""
        result = self.__class__(self.shape, self.dx)
        if isinstance(other, (int, float)):
            result.data = self.data + other
        elif isinstance(other, ScalarField):
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result.data = self.data + other.data
        else:
            raise TypeError("無効な型との演算です")
        return result

    def __mul__(
        self, other: Union[ScalarField, VectorField, float]
    ) -> Union[ScalarField, VectorField]:
        """乗算演算子の実装"""
        # VectorFieldのインポートを関数内で行うことで循環インポートを回避
        from .vector import VectorField

        if isinstance(other, (int, float)):
            result = self.__class__(self.shape, self.dx)
            result.data = self.data * other
            return result
        elif isinstance(other, ScalarField):
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result = self.__class__(self.shape, self.dx)
            result.data = self.data * other.data
            return result
        elif isinstance(other, np.ndarray):
            if self.data.shape != other.shape:
                raise ValueError("配列の形状が一致しません")
            result = self.__class__(self.shape, self.dx)
            result.data = self.data * other
            return result
        elif isinstance(other, VectorField):
            # VectorFieldとの乗算
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result = VectorField(self.shape, self.dx)
            for i, comp in enumerate(other.components):
                # ScalarField同士の乗算を使用
                scalar_result = self.__class__(self.shape, self.dx)
                scalar_result.data = self.data * comp.data
                result.components[i] = scalar_result
            return result
        else:
            raise TypeError("無効な型との演算です")

    def __rmul__(
        self, other: Union[float, VectorField]
    ) -> Union[ScalarField, VectorField]:
        """右乗算演算子の実装"""
        if isinstance(other, (int, float)):
            return self.__mul__(other)
        elif TYPE_CHECKING and isinstance(other, VectorField):
            return self.__mul__(other)
        else:
            raise TypeError("無効な型との演算です")

    def __truediv__(self, other: Union[ScalarField, float]) -> ScalarField:
        """除算演算子の実装"""
        result = self.__class__(self.shape, self.dx)
        if isinstance(other, (int, float)):
            result.data = self.data / other
        elif isinstance(other, ScalarField):
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result.data = self.data / other.data
        else:
            raise TypeError("無効な型との演算です")
        return result

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "magnitude": float(self.magnitude().max()),
            "min": float(self.min()),
            "max": float(self.max()),
            "mean": float(self.mean()),
        }

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        return {
            "data": self.data.copy(),
            "shape": self.shape,
            "dx": self.dx,
            "time": self.time,
        }

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        # データの復元
        if tuple(state["shape"]) != self.shape:
            raise ValueError("形状が一致しません")

        self.data = state["data"].copy()

        # 時刻の復元
        self.time = state.get("time", 0.0)

        # グリッド間隔の確認（必要に応じて）
        if not np.allclose(state["dx"], self.dx):
            raise ValueError("グリッド間隔が一致しません")

    def norm(self, ord=2) -> float:
        """場のノルムを計算

        Args:
            ord: ノルムの種類（デフォルトはL2ノルム）

        Returns:
            計算されたノルム
        """
        return np.linalg.norm(self._data.ravel(), ord=ord)

```

### core/field/vector.py

```
"""ベクトル場クラスを提供するモジュール

このモジュールは、ベクトル量（速度、運動量など）を表現するための
ベクトル場クラスを定義します。"""

from __future__ import annotations  # 型アノテーションの評価を延期
from typing import List, Tuple, Optional, Union, Dict, Any, TYPE_CHECKING
import numpy as np
from .field import Field

if TYPE_CHECKING:
    from .scalar import ScalarField


class VectorField(Field):
    """ベクトル場クラス

    速度、運動量などのベクトル量を表現するためのクラスです。
    各成分をスカラー場として保持し、ベクトル演算のメソッドを提供します。
    """

    def __init__(self, shape: Tuple[int, ...], dx: Union[float, np.ndarray] = 1.0):
        """ベクトル場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔（スカラーまたはベクトル）
        """
        # dxの正規化：スカラーの場合はベクトルに変換
        if np.isscalar(dx):
            dx = np.full(len(shape), float(dx))

        # 基底クラスの初期化
        super().__init__(shape, dx)

        # 循環インポートを避けるために遅延インポート
        from .scalar import ScalarField

        # データの初期化
        self._data = np.zeros(shape + (len(shape),))
        self._components = [
            ScalarField(shape, dx, initial_value=self._data[..., i].copy())
            for i in range(len(shape))
        ]

    @property
    def components(self) -> List[ScalarField]:
        """ベクトル場の各成分を取得"""
        # 各コンポーネントのデータを更新
        for i, comp in enumerate(self._components):
            comp._data = self._data[..., i].copy()  # 直接_dataを更新
        return self._components

    @components.setter
    def components(self, value: List[ScalarField]):
        """ベクトル場の各成分を設定

        Args:
            value: 設定するスカラー場のリスト

        Raises:
            ValueError: コンポーネントの数が不正な場合
        """
        if len(value) != len(self._components):
            raise ValueError(
                f"コンポーネント数が一致しません: {len(value)} != {len(self._components)}"
            )
        if not all(isinstance(v, ScalarField) for v in value):
            raise ValueError("すべての要素がScalarFieldである必要があります")
        if not all(v.shape == self.shape[:-1] for v in value):
            raise ValueError("すべてのコンポーネントは同じ形状である必要があります")

        # 各コンポーネントのデータを更新
        for i, comp in enumerate(value):
            self._data[..., i] = comp.data
            self._components[i] = comp

    def magnitude(self) -> ScalarField:
        """ベクトル場の大きさを計算

        Returns:
            計算されたベクトルの大きさを表すスカラー場
        """
        from .scalar import ScalarField

        result = ScalarField(self.shape[:-1], self.dx)  # 形状から最後の次元を除外
        result.data = np.sqrt(np.sum(self._data**2, axis=-1))
        return result

    def symmetric_gradient(self) -> VectorField:
        """対称勾配テンソルを計算

        Returns:
            対称勾配テンソルをVectorFieldとして返す
        """
        result = VectorField(self.shape[:-1], self.dx)  # 形状から最後の次元を除外
        for i in range(self.ndim):
            for j in range(self.ndim):
                # 対称勾配: 0.5 * (∂u_i/∂x_j + ∂u_j/∂x_i)
                if i <= j:  # 対称性を利用して計算を最適化
                    comp_data = 0.5 * (
                        np.gradient(self._data[..., i], self.dx[j], axis=j)
                        + np.gradient(self._data[..., j], self.dx[i], axis=i)
                    )
                    result._data[..., i] = comp_data
                else:
                    # 対称性を利用して既に計算した値をコピー
                    result._data[..., i] = result._data[..., j]
        return result

    def gradient(self) -> VectorField:
        """ベクトル場の勾配を計算

        Returns:
            勾配テンソルをVectorFieldとして返す
        """
        result = VectorField(self.shape[:-1], self.dx)  # 形状から最後の次元を除外
        for i in range(self.ndim):
            for j in range(self.ndim):
                # ∂u_i/∂x_j
                result._data[..., i] = np.gradient(
                    self._data[..., j], self.dx[i], axis=i
                )
        return result

    def divergence(self) -> ScalarField:
        """発散を計算

        Returns:
            計算された発散を表すスカラー場
        """
        from .scalar import ScalarField

        result = ScalarField(self.shape[:-1], self.dx)  # 形状から最後の次元を除外
        divs = [
            np.gradient(self._data[..., i], self.dx[i], axis=i)
            for i in range(self.ndim)
        ]
        result.data = np.sum(divs, axis=0)
        return result

    def curl(self) -> Optional[VectorField]:
        """回転を計算（3次元のみ）

        Returns:
            3次元の場合は計算された回転を表すベクトル場
            2次元の場合はNone
        """
        if self.ndim != 3:
            return None

        result = VectorField(self.shape[:-1], self.dx)  # 形状から最後の次元を除外
        # ∂w/∂y - ∂v/∂z
        result._data[..., 0] = np.gradient(
            self._data[..., 2], self.dx[1], axis=1
        ) - np.gradient(self._data[..., 1], self.dx[2], axis=2)
        # ∂u/∂z - ∂w/∂x
        result._data[..., 1] = np.gradient(
            self._data[..., 0], self.dx[2], axis=2
        ) - np.gradient(self._data[..., 2], self.dx[0], axis=0)
        # ∂v/∂x - ∂u/∂y
        result._data[..., 2] = np.gradient(
            self._data[..., 1], self.dx[0], axis=0
        ) - np.gradient(self._data[..., 0], self.dx[1], axis=1)
        return result

    def integrate(self) -> float:
        """場の積分値を計算

        Returns:
            各成分の積分値の二乗和の平方根
        """
        # グリッド体積要素
        dV = np.prod(self.dx)
        # 各成分の積分
        integral_squares = [
            np.sum(self._data[..., i]) ** 2 * dV**2 for i in range(self.ndim)
        ]
        return np.sqrt(np.sum(integral_squares))

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "max_magnitude": float(self.magnitude().max()),
            "components": {
                f"component_{i}": {
                    "min": float(np.min(self._data[..., i])),
                    "max": float(np.max(self._data[..., i])),
                    "mean": float(np.mean(self._data[..., i])),
                    "norm": float(np.linalg.norm(self._data[..., i])),
                }
                for i in range(self.ndim)
            },
        }

    def __neg__(self) -> VectorField:
        """単項マイナス演算子の実装"""
        result = VectorField(self.shape[:-1], self.dx)
        result._data = -self._data
        return result

    def __add__(self, other: VectorField) -> VectorField:
        """加算演算子の実装"""
        if not isinstance(other, VectorField):
            raise TypeError("ベクトル場同士の演算のみ可能です")
        if self.shape != other.shape:
            raise ValueError("場の形状が一致しません")

        result = VectorField(self.shape[:-1], self.dx)
        result._data = self._data + other._data
        return result

    def __mul__(self, other: Union[float, ScalarField]) -> VectorField:
        """スカラー倍の実装"""
        result = VectorField(self.shape[:-1], self.dx)

        if isinstance(other, (int, float)):
            result._data = self._data * other
        elif isinstance(other, ScalarField):
            if other.shape != self.shape[:-1]:
                raise ValueError("場の形状が一致しません")
            # スカラー場を各成分に掛ける
            result._data = self._data * other.data[..., np.newaxis]
        else:
            raise TypeError("スカラーまたはスカラー場との乗算のみ可能です")

        return result

    def __rmul__(self, other: Union[float, ScalarField]) -> VectorField:
        """右スカラー倍の実装"""
        return self.__mul__(other)

    def __truediv__(self, other: Union[float, ScalarField]) -> VectorField:
        """除算の実装"""
        result = VectorField(self.shape[:-1], self.dx)

        if isinstance(other, (int, float)):
            result._data = self._data / other
        elif isinstance(other, ScalarField):
            if other.shape != self.shape[:-1]:
                raise ValueError("場の形状が一致しません")
            # スカラー場で各成分を割る
            result._data = self._data / other.data[..., np.newaxis]
        else:
            raise TypeError("スカラーまたはスカラー場との除算のみ可能です")

        return result

    def dot(self, other: VectorField) -> ScalarField:
        """内積を計算"""
        if not isinstance(other, VectorField):
            raise TypeError("ベクトル場同士の演算のみ可能です")
        if self.shape != other.shape:
            raise ValueError("場の形状が一致しません")

        from .scalar import ScalarField

        result = ScalarField(self.shape[:-1], self.dx)
        result.data = np.sum(self._data * other._data, axis=-1)
        return result

    def cross(self, other: VectorField) -> Optional[VectorField]:
        """外積を計算（3次元のみ）"""
        if self.ndim != 3:
            return None
        if not isinstance(other, VectorField):
            raise TypeError("ベクトル場同士の演算のみ可能です")
        if self.shape != other.shape:
            raise ValueError("場の形状が一致しません")

        result = VectorField(self.shape[:-1], self.dx)
        # 外積の各成分を計算
        result._data[..., 0] = (
            self._data[..., 1] * other._data[..., 2]
            - self._data[..., 2] * other._data[..., 1]
        )
        result._data[..., 1] = (
            self._data[..., 2] * other._data[..., 0]
            - self._data[..., 0] * other._data[..., 2]
        )
        result._data[..., 2] = (
            self._data[..., 0] * other._data[..., 1]
            - self._data[..., 1] * other._data[..., 0]
        )
        return result

    def norm(self) -> float:
        """ベクトル場のノルムを計算

        Returns:
            全成分のL2ノルムの最大値
        """
        # 各成分のL2ノルムを計算
        component_norms = [
            np.sqrt(np.mean(self._data[..., i] ** 2)) for i in range(self.ndim)
        ]
        # 最大のノルムを返す
        return max(component_norms)

```

### core/field/field.py

```
"""場の基底クラスを提供するモジュール

このモジュールは流体シミュレーションで使用される場の基底クラスを定義します。
すべての具体的な場の実装（スカラー場、ベクトル場など）は、この基底クラスを継承します。
"""

from abc import ABC, abstractmethod
from typing import Tuple, Dict, Any, Union, List
import numpy as np


class Field(ABC):
    """場の基底クラス

    この抽象基底クラスは、流体シミュレーションで使用される全ての場に共通の
    インターフェースと基本機能を提供します。

    Attributes:
        shape (Tuple[int, ...]): グリッドの形状
        dx (Union[float, np.ndarray]): グリッド間隔（スカラーまたはベクトル）
        time (float): 現在の時刻
    """

    def __init__(self, shape: Tuple[int, ...], dx: Union[float, np.ndarray] = 1.0):
        """場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔（スカラーまたはベクトル）
        """
        self._data = np.zeros(shape)

        # dxの処理：スカラーの場合はベクトルに変換
        if isinstance(dx, (int, float)):
            self._dx = np.full(len(shape), float(dx))
        else:
            self._dx = np.asarray(dx, dtype=float)
            if len(self._dx) != len(shape):
                # VectorFieldの場合、最後の次元は成分を表すので除外してチェック
                base_shape = shape[:-1] if len(shape) > len(self._dx) else shape
                if len(self._dx) != len(base_shape):
                    raise ValueError(
                        f"dxの次元数({len(self._dx)})がshapeの次元数({len(base_shape)})と一致しません"
                    )

        self._time = 0.0

    @property
    @abstractmethod
    def components(self) -> List[Any]:
        """場のコンポーネントを取得する抽象メソッド

        サブクラスで実装する必要があります。
        """
        pass

    def get_component_diagnostics(self) -> Dict[str, Any]:
        """全コンポーネントの診断情報を取得

        Returns:
            コンポーネントごとの診断情報を含む辞書
        """
        try:
            return {
                f"component_{i}": {
                    "magnitude": float(comp.magnitude().max())
                    if hasattr(comp, "magnitude")
                    else None,
                    "min": float(comp.min()) if hasattr(comp, "min") else None,
                    "max": float(comp.max()) if hasattr(comp, "max") else None,
                    "mean": float(comp.mean()) if hasattr(comp, "mean") else None,
                }
                for i, comp in enumerate(self.components)
            }
        except Exception:
            return {}

    def magnitude(self) -> "Field":
        """場の大きさを計算する共通メソッド

        サブクラスで具体的な実装が必要です。
        """
        raise NotImplementedError("サブクラスで実装する必要があります")

    @property
    def data(self) -> np.ndarray:
        """場のデータを取得"""
        return self._data

    @data.setter
    def data(self, value: np.ndarray):
        """場のデータを設定

        Args:
            value: 設定するデータ配列

        Raises:
            ValueError: データの形状が不一致の場合
        """
        if value.shape != self._data.shape:
            raise ValueError(f"形状が一致しません: {value.shape} != {self._data.shape}")
        self._data = value.copy()  # 防御的コピー

    @property
    def shape(self) -> Tuple[int, ...]:
        """場の形状を取得"""
        return self._data.shape

    @property
    def ndim(self) -> int:
        """次元数を取得"""
        return self._data.ndim

    @property
    def dx(self) -> Union[float, np.ndarray]:
        """グリッド間隔を取得"""
        return self._dx

    @property
    def time(self) -> float:
        """現在の時刻を取得"""
        return self._time

    @time.setter
    def time(self, value: float):
        """時刻を設定

        Args:
            value: 設定する時刻

        Raises:
            ValueError: 負の時刻が指定された場合
        """
        if value < 0:
            raise ValueError("時刻は非負である必要があります")
        self._time = value

    def gradient(self, axis: int) -> np.ndarray:
        """指定軸方向の勾配を計算

        中心差分による2次精度の勾配計算を行います。

        Args:
            axis: 勾配を計算する軸のインデックス

        Returns:
            計算された勾配
        """
        if not 0 <= axis < self.ndim:
            raise ValueError(f"無効な軸です: {axis}")

        # スライスを使って各方向の勾配を計算
        dx = self._dx[axis]
        grad = np.gradient(self._data, dx, axis=axis)
        return grad

    def divergence(self) -> np.ndarray:
        """発散を計算

        中心差分による2次精度の発散計算を行います。

        Returns:
            計算された発散
        """
        div = np.zeros_like(self._data)
        for i in range(self.ndim):
            div += self.gradient(i)
        return div

    def laplacian(self) -> np.ndarray:
        """ラプラシアンを計算

        中心差分による2次精度のラプラシアン計算を行います。

        Returns:
            計算されたラプラシアン
        """
        lap = np.zeros_like(self._data)
        for i in range(self.ndim):
            lap += np.gradient(self.gradient(i), self._dx[i], axis=i)
        return lap

    def copy(self) -> "Field":
        """場の深いコピーを作成

        Returns:
            コピーされた場
        """
        new_field = self.__class__(self.shape, self.dx)
        new_field.data = self.data.copy()
        new_field.time = self.time
        return new_field

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        return {"data": self._data.copy(), "time": self._time, "dx": self._dx}

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        self._data = state["data"].copy()
        self._time = state["time"]
        self._dx = state["dx"]

    @abstractmethod
    def integrate(self) -> float:
        """場の積分値を計算

        Returns:
            計算された積分値
        """
        pass

```

### core/field/__init__.py

```
from .field import Field
from .scalar import ScalarField
from .vector import VectorField

__all__ = ["Field", "ScalarField", "VectorField"]

```

### config.yaml

```
# Two-phase flow simulation configuration

# 物理パラメータ
physics:
  gravity: 9.81  # 重力加速度 [m/s²]
  surface_tension: 0.072  # 表面張力係数 [N/m]

  # 相の物性値
  phases:
    - phase: water
      density: 1000.0  # 密度 [kg/m³]
      viscosity: 1.0e-3  # 動粘性係数 [Pa·s]
      surface_tension: 0.07  # 表面張力係数 [N/m]
    - phase: nitrogen
      density: 1.25  # 密度 [kg/m³]
      viscosity: 1.81e-5  # 動粘性係数 [Pa·s]
      surface_tension: 0.0  # 表面張力係数 [N/m]

# 計算領域の設定
domain:
  dimensions: [32, 32, 32]  # X, Y, Z方向のグリッドポイント数
  size: [1.0, 1.0, 1.0]  # X, Y, Z方向の物理的サイズ [m]

# 境界条件
boundary_conditions:
  x: 
    left: periodic
    right: periodic
  y: 
    front: periodic
    back: periodic
  z: 
    bottom: neumann
    top: neumann

# 初期条件
initial_conditions:
  background:
    phase: nitrogen  # デフォルトの背景相

  # 界面オブジェクトの設定
  objects:
    - type: plate  # プレート（平面）界面の例
      phase: water
      height: 0.70  # 0から1の間の値を使用
    
    - type: sphere  # 球形界面の例
      phase: nitrogen
      center: [0.5, 0.5, 0.4]
      radius: 0.2

  # 初期速度場の設定
  velocity:
    type: zero  # または "uniform", "vortex"

# 数値スキーム
numerical:
  time_integrator: "euler"  # または "rk4"
  max_time: 2.0
  initial_dt: 0.001
  save_interval: 0.01
  cfl: 0.5
  min_dt: 1.0e-6
  max_dt: 1.0e-2

  # 界面関数の設定
  interface:
    epsilon: 1.0e-2  # 界面厚さパラメータ
    reinit_interval: 5  # 再初期化の間隔（ステップ数）
    reinit_steps: 2  # 再初期化の反復回数
    reinit_method: "fast_marching"  # 再初期化の手法
    
    # 界面追跡のパラメータ
    smoothing: true  # 界面の平滑化を有効化
    smoothing_iterations: 1  # 平滑化の反復回数
    smoothing_factor: 0.1  # 平滑化の強度

# 可視化設定
output:
  output_dir: "results/visualization"
  format: "png"  # 出力フォーマット
  dpi: 300       # 解像度
  colormap: "viridis"  # デフォルトのカラーマップ
  show_colorbar: true  # カラーバーの表示
  show_axes: true      # 軸の表示
  show_grid: false     # グリッドの表示

  # スライス位置と軸を明示的に指定
  slices:
    axes: 
      - "xy"   # XY面
      - "xz"   # XZ面
      - "yz"   # YZ面
    positions: 
      - 0.5    # 中央

  # 可視化する物理量を選択
  fields:
    velocity:
      enabled: true   # 速度場を可視化
      plot_types: ["vector", "magnitude"]
      scale: 1.0
      density: 20
      color: "black"
      alpha: 0.7
    pressure:
      enabled: true   # 圧力場を可視化
      plot_types: ["scalar", "contour"]
      levels: 20
      alpha: 0.5
    levelset:
      enabled: true   # 界面関数を可視化
      plot_types: ["interface", "contour"]
      levels: [0]
      colors: ["black"]
      linewidth: 2.0

# デバッグ設定
debug:
  level: "ERROR"
  save_fields: true
  check_divergence: true
  plot_residuals: true
  profiling: false
```

### results/visualization/simulation_state_pressure_yz_slice_0.50_0.000_0.000000.json

```
{
  "data_range": {
    "min": 0.0,
    "max": 0.0
  },
  "display_type": [
    "scalar",
    "slice"
  ]
}
```

### results/visualization/simulation_state_velocity_xz_slice_0.50_0.000_0.000000.json

```
{
  "data_range": {
    "min_magnitude": 0.0,
    "max_magnitude": 0.0
  },
  "display_type": [
    "vector",
    "slice"
  ],
  "slice_info": {
    "axis": "xy",
    "position": 0.5
  }
}
```

### results/visualization/simulation_state_pressure_xz_slice_0.50_0.000_0.000000.json

```
{
  "data_range": {
    "min": 0.0,
    "max": 0.0
  },
  "display_type": [
    "scalar",
    "slice"
  ]
}
```

### results/visualization/simulation_state_levelset_xy_slice_0.50_0.000_0.000000.json

```
{
  "data_range": {
    "min": -0.7273618495495704,
    "max": 0.17379342450117433
  },
  "display_type": [
    "scalar",
    "slice"
  ]
}
```

### results/visualization/simulation_state_pressure_xy_slice_0.50_0.000_0.000000.json

```
{
  "data_range": {
    "min": 0.0,
    "max": 0.0
  },
  "display_type": [
    "scalar",
    "slice"
  ]
}
```

### results/visualization/diagnostics/diagnostics_0.000000.json

```
{
  "time": 0.0,
  "velocity_max": 0.0,
  "pressure_max": 0.0,
  "levelset_min": -0.7273618495495704,
  "levelset_max": 0.17379342450117433,
  "interface_geometry": {
    "volume_fraction": 0.030673067010308575,
    "interface_points": 5884,
    "interface_area": 0.4774121918301932,
    "distance_error": 5.9558759377161035e-05,
    "curvature": {
      "min": -38.63180401353125,
      "max": -5.523467195304148,
      "mean": -8.204176285902001,
      "rms": 9.017090533573018
    }
  }
}
```

### results/visualization/simulation_state_levelset_yz_slice_0.50_0.000_0.000000.json

```
{
  "data_range": {
    "min": -0.7273618495495704,
    "max": 0.17379342450117433
  },
  "display_type": [
    "scalar",
    "slice"
  ]
}
```

### results/visualization/simulation_state_velocity_xy_slice_0.50_0.000_0.000000.json

```
{
  "data_range": {
    "min_magnitude": 0.0,
    "max_magnitude": 0.0
  },
  "display_type": [
    "vector",
    "slice"
  ],
  "slice_info": {
    "axis": "xy",
    "position": 0.5
  }
}
```

### results/visualization/simulation_state_levelset_xz_slice_0.50_0.000_0.000000.json

```
{
  "data_range": {
    "min": -0.7273618495495704,
    "max": 0.17379342450117433
  },
  "display_type": [
    "scalar",
    "slice"
  ]
}
```

### results/visualization/simulation_state_velocity_yz_slice_0.50_0.000_0.000000.json

```
{
  "data_range": {
    "min_magnitude": 0.0,
    "max_magnitude": 0.0
  },
  "display_type": [
    "vector",
    "slice"
  ],
  "slice_info": {
    "axis": "xy",
    "position": 0.5
  }
}
```

### physics/pressure/poisson.py

```
"""
圧力ポアソン方程式のソルバー

圧力ポアソン方程式: ∇²p = ∇⋅f を解きます。

ここで、右辺の f は以下の項から構成されます：
- 移流項: -ρ(u⋅∇)u
- 粘性項: μ∇²u
- 外力項: ρg + f_s (重力と表面張力)
"""

from typing import Optional, Dict, Any, Tuple
import numpy as np

from core.field import VectorField, ScalarField
from numerics.poisson import PoissonConfig, ConjugateGradientSolver
from .terms import AdvectionTerm, ViscousTerm, ForceTerm


class PressurePoissonSolver:
    """圧力ポアソン方程式のソルバー

    非圧縮性流体の圧力場を計算するためのソルバーです。
    各種の物理項（移流、粘性、外力）の発散から右辺を構築し、
    ポアソン方程式を解いて圧力場を得ます。
    """

    def __init__(self, solver_config: Optional[PoissonConfig] = None):
        """
        Args:
            solver_config: ポアソンソルバーの設定
        """
        # ポアソンソルバーの初期化
        self._poisson_solver = ConjugateGradientSolver(solver_config or PoissonConfig())

        # 物理項の初期化
        self._advection_term = AdvectionTerm()
        self._viscous_term = ViscousTerm()
        self._force_term = ForceTerm()

        # 診断情報の初期化
        self._diagnostics: Dict[str, Any] = {}

    def solve(
        self,
        velocity: VectorField,
        density: ScalarField,
        viscosity: ScalarField,
        external_force: Optional[VectorField] = None,
        **kwargs,
    ) -> Tuple[ScalarField, Dict[str, Any]]:
        """圧力ポアソン方程式を解く

        Args:
            velocity: 速度場
            density: 密度場
            viscosity: 粘性場
            external_force: 外力場（オプション）
            **kwargs: 追加のパラメータ

        Returns:
            (圧力場, 診断情報)のタプル
        """
        # 各物理項からの寄与を計算
        source_terms = self._compute_source_terms(
            velocity, density, viscosity, external_force
        )

        # 右辺の構築
        rhs = ScalarField(velocity.shape, velocity.dx)
        for term in source_terms.values():
            rhs.data = np.array(rhs.data) + np.array(term.data)

        # ポアソン方程式を解く
        pressure = ScalarField(velocity.shape, velocity.dx)
        pressure.data = self._poisson_solver.solve(np.array(rhs.data))

        # 診断情報の更新
        self._update_diagnostics(pressure, rhs, source_terms)

        return pressure, self._diagnostics

    def _compute_source_terms(
        self,
        velocity: VectorField,
        density: ScalarField,
        viscosity: ScalarField,
        external_force: Optional[VectorField],
    ) -> Dict[str, ScalarField]:
        """ポアソン方程式の右辺を構成する各項を計算"""
        source_terms = {}

        # 移流項の発散: -∇⋅(ρ(u⋅∇)u)
        advection = self._advection_term.compute(velocity=velocity)
        source_terms["advection"] = ScalarField(
            velocity.shape,
            velocity.dx,
        )

        # 粘性項の発散: ∇⋅(μ∇²u)
        viscous = self._viscous_term.compute(velocity=velocity, viscosity=viscosity)
        source_terms["viscous"] = ScalarField(
            velocity.shape,
            velocity.dx,
        )

        # 外力項の発散: ∇⋅f
        if external_force is not None:
            force = self._force_term.compute(
                shape=velocity.shape, dx=velocity.dx, external_force=external_force
            )
            source_terms["force"] = force

        return source_terms

    def _update_diagnostics(
        self,
        pressure: ScalarField,
        rhs: ScalarField,
        source_terms: Dict[str, ScalarField],
    ) -> None:
        """診断情報を更新

        Args:
            pressure: 計算された圧力場
            rhs: 右辺
            source_terms: 各物理項からの寄与
        """
        self._diagnostics = {
            "pressure": {
                "min": float(np.min(pressure.data)),
                "max": float(np.max(pressure.data)),
                "mean": float(np.mean(pressure.data)),
                "norm": float(np.linalg.norm(pressure.data)),
            },
            "source_terms": {
                name: {
                    "min": float(np.min(term.data)),
                    "max": float(np.max(term.data)),
                    "norm": float(np.linalg.norm(term.data)),
                }
                for name, term in source_terms.items()
            },
            "rhs": {
                "min": float(np.min(rhs.data)),
                "max": float(np.max(rhs.data)),
                "norm": float(np.linalg.norm(rhs.data)),
            },
        }

        # ポアソンソルバーの診断情報も追加
        if hasattr(self._poisson_solver, "get_diagnostics"):
            self._diagnostics["solver"] = self._poisson_solver.get_diagnostics()

```

### physics/pressure/terms/force.py

```
"""
外力項の計算を提供するモジュール

Navier-Stokes方程式における外力項 ∇⋅f を計算します。
"""

import numpy as np
from typing import Optional

from core.field import VectorField, ScalarField
from .base import PoissonTerm
from typing import Dict, Any


class ForceTerm(PoissonTerm):
    """外力項の計算クラス"""

    def __init__(self, name: str = "ExternalForce", enabled: bool = True):
        """
        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        super().__init__(name, enabled)

    def compute(
        self,
        shape: tuple,
        dx: np.ndarray,
        external_force: Optional[VectorField] = None,
        **kwargs,
    ) -> ScalarField:
        """
        外力項 ∇⋅f を計算

        Args:
            shape: 計算領域の形状
            dx: グリッド間隔（ベクトル）
            external_force: 外力場（オプション）

        Returns:
            外力項の発散を表すスカラー場
        """
        if not self.enabled or external_force is None:
            return ScalarField(shape[:-1], dx)  # VectorFieldの最後の次元を除外

        # 結果を格納するスカラー場
        result = ScalarField(shape[:-1], dx)
        
        # 空間次元数の取得（VectorFieldの最後の次元を除く）
        ndim = len(shape) - 1

        # 発散の計算: ∇⋅f = Σᵢ ∂fᵢ/∂xᵢ
        divergence = np.zeros(shape[:-1])
        for i in range(ndim):
            # i方向の力の成分についての勾配を計算
            div_i = np.gradient(external_force.components[i].data, dx[i], axis=i)
            divergence += div_i

        result.data = divergence

        # 診断情報の更新
        self._update_diagnostics(result, external_force)

        return result

    def _update_diagnostics(self, result: ScalarField, force: VectorField):
        """診断情報を更新

        Args:
            result: 計算された外力項
            force: 外力場
        """
        self._diagnostics = {
            "divergence": {
                "max": float(np.max(np.abs(result.data))),
                "min": float(np.min(result.data)),
                "mean": float(np.mean(result.data)),
                "norm": float(np.linalg.norm(result.data)),
            },
            "force_components": {
                f"component_{i}": {
                    "max": float(np.max(np.abs(comp.data))),
                    "min": float(np.min(comp.data)),
                }
                for i, comp in enumerate(force.components)
            },
        }

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(self._diagnostics)
        return diag
```

### physics/pressure/terms/base.py

```
"""
圧力ポアソン方程式の各項の基底クラスを提供するモジュール

このモジュールは、圧力ポアソン方程式を構成する各項（移流、粘性、外力）の
共通インターフェースと基本機能を定義します。
"""

from abc import ABC, abstractmethod
from typing import Dict, Any
from core.field import ScalarField


class PoissonTerm(ABC):
    """圧力ポアソン方程式の項の基底クラス"""

    def __init__(self, name: str = "BaseTerm", enabled: bool = True):
        """
        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        self._name = name
        self._enabled = enabled
        self._diagnostics: Dict[str, Any] = {}

    @property
    def name(self) -> str:
        """項の名前を取得"""
        return self._name

    @property
    def enabled(self) -> bool:
        """項が有効かどうかを取得"""
        return self._enabled

    @abstractmethod
    def compute(self, **kwargs) -> ScalarField:
        """
        項の寄与を計算する抽象メソッド

        Returns:
            項の寄与を表すScalarField
        """
        pass

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {"name": self.name, "enabled": self.enabled, **self._diagnostics}

```

### physics/pressure/terms/advection.py

```
"""
移流項（対流項）の計算を提供するモジュール

Navier-Stokes方程式における移流項 (u·∇)u の計算を実装します。
ScalarField/VectorFieldの演算子を活用して、
数学的な表現に近い形で実装を提供します。

数学的表現:
(u·∇)u_i = Σ_j (u_j ∂u_i/∂x_j)

ここで:
- u_j: j方向の速度成分
- ∂u_i/∂x_j: i成分のj方向への偏微分
"""

from typing import Dict, Any
import numpy as np

from core.field import VectorField
from .base import PoissonTerm


class AdvectionTerm(PoissonTerm):
    """移流項を計算するクラス"""

    def __init__(
        self,
        name: str = "Advection",
        enabled: bool = True,
        scheme: str = "central",
    ):
        """移流項計算器を初期化

        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
            scheme: 差分スキーム
        """
        super().__init__(name, enabled)
        self._scheme = scheme

    def compute(self, velocity: VectorField, **kwargs) -> VectorField:
        """移流項 -(u·∇)u を計算

        ScalarField/VectorFieldの演算子を活用して、
        数学的な表現に近い形で実装します。

        式: (u·∇)u_i = Σ_j (u_j ∂u_i/∂x_j)

        Args:
            velocity: 速度場
            **kwargs: 追加のパラメータ

        Returns:
            計算された移流項（VectorField）
        """
        if not self.enabled:
            return VectorField(velocity.shape[:-1], velocity.dx)

        # 計算結果を格納するベクトル場
        result = VectorField(velocity.shape[:-1], velocity.dx)

        # 速度成分の数を取得
        n_components = len(velocity.shape[:-1])  # VectorFieldの形状から最後の次元を除外

        # 各速度成分について (u·∇)u_i を計算
        for i in range(n_components):
            # 各方向の寄与を計算して合計
            advection = np.zeros(velocity.shape[:-1])
            for j in range(n_components):
                # u_j * ∂u_i/∂x_j を計算
                # データに直接アクセスして高速化
                velocity_j = velocity._data[..., j]
                grad_u_i = np.gradient(velocity._data[..., i], velocity.dx[j], axis=j)
                advection += velocity_j * grad_u_i

            # 結果を設定
            result._data[..., i] = advection

        # 診断情報の更新
        self._update_diagnostics(result)

        return result

    def _update_diagnostics(self, result: VectorField):
        """診断情報を更新

        Args:
            result: 計算された移流項
        """
        self._diagnostics = {
            "scheme": self._scheme,
            "max_magnitude": float(result.magnitude().max()),
            "component_max": {
                f"component_{i}": float(np.max(np.abs(result._data[..., i])))
                for i in range(result.shape[-1])
            },
        }

    def compute_timestep(self, velocity: VectorField, **kwargs) -> float:
        """移流による時間刻み幅の制限を計算

        CFL条件に基づいて、数値的に安定な時間刻み幅を計算します。
        Δt ≤ CFL * Δx / |u|_max

        Args:
            velocity: 速度場
            **kwargs: 追加のパラメータ（cflなど）

        Returns:
            計算された時間刻み幅の制限
        """
        if not self.enabled:
            return float("inf")

        # 最大速度を計算
        max_velocity = velocity.magnitude().max()

        # CFL条件に基づく時間刻み幅の計算
        cfl = kwargs.get("cfl", 0.5)
        return cfl * min(velocity.dx) / (max_velocity + 1e-10)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得

        Returns:
            診断情報を含む辞書
        """
        diag = super().get_diagnostics()
        diag.update(self._diagnostics)
        return diag

```

### physics/pressure/terms/viscous.py

```
"""
粘性項（拡散項）の計算を提供するモジュール

Navier-Stokes方程式における粘性項 ∇⋅(μ∇²u) を計算します。
"""

from typing import Dict, Any
import numpy as np

from core.field import VectorField, ScalarField
from .base import PoissonTerm


class ViscousTerm(PoissonTerm):
    """粘性項（拡散項）を計算するクラス"""

    def __init__(self, name: str = "Viscous", enabled: bool = True):
        """粘性項計算器を初期化

        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        super().__init__(name, enabled)

    def compute(
        self, velocity: VectorField, viscosity: ScalarField, **kwargs
    ) -> ScalarField:
        """粘性項 ∇⋅(μ∇²u) を計算

        Args:
            velocity: 速度場
            viscosity: 粘性係数場

        Returns:
            粘性項の発散
        """
        if not self.enabled:
            return ScalarField(velocity.shape[:-1], velocity.dx)

        # 結果を格納するスカラー場
        result = ScalarField(velocity.shape[:-1], velocity.dx)

        # 空間次元数の取得
        ndim = len(velocity.shape) - 1  # VectorFieldの形状から最後の次元を除外

        # 各速度成分についてラプラシアンを計算
        for i in range(ndim):
            laplacian = np.zeros_like(velocity.components[i].data)
            
            # 各方向の2階微分を計算
            for j in range(ndim):
                # ∂²u_i/∂x_j²
                laplacian += np.gradient(
                    np.gradient(
                        velocity.components[i].data, 
                        velocity.dx[j], 
                        axis=j
                    ),
                    velocity.dx[j],
                    axis=j
                )

            # 粘性を考慮した拡散項の発散を計算
            viscous_flux = viscosity.data * laplacian
            div_viscous = np.zeros_like(viscous_flux)
            
            # 各方向の勾配を合計
            for j in range(ndim):
                div_viscous += np.gradient(viscous_flux, velocity.dx[j], axis=j)
            
            # 結果に加算
            result.data += div_viscous

        return result

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "name": self.name,
            "enabled": self.enabled,
        }
```

### physics/pressure/terms/__init__.py

```
"""圧力ポアソン方程式の各項を提供するパッケージ"""

from .base import PoissonTerm
from .advection import AdvectionTerm
from .viscous import ViscousTerm
from .force import ForceTerm

__all__ = [
    "PoissonTerm",
    "AdvectionTerm",
    "ViscousTerm",
    "ForceTerm",
]

```

### physics/pressure/terms/pressure.py

```
"""
外力項の計算を提供するモジュール

Navier-Stokes方程式における外力項 ∇⋅f を計算します。
"""

import numpy as np
from typing import Optional

from core.field import VectorField, ScalarField
from .base import PoissonTerm
from typing import Dict, Any


class ForceTerm(PoissonTerm):
    """外力項の計算クラス"""

    def __init__(self, name: str = "ExternalForce", enabled: bool = True):
        """
        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        super().__init__(name, enabled)

    def compute(
        self,
        shape: tuple,
        dx: np.ndarray,
        external_force: Optional[VectorField] = None,
        **kwargs,
    ) -> ScalarField:
        """
        外力項 ∇⋅f を計算

        Args:
            shape: 計算領域の形状
            dx: グリッド間隔（ベクトル）
            external_force: 外力場（オプション）

        Returns:
            外力項の発散を表すスカラー場
        """
        if not self.enabled or external_force is None:
            return ScalarField(shape[:-1], dx)  # VectorFieldの最後の次元を除外

        # 結果を格納するスカラー場
        result = ScalarField(shape[:-1], dx)
        
        # 空間次元数の取得（VectorFieldの最後の次元を除く）
        ndim = len(shape) - 1

        # 発散の計算: ∇⋅f = Σᵢ ∂fᵢ/∂xᵢ
        divergence = np.zeros(shape[:-1])
        for i in range(ndim):
            # i方向の力の成分についての勾配を計算
            div_i = np.gradient(external_force.components[i].data, dx[i], axis=i)
            divergence += div_i

        result.data = divergence

        # 診断情報の更新
        self._update_diagnostics(result, external_force)

        return result

    def _update_diagnostics(self, result: ScalarField, force: VectorField):
        """診断情報を更新

        Args:
            result: 計算された外力項
            force: 外力場
        """
        self._diagnostics = {
            "divergence": {
                "max": float(np.max(np.abs(result.data))),
                "min": float(np.min(result.data)),
                "mean": float(np.mean(result.data)),
                "norm": float(np.linalg.norm(result.data)),
            },
            "force_components": {
                f"component_{i}": {
                    "max": float(np.max(np.abs(comp.data))),
                    "min": float(np.min(comp.data)),
                }
                for i, comp in enumerate(force.components)
            },
        }

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(self._diagnostics)
        return diag
```

### physics/pressure/__init__.py

```
"""圧力ポアソン方程式のソルバーパッケージ

このパッケージは、二相流体における圧力ポアソン方程式を解くためのソルバーを提供します。
主な機能：
- 密度が空間的に変化する場合の圧力場の計算
- 非圧縮性条件の維持
- 界面張力などの外力の考慮
"""

from .poisson import PressurePoissonSolver

__all__ = [
    "PressurePoissonSolver",
]

```

### physics/continuity/continuity.py

```
"""
連続の方程式（移流方程式）を解くためのモジュール

保存則の形式での移流方程式: ∂f/∂t + ∇⋅(uf) = 0
非保存形式での移流方程式: ∂f/∂t + u⋅∇f = 0

このモジュールは、任意のスカラー場の移流を計算し、時間発展を追跡します。
スカラー場は物質（レベルセット関数）や状態量（温度など）を表現できます。
"""

from typing import Dict, Any
import numpy as np

from core.field import VectorField, ScalarField


class ContinuityEquation:
    """
    連続の方程式（移流方程式）を解くためのクラス

    この実装は、スカラー場の移流を計算し、時間発展を追跡します。
    レベルセット関数、温度場、密度場など、様々なスカラー場の移流に使用できます。
    """

    def __init__(self, name: str = "Continuity"):
        """連続の方程式クラスを初期化

        Args:
            name: 方程式の名前（デフォルト: "Continuity"）
        """
        self.name = name

    def compute_derivative(
        self,
        field: ScalarField,
        velocity: VectorField,
    ) -> ScalarField:
        """
        スカラー場の時間微分を計算（非保存形式）

        速度場との内積演算を活用して、∂f/∂t = -u⋅∇f を計算します。

        Args:
            field: 移流される任意のスカラー場
            velocity: 速度場

        Returns:
            スカラー場の時間微分をScalarFieldとして返す
        """
        result = ScalarField(field.shape, field.dx)
        result.data = -(velocity * field.gradient()).data
        return result

    def compute_derivative_conservative(
        self,
        field: ScalarField,
        velocity: VectorField,
    ) -> ScalarField:
        """
        スカラー場の時間微分を計算（保存形式）

        フラックスの発散として、∂f/∂t = -∇⋅(uf) を計算します。

        Args:
            field: 移流される任意のスカラー場
            velocity: 速度場

        Returns:
            スカラー場の時間微分をScalarFieldとして返す
        """
        result = ScalarField(field.shape, field.dx)
        flux = velocity * field
        result.data = -flux.divergence().data
        return result

    def compute_timestep(
        self, velocity: VectorField, field: ScalarField, **kwargs
    ) -> float:
        """
        移流のための時間刻み幅を計算

        CFL条件に基づいて安定な時間刻み幅を計算します。
        dt ≤ CFL * dx / max(|u|)

        Args:
            velocity: 速度場
            field: スカラー場
            **kwargs: 追加のパラメータ（cfl係数など）

        Returns:
            計算された時間刻み幅
        """
        # CFLベースの時間刻み幅計算
        cfl = kwargs.get("cfl", 0.5)

        # 各方向の最大速度を計算
        max_velocity = max(np.max(np.abs(comp.data)) for comp in velocity.components)

        # CFL条件に基づく時間刻み幅の計算
        if max_velocity > 0:
            dt = cfl * field.dx / max_velocity
        else:
            dt = float("inf")

        return dt

    def get_diagnostics(
        self, field: ScalarField, velocity: VectorField
    ) -> Dict[str, Any]:
        """
        診断情報を取得

        Args:
            field: スカラー場
            velocity: 速度場

        Returns:
            診断情報の辞書
        """
        # 移流速度の特性を計算
        velocity_info = {
            f"max_velocity_{dim}": float(np.max(np.abs(comp.data)))
            for dim, comp in zip(["x", "y", "z"], velocity.components)
        }

        # スカラー場の統計情報
        field_info = {
            "mean": float(np.mean(field.data)),
            "max": float(np.max(field.data)),
            "min": float(np.min(field.data)),
            "std": float(np.std(field.data)),
        }

        return {
            "name": self.name,
            "scheme": "central_difference",
            "velocities": velocity_info,
            "field": field_info,
            "grid_spacing": field.dx,
        }

```

### physics/continuity/__init__.py

```
"""
連続の方程式モジュールのパッケージ初期化

このパッケージは、流体力学における連続の方程式を実装します。
"""

from .continuity import ContinuityEquation

__all__ = [
    "ContinuityEquation",
]

```

### physics/multiphase/interface.py

```
"""多相流体の界面計算機能を提供するモジュール（改良版）

このモジュールは、多相流体における界面の初期化、再構築、幾何計算、
相識別などの機能を統合的に提供します。新しい演算子とメソッドを活用して
実装を改善しています。
"""

from typing import Tuple, List, Dict, Any
import numpy as np

from core.field import ScalarField, VectorField
from .operators.initialization import InitializationOperator
from .operators.reinitialization import ReinitializationOperator
from .operators.geometry import GeometryOperator
from .operators.indicator import IndicatorOperator


class InterfaceOperations:
    """多相流体の界面計算機能を提供するクラス（改良版）"""

    def __init__(self, dx: np.ndarray, epsilon: float = 1.0e-6):
        """界面計算機能を初期化

        Args:
            dx: グリッド間隔（ベクトル）
            epsilon: 数値計算の安定化パラメータ
        """
        self.dx = dx
        self.epsilon = epsilon

        # 各演算子の初期化
        self._init_op = InitializationOperator(dx)
        self._reinit_op = ReinitializationOperator(dx, epsilon)
        self._geom_op = GeometryOperator(dx, epsilon)
        self._indicator_op = IndicatorOperator(epsilon)

    def create_sphere(
        self, shape: Tuple[int, ...], center: List[float], radius: float
    ) -> ScalarField:
        """球形の界面を生成（新しい演算子を活用）"""
        return self._init_op.create_sphere(shape, center, radius)

    def create_plane(
        self, shape: Tuple[int, ...], normal: List[float], point: List[float]
    ) -> ScalarField:
        """平面界面を生成（新しい演算子を活用）"""
        # 座標場の生成
        coords = np.meshgrid(*[np.linspace(0, 1, s) for s in shape], indexing="ij")

        # ベクトル演算を活用した効率的な実装
        normal = np.array(normal) / np.linalg.norm(normal)
        displacement = [x - p for x, p in zip(coords, point)]
        return ScalarField(
            shape,
            self.dx,
            initial_value=sum(n * d for n, d in zip(normal, displacement)),
        )

    def compute_normal(self, phi: ScalarField) -> VectorField:
        """法線ベクトルを計算（新しい演算子を活用）"""
        # 勾配の計算と正規化
        grad = phi.gradient()
        grad_norm = grad.magnitude()
        # 新しい除算演算子を使用
        return grad / (grad_norm + self.epsilon)

    def compute_curvature(
        self, phi: ScalarField, high_order: bool = False
    ) -> ScalarField:
        """曲率を計算（新しい演算子を活用）"""
        method = "high_order" if high_order else "standard"
        return self._geom_op.compute_curvature(phi, method)

    def combine_interfaces(
        self, phi1: ScalarField, phi2: ScalarField, operation: str = "union"
    ) -> ScalarField:
        """界面を組み合わせて新しい形状を生成（新しい演算子を活用）"""
        # 同じ形状チェック
        if phi1.shape != phi2.shape:
            raise ValueError("スカラー場の形状が一致しません")

        result = ScalarField(phi1.shape, self.dx)

        if operation == "union":
            # minimum演算子を使用
            result.data = np.minimum(phi1.data, phi2.data)
        elif operation == "intersection":
            # maximum演算子を使用
            result.data = np.maximum(phi1.data, phi2.data)
        elif operation == "difference":
            # 新しい演算子を使用
            result.data = np.maximum(phi1.data, -phi2.data)
        else:
            raise ValueError(f"未知の操作: {operation}")

        return result

    def get_phase_distribution(self, phi: ScalarField) -> ScalarField:
        """相分布を計算（新しい演算子を活用）"""
        return self._indicator_op.compute_heaviside(phi)

    def get_interface_delta(self, phi: ScalarField) -> ScalarField:
        """界面のデルタ関数を計算（新しい演算子を活用）"""
        return self._indicator_op.compute_delta(phi)

    def get_property_field(
        self, phi: ScalarField, value1: float, value2: float
    ) -> ScalarField:
        """物性値の空間分布を計算（新しい演算子を活用）"""
        return self._indicator_op.get_phase_field(phi, value1, value2)

    def _compute_interface_curvature_stats(
        self, kappa: ScalarField, interface_region: np.ndarray
    ) -> Dict[str, float]:
        """界面上の曲率統計を計算（新しいメソッドを活用）"""
        if not np.any(interface_region):
            return {"min": 0.0, "max": 0.0, "mean": 0.0, "rms": 0.0}

        kappa_interface = kappa.data[interface_region]
        return {
            "min": float(np.min(kappa_interface)),
            "max": float(np.max(kappa_interface)),
            "mean": float(np.mean(kappa_interface)),
            "rms": float(np.sqrt(np.mean(kappa_interface**2))),
        }

    def get_diagnostics(self, phi: ScalarField) -> Dict[str, Any]:
        """界面に関する診断情報を取得（新しいメソッドを活用）"""
        # 相分布とデルタ関数の計算
        phase = self.get_phase_distribution(phi)
        delta = self.get_interface_delta(phi)

        # 距離関数の性質の検証
        distance_error = self._reinit_op.validate(phi)

        # 界面の曲率を計算
        kappa = self.compute_curvature(phi, high_order=False)

        # グリッド体積要素の計算
        dv = np.prod(self.dx)

        # 界面近傍の点の識別（新しいメソッドを活用）
        interface_region = np.abs(phi.data) < (5.0 * min(self.dx))

        # 界面上の曲率統計の計算
        curvature_stats = self._compute_interface_curvature_stats(
            kappa, interface_region
        )

        return {
            "volume_fraction": float(phase.mean()),
            "interface_points": int(interface_region.sum()),
            "interface_area": float((delta.data * dv).sum()),
            "distance_error": distance_error,
            "curvature": curvature_stats,
        }

    def compute_interface_measures(self, phi: ScalarField) -> Dict[str, float]:
        """界面の各種測度を計算（新しいメソッドを活用）"""
        # 相分布とデルタ関数の計算
        phase = self.get_phase_distribution(phi)
        delta = self.get_interface_delta(phi)

        # グリッド体積要素の計算
        dv = np.prod(self.dx)

        # 体積の計算（新しい積分メソッドを使用）
        volume = float(phase.integrate())

        # 界面測度の計算
        interface_measure = float(delta.integrate())

        return {
            "volume": volume,
            "area": interface_measure if phi.ndim == 3 else None,
            "length": interface_measure if phi.ndim == 2 else None,
            "perimeter": interface_measure if phi.ndim == 3 else None,
        }

    def reinitialize(
        self, phi: ScalarField, n_steps: int = 5, dt: float = 0.1
    ) -> ScalarField:
        """距離関数の性質を回復（新しいメソッドを活用）"""
        return self._reinit_op.execute(phi, n_steps, dt)

    def validate_distance(self, phi: ScalarField) -> float:
        """距離関数の性質を検証（新しいメソッドを活用）"""
        return self._reinit_op.validate(phi)

```

### physics/multiphase/operators/initialization.py

```
"""界面の初期化を提供するモジュール

このモジュールは、多相流体計算における界面の初期形状を
生成するための機能を提供します。
"""

from typing import Tuple, List
import numpy as np

from core.field import ScalarField


class InitializationOperator:
    """界面の初期化を実行するクラス"""

    def __init__(self, dx: np.ndarray):
        """初期化演算子を初期化

        Args:
            dx: グリッド間隔（ベクトル）
        """
        self.dx = dx

    def create_sphere(
        self, shape: Tuple[int, ...], center: List[float], radius: float
    ) -> ScalarField:
        """球形の界面を生成

        Args:
            shape: グリッドの形状
            center: 球の中心座標（0-1で正規化）
            radius: 球の半径（0-1で正規化）

        Returns:
            界面からの符号付き距離を表すスカラー場
        """
        result = ScalarField(shape, self.dx)

        # 座標グリッドの生成
        coords = np.meshgrid(*[np.linspace(0, 1, s) for s in shape], indexing="ij")

        # 中心からの距離を計算（各方向のスケーリングを考慮）
        squared_distance = sum(
            ((x - c) / d) ** 2 for x, c, d in zip(coords, center, np.ones_like(self.dx))
        )
        distance = np.sqrt(squared_distance)

        # 符号付き距離関数として設定
        result.data = distance - radius
        return result

    def create_plane(
        self, shape: Tuple[int, ...], normal: List[float], point: List[float]
    ) -> ScalarField:
        """平面界面を生成

        Args:
            shape: グリッドの形状
            normal: 平面の法線ベクトル
            point: 平面上の1点の座標（0-1で正規化）

        Returns:
            界面からの符号付き距離を表すスカラー場
        """
        result = ScalarField(shape, self.dx)

        # 座標グリッドの生成
        coords = np.meshgrid(*[np.linspace(0, 1, s) for s in shape], indexing="ij")

        # 法線ベクトルの正規化（グリッド間隔を考慮）
        normal = np.array(normal)
        normal = normal / np.sqrt(np.sum((normal / self.dx) ** 2))

        # 平面からの符号付き距離を計算（各方向のスケーリングを考慮）
        distance = sum(
            n * (x - p) / d
            for x, p, n, d in zip(coords, point, normal, np.ones_like(self.dx))
        )

        result.data = distance
        return result

    def create_composite(
        self, phi1: ScalarField, phi2: ScalarField, operation: str = "union"
    ) -> ScalarField:
        """複数の界面を組み合わせて新しい形状を生成

        Args:
            phi1: 1つ目の距離関数
            phi2: 2つ目の距離関数
            operation: 組み合わせ操作（"union", "intersection", "difference"）

        Returns:
            新しい距離関数
        """
        if phi1.shape != phi2.shape:
            raise ValueError("スカラー場の形状が一致しません")

        result = ScalarField(phi1.shape, self.dx)

        if operation == "union":
            # 和集合: min(φ1, φ2)
            result.data = np.minimum(phi1.data, phi2.data)
        elif operation == "intersection":
            # 積集合: max(φ1, φ2)
            result.data = np.maximum(phi1.data, phi2.data)
        elif operation == "difference":
            # 差集合: max(φ1, -φ2)
            result.data = np.maximum(phi1.data, -phi2.data)
        else:
            raise ValueError(f"未知の操作: {operation}")

        return result

```

### physics/multiphase/operators/indicator.py

```
"""相識別関数を提供するモジュール

このモジュールは、界面を通じた相の分布を表現するための
Heaviside関数とDelta関数を実装します。
"""

import numpy as np
from core.field import ScalarField


class IndicatorOperator:
    """相識別関数を計算するクラス"""

    def __init__(self, epsilon: float = 1.0e-2):
        """相識別演算子を初期化

        Args:
            epsilon: 界面の厚さパラメータ
        """
        self.epsilon = epsilon

    def compute_heaviside(self, phi: ScalarField) -> ScalarField:
        """Heaviside関数を計算: H(φ)

        Args:
            phi: 距離関数

        Returns:
            正則化されたHeaviside関数
        """
        result = ScalarField(phi.shape, phi.dx)
        # tanh関数を用いた正則化
        result.data = 0.5 * (1.0 + np.tanh(phi.data / self.epsilon))
        return result

    def compute_delta(self, phi: ScalarField) -> ScalarField:
        """Delta関数を計算: δ(φ)

        Args:
            phi: 距離関数

        Returns:
            正則化されたDelta関数
        """
        result = ScalarField(phi.shape, phi.dx)
        # Heaviside関数の導関数として計算
        result.data = 0.5 / self.epsilon * (1.0 - np.tanh(phi.data / self.epsilon) ** 2)
        return result

    def get_phase_field(
        self, phi: ScalarField, value1: float, value2: float
    ) -> ScalarField:
        """物性値の分布を計算: f = f₁H(φ) + f₂(1-H(φ))

        Args:
            phi: 距離関数
            value1: 第1相の物性値
            value2: 第2相の物性値

        Returns:
            物性値の分布
        """
        result = ScalarField(phi.shape, phi.dx)
        h = self.compute_heaviside(phi)
        result.data = value1 * h.data + value2 * (1.0 - h.data)
        return result

    def get_interface_measure(self, phi: ScalarField) -> float:
        """界面の面積/長さを計算

        Args:
            phi: 距離関数

        Returns:
            界面の面積（3D）または長さ（2D）
        """
        delta = self.compute_delta(phi)
        # グリッド体積要素を計算（非等方グリッドに対応）
        dv = np.prod(phi.dx)
        return float(np.sum(delta.data) * dv)

```

### physics/multiphase/operators/reinitialization.py

```
"""界面の再構築を提供するモジュール

このモジュールは、界面の位置を保持したまま符号付き距離関数の
性質を回復する再構築機能を提供します。
"""

import numpy as np
from scipy.ndimage import gaussian_filter

from core.field import ScalarField


class ReinitializationOperator:
    """距離関数の再構築を実行するクラス"""

    def __init__(self, dx: np.ndarray, epsilon: float = 1.0e-6):
        """再構築演算子を初期化

        Args:
            dx: グリッド間隔（ベクトル）
            epsilon: 数値計算の安定化パラメータ
        """
        self.dx = dx
        self.epsilon = epsilon
        # 最小のグリッド間隔を計算
        self.min_dx = np.min(dx)

    def execute(
        self, phi: ScalarField, n_steps: int = 5, dt: float = 0.1
    ) -> ScalarField:
        """距離関数の性質を回復

        高速行進法を用いて以下の発展方程式を解きます：
        ∂φ/∂τ = sign(φ₀)(1 - |∇φ|)

        Args:
            phi: 入力スカラー場
            n_steps: 反復回数
            dt: 疑似時間の時間刻み幅

        Returns:
            再構築されたスカラー場
        """
        # 結果の初期化
        result = phi.copy()
        sign = np.sign(result.data)

        # 高速行進法による再構築
        for _ in range(n_steps):
            # 勾配を計算
            grad = np.array([result.gradient(i) for i in range(result.ndim)])
            grad_norm = np.sqrt(np.sum(grad**2, axis=0))
            grad_norm = np.maximum(grad_norm, self.epsilon)  # 安定化

            # 時間発展
            correction = sign * (grad_norm - 1.0)
            result.data -= dt * correction

            # 数値的安定化のためにガウシアンフィルタを適用
            result.data = gaussian_filter(result.data, sigma=0.5 * self.min_dx)

        return result

    def validate(self, phi: ScalarField) -> float:
        """距離関数の性質を検証

        |∇φ| = 1 からのずれを計算します。

        Args:
            phi: 検証するスカラー場

        Returns:
            勾配ノルムの1からの平均二乗偏差
        """
        # 勾配ノルムの計算
        grad = np.array([phi.gradient(i) for i in range(phi.ndim)])
        grad_norm = np.sqrt(np.sum(grad**2, axis=0))

        # 界面近傍での |∇φ| = 1 からのずれを計算
        # 最小グリッド間隔の5倍を界面幅として使用
        interface_width = 5.0 * self.min_dx
        interface_region = np.abs(phi.data) < interface_width

        if np.any(interface_region):
            deviation = np.mean((grad_norm[interface_region] - 1.0) ** 2)
            return float(deviation)
        return 0.0

    def _compute_stable_sign(self, phi: ScalarField, width: float = 5.0) -> np.ndarray:
        """安定化された符号関数を計算

        Args:
            phi: スカラー場
            width: 遷移領域の幅（グリッド間隔の倍数）

        Returns:
            安定化された符号関数の値
        """
        transition_width = width * self.min_dx
        return phi.data / np.sqrt(phi.data**2 + transition_width**2)

```

### physics/multiphase/operators/__init__.py

```
"""多相流体計算の基本演算子パッケージ

このパッケージは、多相流体計算に必要な基本演算子を提供します。
"""

from .initialization import InitializationOperator
from .reinitialization import ReinitializationOperator
from .geometry import GeometryOperator
from .indicator import IndicatorOperator

__all__ = [
    "InitializationOperator",
    "ReinitializationOperator",
    "GeometryOperator",
    "IndicatorOperator",
]

```

### physics/multiphase/operators/geometry.py

```
"""界面の幾何学的演算を提供するモジュール

法線ベクトルや曲率などの幾何学的量の計算を実装します。
"""

import numpy as np
from core.field import VectorField, ScalarField


class GeometryOperator:
    """界面の幾何学的演算を実行するクラス"""

    def __init__(self, dx: np.ndarray, epsilon: float = 1.0e-6):
        """幾何演算子を初期化

        Args:
            dx: グリッド間隔（ベクトル）
            epsilon: 数値計算の安定化パラメータ
        """
        self.dx = dx
        self.epsilon = epsilon

    def compute_normal(self, phi: ScalarField) -> VectorField:
        """法線ベクトルを計算: n = ∇φ/|∇φ|

        Args:
            phi: 距離関数

        Returns:
            法線ベクトル場
        """
        # 勾配の計算
        grad_components = [phi.gradient(i) for i in range(phi.ndim)]

        # 勾配ノルムの計算
        grad_norm = np.sqrt(sum(g * g for g in grad_components))
        grad_norm = np.maximum(grad_norm, self.epsilon)

        # 法線ベクトル場の構築
        normal = VectorField(phi.shape, self.dx)
        for i in range(phi.ndim):
            normal.components[i] = ScalarField(
                phi.shape, self.dx, initial_value=grad_components[i] / grad_norm
            )

        return normal

    def compute_curvature(
        self, phi: ScalarField, method: str = "standard"
    ) -> ScalarField:
        """曲率を計算: κ = ∇⋅n = ∇⋅(∇φ/|∇φ|)

        Args:
            phi: 距離関数
            method: 計算手法 ('standard' または 'high_order')

        Returns:
            曲率場
        """
        if method == "standard":
            return self._compute_standard_curvature(phi)
        elif method == "high_order":
            return self._compute_high_order_curvature(phi)
        else:
            raise ValueError(f"未知の計算手法: {method}")

    def _compute_standard_curvature(self, phi: ScalarField) -> ScalarField:
        """2次精度の標準的な曲率計算"""
        # 勾配と勾配ノルムの計算
        grad_components = [phi.gradient(i) for i in range(phi.ndim)]
        grad_norm = np.sqrt(sum(g * g for g in grad_components))
        grad_norm = np.maximum(grad_norm, self.epsilon)

        # 法線ベクトルの発散を計算
        result = ScalarField(phi.shape, self.dx)
        for i in range(phi.ndim):
            normalized_grad = grad_components[i] / grad_norm
            # 各方向の勾配を個別に計算
            result.data += np.gradient(normalized_grad, self.dx[i], axis=i)

        return result

    def _compute_high_order_curvature(self, phi: ScalarField) -> ScalarField:
        """4次精度の高精度曲率計算"""
        result = ScalarField(phi.shape, self.dx)
        ndim = phi.ndim

        for i in range(ndim):
            for j in range(ndim):
                if i == j:
                    # 対角項の4次精度差分
                    d2 = self._compute_4th_order_derivative(phi, i, i)
                else:
                    # 交差微分項の4次精度差分
                    d2 = self._compute_4th_order_cross_derivative(phi, i, j)

                result.data += d2

        return result

    def _compute_4th_order_derivative(
        self, phi: ScalarField, i: int, j: int
    ) -> np.ndarray:
        """4次精度の2階微分を計算"""
        data = phi.data
        dx = self.dx[i]  # 対応する方向のグリッド間隔を使用

        # 4次精度の係数
        c = [-1 / 12, 4 / 3, -5 / 2, 4 / 3, -1 / 12]

        # 2階微分の計算
        result = np.zeros_like(data)
        for k in range(5):
            shifted = np.roll(data, k - 2, axis=i)
            result += c[k] * shifted

        return result / (dx * dx)

    def _compute_4th_order_cross_derivative(
        self, phi: ScalarField, i: int, j: int
    ) -> np.ndarray:
        """4次精度の交差微分を計算"""
        data = phi.data
        dx_i = self.dx[i]  # i方向のグリッド間隔
        dx_j = self.dx[j]  # j方向のグリッド間隔

        # まず i 方向の1階微分を計算
        di = np.zeros_like(data)
        for k in range(-2, 3):
            shifted = np.roll(data, k, axis=i)
            di += (-1 / 12 if abs(k) == 2 else 2 / 3 if abs(k) == 1 else 0) * shifted
        di /= dx_i

        # 次に j 方向の1階微分を計算
        result = np.zeros_like(data)
        for k in range(-2, 3):
            shifted = np.roll(di, k, axis=j)
            result += (
                -1 / 12 if abs(k) == 2 else 2 / 3 if abs(k) == 1 else 0
            ) * shifted
        result /= dx_j

        return result

```

### physics/multiphase/__init__.py

```
"""多相流体計算パッケージ

このパッケージは、多相流体計算に必要な機能を提供します。
Level Set法による界面追跡やVOF法による界面捕獲など、
様々な手法に対応可能な汎用的なインターフェースを提供します。
"""

from .interface import InterfaceOperations

__all__ = ["InterfaceOperations"]

# パッケージのバージョン情報
__version__ = "1.0.0"

```

### physics/navier_stokes/solver.py

```
"""
二相流のためのNavier-Stokes方程式ソルバー

Navier-Stokes方程式の理論的導出と数値解法の詳細

1. 連続の方程式（質量保存則）
   微分形: ∂ρ/∂t + ∇⋅(ρu) = 0

2. 運動量保存則（基本形）
   ∂(ρu)/∂t + ∇⋅(ρuu) = -∇p + ∇⋅(μ(∇u + ∇uT)) + f

方程式の詳細な数学的展開:

I. 連続の方程式の展開
   1) ρの実質微分: Dρ/Dt = ∂ρ/∂t + u⋅∇ρ
   2) 連続の方程式の変形:
      ∂ρ/∂t + u⋅∇ρ + ρ∇⋅u = 0

II. 運動量保存則の詳細な導出
    1) 初期形: ∂(ρu)/∂t + ∇⋅(ρuu) = -∇p + ∇⋅(μ(∇u + ∇uT)) + f

    2) 各項の展開:
       a) 左辺第1項: ∂(ρu)/∂t
          = ρ∂u/∂t + u∂ρ/∂t

       b) 左辺第2項: ∇⋅(ρuu)
          = ρ(u⋅∇)u + u(u⋅∇ρ)

    3) 最終的な方程式形:
       ρ∂u/∂t + ρ(u⋅∇)u + u(u⋅∇ρ) = -∇p + ∇⋅(μ(∇u + ∇uT)) + f

    4) 速度の時間微分の形に変形:
       ∂u/∂t = -1/ρ (u⋅∇)u - 1/ρ u(u⋅∇ρ) - 1/ρ ∇p + 1/ρ ∇⋅(μ(∇u + ∇uT)) + 1/ρ f

数値解法の特徴:
1. 各項の物理的意味
   - 移流項 (-1/ρ (u⋅∇)u): 速度場の非線形な自己移流
   - 密度勾配項 (-1/ρ u(u⋅∇ρ)): 密度の空間変化による加速
   - 圧力項 (-1/ρ ∇p): 圧力勾配による運動
   - 粘性項 (1/ρ ∇⋅(μ(∇u + ∇uT))): 粘性による運動量拡散
   - 外力項 (1/ρ f): 重力や他の外部力

2. 数値スキームの仮定
   - 非圧縮性流体
   - 層流regime
   - 密度と粘性の空間的変化を許容
   - 外部力の一般的な取り扱い

実装上の注意:
- 高レイノルズ数流れでは追加のモデリングが必要
- 乱流効果は陽には考慮されていない
- 数値的安定性のため、各項の慎重な離散化が必要

数値的課題:
1. 移流項の非線形性
2. 密度と粘性の不連続性
3. 圧力-速度の結合
4. 界面での物理量の扱い

"""

from typing import Optional, Dict, Any

from core.field import VectorField, ScalarField
from .terms import (
    AdvectionTerm,
    DiffusionTerm,
    PressureTerm,
    AccelerationTerm,
)


class NavierStokesSolver:
    """Navier-Stokes方程式のソルバー（改良版）"""

    def __init__(self):
        """ソルバーを初期化"""
        self.advection_term = AdvectionTerm()
        self.diffusion_term = DiffusionTerm()
        self.pressure_term = PressureTerm()
        self.acceleration_term = AccelerationTerm()
        self._diagnostics: Dict[str, Any] = {}

    def compute(
        self,
        velocity: VectorField,
        density: ScalarField,
        viscosity: ScalarField,
        pressure: ScalarField,
        force: Optional[VectorField] = None,
        **kwargs,
    ) -> VectorField:
        """
        速度の時間微分を計算（新しい演算子を活用）

        Args:
            velocity: 速度場
            density: 密度場
            viscosity: 粘性場
            pressure: 圧力場
            force: 外力場（オプション）

        Returns:
            速度の時間微分をVectorFieldとして返す
        """
        # デフォルトの外力場を初期化
        if force is None:
            force = VectorField(velocity.shape, velocity.dx)

        # 各項を新しい演算子を使用して計算
        advection = self.advection_term.compute(velocity)
        density_gradient = self.acceleration_term.compute(velocity, density)
        diffusion = self.diffusion_term.compute(velocity, viscosity)
        pressure_grad = self.pressure_term.compute(velocity, pressure, density)

        # 密度の逆数を計算（ゼロ除算を防止）
        inv_density = 1.0 / (density + ScalarField(density.shape, density.dx, 1e-10))

        # 時間微分の計算（新しい演算子を活用）
        result = (
            -advection  # 移流項
            + density_gradient  # 密度勾配項
            + diffusion  # 粘性項
            - pressure_grad  # 圧力項
            + force * inv_density  # 外力項
        )

        # 診断情報の更新
        self._update_diagnostics(
            advection=advection,
            density_gradient=density_gradient,
            diffusion=diffusion,
            pressure_grad=pressure_grad,
            force=force,
            result=result,
        )

        return result

    def _update_diagnostics(self, **fields: VectorField):
        """診断情報を更新（新しいメソッドを活用）"""
        self._diagnostics = {
            name: {
                "max_magnitude": float(field.magnitude().max()),
                "min_magnitude": float(field.magnitude().min()),
                "mean_magnitude": float(field.magnitude().mean()),
                "component_norms": [float(comp.norm()) for comp in field.components],
            }
            for name, field in fields.items()
        }

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return self._diagnostics.copy()

```

### physics/navier_stokes/terms/base.py

```
"""
Navier-Stokes方程式の項の基底クラスを提供するモジュール

各項（移流、拡散、圧力、加速度など）の共通インターフェースを定義します。
"""

from abc import ABC, abstractmethod
from typing import Dict, Any
from core.field import VectorField


class BaseNavierStokesTerm(ABC):
    """
    Navier-Stokes方程式の各項の基底抽象クラス

    すべての項に共通の基本機能と、必要なインターフェースを提供します。
    """

    def __init__(self, name: str = "BaseTerm", enabled: bool = True):
        """
        基底クラスの初期化

        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        self._name = name
        self._enabled = enabled
        # 診断情報用の辞書
        self._diagnostics: Dict[str, Any] = {}

    @property
    def name(self) -> str:
        """項の名前を取得"""
        return self._name

    @property
    def enabled(self) -> bool:
        """項が有効かどうかを取得"""
        return self._enabled

    @abstractmethod
    def compute(self, velocity: VectorField, **kwargs) -> VectorField:
        """
        項の寄与を計算する抽象メソッド

        Args:
            velocity: 速度場
            **kwargs: 追加のパラメータ

        Returns:
            計算された項の寄与をVectorFieldとして返す
        """
        pass

    def compute_timestep(self, velocity: VectorField, **kwargs) -> float:
        """
        項に基づく時間刻み幅の制限を計算するデフォルトメソッド

        Args:
            velocity: 速度場
            **kwargs: 追加のパラメータ

        Returns:
            計算された時間刻み幅の制限
        """
        return float("inf")

    def get_diagnostics(self) -> Dict[str, Any]:
        """
        診断情報を取得

        Returns:
            項の診断情報を含む辞書
        """
        base_diagnostics = {
            "name": self.name,
            "enabled": self.enabled,
        }
        base_diagnostics.update(self._diagnostics)
        return base_diagnostics

```

### physics/navier_stokes/terms/advection.py

```
"""
移流項（対流項）の計算を提供するモジュール

Navier-Stokes方程式における移流項 (u·∇)u の計算を実装します。
ScalarField/VectorFieldの演算子を活用して、
数学的な表現に近い形で実装を提供します。

数学的表現:
(u·∇)u_i = Σ_j (u_j ∂u_i/∂x_j)

ここで:
- u_j: j方向の速度成分
- ∂u_i/∂x_j: i成分のj方向への偏微分
"""

from typing import Dict, Any
import numpy as np

from core.field import VectorField
from .base import BaseNavierStokesTerm


class AdvectionTerm(BaseNavierStokesTerm):
    """移流項を計算するクラス"""

    def __init__(
        self,
        name: str = "Advection",
        enabled: bool = True,
        scheme: str = "central",
    ):
        """移流項計算器を初期化

        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
            scheme: 差分スキーム
        """
        super().__init__(name, enabled)
        self._scheme = scheme

    def compute(self, velocity: VectorField, **kwargs) -> VectorField:
        """移流項 -(u·∇)u を計算

        Args:
            velocity: 速度場
            **kwargs: 追加のパラメータ

        Returns:
            計算された移流項（VectorField）
        """
        if not self.enabled:
            return VectorField(velocity.shape[:-1], velocity.dx)

        # 計算結果を格納するベクトル場
        result = VectorField(velocity.shape[:-1], velocity.dx)

        # 速度成分の数を取得
        n_components = len(velocity.shape[:-1])  # VectorFieldの形状から最後の次元を除外

        # 各速度成分について -(u·∇)u_i を計算
        for i in range(n_components):
            # 各方向の寄与を計算して合計
            advection = np.zeros(velocity.shape[:-1])
            for j in range(n_components):
                # u_j * ∂u_i/∂x_j を計算
                # データに直接アクセスして高速化
                velocity_j = velocity._data[..., j]
                grad_u_i = np.gradient(velocity._data[..., i], velocity.dx[j], axis=j)
                advection += velocity_j * grad_u_i

            # 結果を設定（負符号に注意）
            result._data[
                ..., i
            ] = -advection  # 移流項は運動方程式の左辺に移項されるため負符号

        # 診断情報の更新
        self._update_diagnostics(result)

        return result

    def _update_diagnostics(self, result: VectorField):
        """診断情報を更新

        Args:
            result: 計算された移流項
        """
        self._diagnostics = {
            "scheme": self._scheme,
            "max_magnitude": float(result.magnitude().max()),
            "component_max": {
                f"component_{i}": float(np.max(np.abs(result._data[..., i])))
                for i in range(result.shape[-1])
            },
        }

    def compute_timestep(self, velocity: VectorField, **kwargs) -> float:
        """移流による時間刻み幅の制限を計算

        CFL条件に基づいて、数値的に安定な時間刻み幅を計算します。
        Δt ≤ CFL * Δx / |u|_max

        Args:
            velocity: 速度場
            **kwargs: 追加のパラメータ（cflなど）

        Returns:
            計算された時間刻み幅の制限
        """
        if not self.enabled:
            return float("inf")

        # 最大速度を計算
        max_velocity = velocity.magnitude().max()

        # CFL条件に基づく時間刻み幅の計算
        cfl = kwargs.get("cfl", 0.5)
        return cfl * min(velocity.dx) / (max_velocity + 1e-10)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(self._diagnostics)
        return diag

```

### physics/navier_stokes/terms/acceleration.py

```
"""
密度勾配による加速度項を計算するモジュール

密度の空間的な変化による加速度項 -1/ρ u(u⋅∇ρ) を計算します。
"""

from typing import Dict, Any
import numpy as np

from core.field import VectorField, ScalarField
from .base import BaseNavierStokesTerm


class AccelerationTerm(BaseNavierStokesTerm):
    """
    密度勾配による加速度項を計算するクラス

    計算される項: -1/ρ u(u⋅∇ρ)
    """

    def __init__(
        self,
        name: str = "DensityGradientAcceleration",
        enabled: bool = True,
    ):
        """
        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        super().__init__(name, enabled)

    def compute(
        self, velocity: VectorField, density: ScalarField, **kwargs
    ) -> VectorField:
        """
        密度勾配による加速度項を計算

        Args:
            velocity: 速度場
            density: 密度場

        Returns:
            加速度項をVectorFieldとして返す
        """
        if not self.enabled:
            return VectorField(velocity.shape, velocity.dx)

        # 密度勾配の計算
        density_grad = [
            ScalarField(velocity.shape, velocity.dx, density.gradient(i))
            for i in range(velocity.ndim)
        ]

        # 速度と密度勾配の内積 (u⋅∇ρ)
        density_advection = ScalarField(velocity.shape, velocity.dx)
        for u_comp, grad_comp in zip(velocity.components, density_grad):
            density_advection = density_advection + (u_comp * grad_comp)

        # 結果の計算 -1/ρ u(u⋅∇ρ)
        result = VectorField(velocity.shape, velocity.dx)
        inv_density = ScalarField(density.shape, density.dx, 1.0) / (density + 1e-10)

        # 各成分の計算
        for i, v_comp in enumerate(velocity.components):
            result.components[i] = -(v_comp * density_advection * inv_density)

        # 診断情報の更新
        self._update_diagnostics(result, density_advection, density)

        return result

    def _update_diagnostics(
        self, result: VectorField, density_advection: ScalarField, density: ScalarField
    ):
        """
        診断情報を更新

        Args:
            result: 計算された加速度項
            density_advection: 密度の移流量
            density: 密度場
        """
        # 密度勾配の大きさ
        density_gradients = [
            np.max(np.abs(density.gradient(i))) for i in range(density.ndim)
        ]

        self._diagnostics = {
            "max_acceleration": float(
                max(np.max(np.abs(comp.data)) for comp in result.components)
            ),
            "density_advection": {
                "min": float(np.min(density_advection.data)),
                "max": float(np.max(density_advection.data)),
                "mean": float(np.mean(density_advection.data)),
            },
            "density_gradients": {
                "x": float(density_gradients[0]) if len(density_gradients) > 0 else 0.0,
                "y": float(density_gradients[1]) if len(density_gradients) > 1 else 0.0,
                "z": float(density_gradients[2]) if len(density_gradients) > 2 else 0.0,
            },
            "density_range": {
                "min": float(np.min(density.data)),
                "max": float(np.max(density.data)),
            },
        }

    def compute_timestep(
        self, velocity: VectorField, density: ScalarField, **kwargs
    ) -> float:
        """
        密度勾配による加速度項に基づく時間刻み幅の制限を計算

        Args:
            velocity: 速度場
            density: 密度場

        Returns:
            計算された時間刻み幅の制限
        """
        if not self.enabled:
            return float("inf")

        # 密度勾配の最大値を計算
        max_density_grad = max(
            np.max(np.abs(density.gradient(i))) for i in range(density.ndim)
        )

        # 最大速度の計算
        max_velocity = max(np.max(np.abs(comp.data)) for comp in velocity.components)

        # 特性速度の推定: v_c ≈ max(|u|) * max(|∇ρ|/ρ)
        min_density = np.min(density.data)
        characteristic_speed = max_velocity * max_density_grad / (min_density + 1e-10)

        # CFL条件に基づく時間刻み幅の計算
        cfl = kwargs.get("cfl", 0.5)
        return cfl * min(velocity.dx) / (characteristic_speed + 1e-10)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(self._diagnostics)
        return diag

```

### physics/navier_stokes/terms/diffusion.py

```
"""
粘性項（拡散項）の計算を提供するモジュール（改良版）

Navier-Stokes方程式における∇⋅(μ(∇u+∇uᵀ)) 項を計算します。
新しい演算子とメソッドを活用して実装を改善しています。
"""

from typing import Dict, Any, Union
import numpy as np

from core.field import VectorField, ScalarField
from .base import BaseNavierStokesTerm


class DiffusionTerm(BaseNavierStokesTerm):
    """粘性項（拡散項）を計算するクラス（改良版）"""

    def __init__(self, name: str = "Diffusion", enabled: bool = True, order: int = 2):
        """
        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
            order: 差分近似の次数
        """
        super().__init__(name, enabled)
        self._order = order

    def compute(
        self,
        velocity: VectorField,
        viscosity: Union[float, ScalarField, None] = None,
        **kwargs,
    ) -> VectorField:
        """
        粘性項 ∇⋅(μ(∇u+∇uᵀ)) を計算
        新しい演算子を活用して実装を改善

        Args:
            velocity: 速度場
            viscosity: 粘性係数（スカラー値またはスカラー場）

        Returns:
            拡散項をVectorFieldとして返す
        """
        if not self.enabled:
            return VectorField(velocity.shape, velocity.dx)

        # 粘性係数の正規化（新しいコンストラクタを活用）
        nu_field = (
            viscosity
            if isinstance(viscosity, ScalarField)
            else ScalarField(
                velocity.shape, velocity.dx, initial_value=viscosity or 1.0e-3
            )
        )

        # 対称勾配テンソルの計算（新しいメソッドを活用）
        strain = velocity.symmetric_gradient()

        # 粘性応力の計算と発散（新しい演算子を活用）
        result = (nu_field * strain).divergence()

        # 診断情報の更新
        self._update_diagnostics(result, nu_field)
        return result

    def _update_diagnostics(self, result: VectorField, viscosity: ScalarField):
        """診断情報を更新（新しいメソッドを活用）"""
        self._diagnostics = {
            "order": self._order,
            "diffusion": {
                "max_magnitude": float(result.magnitude().max()),
                "component_max": {
                    f"component_{i}": float(comp.norm(ord=np.inf))
                    for i, comp in enumerate(result.components)
                },
            },
            "viscosity": {
                "min": float(viscosity.min()),
                "max": float(viscosity.max()),
                "mean": float(viscosity.mean()),
            },
        }

    def compute_timestep(self, velocity: VectorField, **kwargs) -> float:
        """
        拡散項に基づく時間刻み幅の制限を計算
        新しいメソッドを活用

        Args:
            velocity: 速度場

        Returns:
            計算された時間刻み幅の制限
        """
        if not self.enabled:
            return float("inf")

        # 粘性の取得と正規化
        viscosity = kwargs.get("viscosity", 1.0e-3)
        if isinstance(viscosity, ScalarField):
            viscosity = viscosity.max()

        # von Neumannの安定性解析に基づく制限
        dx_min = min(velocity.dx)
        return 0.5 * dx_min * dx_min / (viscosity + 1e-10)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(self._diagnostics)
        return diag

```

### physics/navier_stokes/terms/__init__.py

```
"""Navier-Stokes方程式の各項を提供するパッケージ

このパッケージは、Navier-Stokes方程式を構成する各項
（移流項、粘性項、圧力項、加速度項）を実装したクラスを提供します。
"""

from .base import BaseNavierStokesTerm
from .advection import AdvectionTerm
from .diffusion import DiffusionTerm
from .pressure import PressureTerm
from .acceleration import AccelerationTerm

__all__ = [
    # 基底クラス
    "BaseNavierStokesTerm",
    # 具体的な項の実装
    "AdvectionTerm",
    "DiffusionTerm",
    "PressureTerm",
    "AccelerationTerm",
]

```

### physics/navier_stokes/terms/pressure.py

```
"""
圧力項の計算を提供するモジュール

Navier-Stokes方程式における -1/ρ ∇p 項を計算します。
"""

from typing import Dict, Any, Union
import numpy as np

from core.field import VectorField, ScalarField
from .base import BaseNavierStokesTerm


class PressureTerm(BaseNavierStokesTerm):
    """
    圧力項を計算するクラス

    速度場の圧力勾配項を中心差分で近似計算します。
    """

    def __init__(self, name: str = "Pressure", enabled: bool = True, order: int = 2):
        """
        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
            order: 差分近似の次数（2次、4次など）
        """
        super().__init__(name, enabled)
        self._order = order

    def compute(
        self,
        velocity: VectorField,
        pressure: ScalarField,
        density: Union[float, ScalarField, None] = None,
        **kwargs,
    ) -> VectorField:
        """
        圧力項 -1/ρ ∇p を計算

        Args:
            velocity: 速度場（形状情報のみ使用）
            pressure: 圧力場
            density: 密度場（またはスカラー値）

        Returns:
            圧力項をVectorFieldとして返す
        """
        if not self.enabled:
            return VectorField(velocity.shape, velocity.dx)

        # 密度場の正規化
        density_field = (
            density
            if isinstance(density, ScalarField)
            else ScalarField(
                velocity.shape, velocity.dx, initial_value=density or 1000.0
            )
        )

        # 圧力勾配項の計算
        result = -pressure.gradient() / density_field

        # 診断情報の更新
        self._update_diagnostics(result, pressure, density_field)

        return result

    def _update_diagnostics(
        self, result: VectorField, pressure: ScalarField, density: ScalarField
    ):
        """
        診断情報を更新

        Args:
            result: 計算された圧力項
            pressure: 圧力場
            density: 密度場
        """
        gradient_max = [float(np.max(np.abs(comp.data))) for comp in result.components]

        self._diagnostics = {
            "order": self._order,
            "max_gradient_x": gradient_max[0] if len(gradient_max) > 0 else 0.0,
            "max_gradient_y": gradient_max[1] if len(gradient_max) > 1 else 0.0,
            "max_gradient_z": gradient_max[2] if len(gradient_max) > 2 else 0.0,
            "max_pressure_gradient": float(max(gradient_max)),
            "pressure_range": {
                "min": float(np.min(pressure.data)),
                "max": float(np.max(pressure.data)),
                "mean": float(np.mean(pressure.data)),
            },
            "density_range": {
                "min": float(np.min(density.data)),
                "max": float(np.max(density.data)),
            },
        }

    def compute_timestep(
        self,
        velocity: VectorField,
        pressure: ScalarField,
        density: Union[float, ScalarField, None] = None,
        **kwargs,
    ) -> float:
        """
        圧力項に基づく時間刻み幅の制限を計算

        Args:
            velocity: 速度場
            pressure: 圧力場
            density: 密度場またはスカラー値

        Returns:
            計算された時間刻み幅の制限
        """
        if not self.enabled:
            return float("inf")

        # 密度の処理
        if density is None:
            rho = 1000.0
        elif isinstance(density, ScalarField):
            rho = np.min(density.data)  # 安全側の評価
        else:
            rho = float(density)

        # 音速の推定: c ≈ √(max(|∇p|)/ρ)
        max_pressure_grad = max(
            np.max(np.abs(pressure.gradient(i))) for i in range(pressure.ndim)
        )
        sound_speed = np.sqrt(max_pressure_grad / (rho + 1e-10))

        # CFL条件に基づく時間刻み幅の計算
        cfl = kwargs.get("cfl", 0.5)
        return cfl * velocity.dx / (sound_speed + 1e-10)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(self._diagnostics)
        return diag

```

### physics/navier_stokes/__init__.py

```
"""Navier-Stokes方程式の各項を提供するパッケージ

このパッケージは、Navier-Stokes方程式を構成する各項
（移流項、粘性項、圧力項、加速度項）を実装したクラスを提供します。
"""

from .solver import NavierStokesSolver

__all__ = ["NavierStokesSolver"]

```

### main2.py

```
"""
二相流シミュレーションのメインスクリプト

このスクリプトは、Level Set法を用いた二相流体シミュレーションの実行を管理します。
"""

import sys
import argparse
import json
from pathlib import Path
from typing import Optional, Tuple, Dict
import logging

from simulations import TwoPhaseFlowSimulator, SimulationConfig, SimulationInitializer
from visualization import visualize_simulation_state


class SimulationManager:
    """シミュレーションの実行を管理するクラス"""

    def __init__(
        self,
        config_path: str,
        checkpoint_path: Optional[str] = None,
        debug: bool = False,
    ):
        """シミュレーションマネージャを初期化"""
        # ロガーの設定
        self.logger = self._setup_logger(debug)

        # 設定の読み込み
        self.logger.info("設定ファイルを読み込み中: %s", config_path)
        self.config = SimulationConfig.from_yaml(config_path)

        # 出力ディレクトリの準備
        self.output_dir = Path(self.config.output.output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.checkpoint_dir = self.output_dir / "checkpoints"
        self.checkpoint_dir.mkdir(parents=True, exist_ok=True)

        # 診断情報の保存先
        self.diagnostics_dir = self.output_dir / "diagnostics"
        self.diagnostics_dir.mkdir(parents=True, exist_ok=True)

        # 初期化子の作成
        self.initializer = SimulationInitializer(self.config)

        # シミュレータの準備
        self.simulator = self._prepare_simulator(checkpoint_path)

        # デバッグ設定
        self.debug = debug

    def _setup_logger(self, debug: bool) -> logging.Logger:
        """ロガーを設定"""
        logger = logging.getLogger("SimulationManager")
        logger.setLevel(logging.DEBUG if debug else logging.INFO)

        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)

        return logger

    def _prepare_simulator(
        self, checkpoint_path: Optional[str] = None
    ) -> TwoPhaseFlowSimulator:
        """シミュレータを準備"""
        simulator = TwoPhaseFlowSimulator(config=self.config)

        if checkpoint_path:
            self.logger.info(
                "チェックポイントから状態を読み込み中: %s", checkpoint_path
            )
            state = simulator.load_checkpoint(checkpoint_path)
        else:
            self.logger.info("新規シミュレーション状態を作成中")
            state = self.initializer.create_initial_state()

        simulator.initialize(state)
        return simulator

    def _save_diagnostics(self, step_info: Dict, current_time: float):
        """診断情報を保存"""
        diagnostics_file = self.diagnostics_dir / f"diagnostics_{current_time:.6f}.json"
        with open(diagnostics_file, "w") as f:
            json.dump(step_info, f, indent=2)

    def run(self) -> int:
        """シミュレーションを実行"""
        try:
            # シミュレーションパラメータ
            save_interval = self.config.numerical.save_interval
            max_time = self.config.numerical.max_time

            # 初期状態の取得と可視化
            current_state, initial_diagnostics = self.simulator.get_state()
            self.logger.info("初期状態を可視化中")
            visualize_simulation_state(current_state, self.config, timestamp=0.0)

            # 初期チェックポイントの保存
            initial_checkpoint = self.checkpoint_dir / "initial_checkpoint.npz"
            self.simulator.save_checkpoint(str(initial_checkpoint))
            self._save_diagnostics(initial_diagnostics, 0.0)

            # シミュレーションのメインループ
            next_save_time = save_interval
            self.logger.info("シミュレーション開始")

            while current_state.time < max_time:
                try:
                    # 時間発展の実行
                    new_state, step_info = self.simulator.step_forward()
                    current_state = new_state

                    # 結果の保存と可視化
                    if current_state.time >= next_save_time:
                        self.logger.info(
                            "時刻 %.6f での状態を保存中", current_state.time
                        )

                        # 可視化
                        visualize_simulation_state(
                            current_state, self.config, timestamp=current_state.time
                        )

                        # チェックポイントの保存
                        checkpoint_filename = f"checkpoint_{current_state.time:.6f}.npz"
                        checkpoint_path = self.checkpoint_dir / checkpoint_filename
                        self.simulator.save_checkpoint(str(checkpoint_path))

                        # 診断情報の保存
                        self._save_diagnostics(step_info, current_state.time)

                        next_save_time += save_interval

                except Exception as step_error:
                    self.logger.error(
                        "シミュレーションステップ中にエラー: %s",
                        step_error,
                        exc_info=True,
                    )
                    return 1

            self.logger.info("シミュレーション正常終了")
            return 0

        except Exception as e:
            self.logger.error("シミュレーション実行中にエラー: %s", e, exc_info=True)
            return 1


def parse_args() -> Tuple[str, Optional[str], bool]:
    """コマンドライン引数をパース"""
    parser = argparse.ArgumentParser(
        description="Level Set法による二相流体シミュレーション"
    )
    parser.add_argument("--config", type=str, required=True, help="設定ファイルのパス")
    parser.add_argument("--checkpoint", type=str, help="チェックポイントファイルのパス")
    parser.add_argument("--debug", action="store_true", help="デバッグモードを有効化")

    args = parser.parse_args()
    return args.config, args.checkpoint, args.debug


def main() -> int:
    """メイン関数"""
    try:
        # コマンドライン引数の解析
        config_path, checkpoint_path, debug_mode = parse_args()

        # シミュレーションマネージャの作成と実行
        manager = SimulationManager(config_path, checkpoint_path, debug_mode)
        return manager.run()

    except Exception as e:
        print(f"実行中にエラーが発生: {e}", file=sys.stderr)
        if debug_mode:
            import traceback

            traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())

```

