# .

## Directory Structure

- ./
  - .venv/
  - simulations/
    - initializer.py
    - state.py
    - config.py
    - simulation.py
    - __init__.py
  - visualization/
    - core/
      - base.py
      - exporter.py
      - renderer.py
      - __init__.py
    - interfaces.py
    - utils/
      - colormap.py
      - camera.py
    - renderer_strategy.py
    - renderers/
      - vector2d.py
      - vector3d.py
      - __init__.py
      - scalar2d.py
      - scalar3d.py
    - visualizer.py
    - __init__.py
    - multiview.py
  - numerics/
    - spatial/
      - stencil.py
      - base.py
      - schemes/
        - central.py
      - __init__.py
    - time_evolution/
      - runge_kutta.py
      - euler.py
      - base.py
    - poisson/
      - solver.py
      - base.py
      - config.py
      - __init__.py
      - methods/
        - sor.py
  - core/
    - boundary/
      - dirichlet.py
      - base.py
      - periodic.py
      - neumann.py
      - __init__.py
    - solver/
      - base.py
      - temporal.py
      - iterative.py
      - __init__.py
    - field/
      - scalar.py
      - vector.py
      - conserved.py
      - field.py
      - __init__.py
  - main.py
  - config.yaml
  - physics/
    - levelset/
      - operations.py
      - initializer.py
      - reinitializer.py
      - method.py
      - field.py
      - __init__.py
      - utils.py
    - navier_stokes/
      - core/
        - interfaces.py
        - __init__.py
      - terms/
        - force.py
        - base.py
        - advection.py
        - acceleration.py
        - diffusion.py
        - __init__.py
        - pressure.py
      - solvers/
        - __init__.py
        - projection.py
      - __init__.py
  - main2.py
  - .vscode/
    - launch.json
  - .ruff_cache/

## File Contents

### simulations/initializer.py

```
"""シミュレーションの初期化を担当するモジュール"""

from typing import Dict, List
import numpy as np

from .config import SimulationConfig
from .state import SimulationState
from physics.levelset import LevelSetField
from physics.levelset.initializer import LevelSetInitializer, InterfaceObject
from core.field import VectorField, ScalarField


class SimulationInitializer:
    """シミュレーションの初期化を担当するクラス"""

    def __init__(self, config: SimulationConfig):
        """初期化子を構築

        Args:
            config: シミュレーション設定
        """
        self.config = config
        self.validate_config()

    def validate_config(self) -> None:
        """設定の妥当性を検証"""
        self.config.validate()

    def create_initial_state(self) -> SimulationState:
        """初期状態を生成

        Returns:
            初期化されたシミュレーション状態
        """
        # グリッドの形状を取得
        shape = tuple(self.config.domain.dimensions.values())
        dx = min(self.config.domain.size.values())

        # 速度場を初期化（ゼロで初期化）
        velocity = VectorField(shape)

        # レベルセット場を初期化
        levelset = self._initialize_levelset(shape, dx)

        # 圧力場を初期化（ゼロで初期化）
        pressure = ScalarField(shape)

        return SimulationState(
            time=0.0,
            velocity=velocity,
            levelset=levelset,
            pressure=pressure
        )

    def _initialize_levelset(self, shape: tuple, dx: float) -> LevelSetField:
        """レベルセット場を初期化"""
        # インターフェースオブジェクトの作成
        interface_objects = [
            InterfaceObject(
                phase=interface.phase,
                object_type=interface.object_type,
                height=interface.height,
                center=interface.center,
                radius=interface.radius
            )
            for interface in self.config.interfaces
        ]

        # Level Set初期化子を使用
        initializer = LevelSetInitializer(dx=dx)
        return initializer.initialize(shape=shape, objects=interface_objects)
```

### simulations/state.py

```
"""シミュレーションの状態を管理するモジュール

このモジュールは、二相流シミュレーションの状態（速度場、レベルセット場、圧力場など）を
管理するためのデータクラスを提供します。
"""

from dataclasses import dataclass
from typing import Dict, Any, Optional
import numpy as np

from core.field import VectorField, ScalarField
from physics.levelset import LevelSetField


@dataclass
class SimulationState:
    """シミュレーションの状態を保持するクラス
    
    物理量の場や時刻情報を保持し、状態の保存・読み込みも担当します。
    """
    time: float
    velocity: VectorField
    levelset: LevelSetField
    pressure: ScalarField
    diagnostics: Dict[str, Any] = None

    def __post_init__(self):
        """初期化後の処理"""
        if self.diagnostics is None:
            self.diagnostics = {}

    def validate(self) -> None:
        """状態の妥当性を検証"""
        if self.time < 0:
            raise ValueError("時刻は非負である必要があります")
        
        shapes = {
            "velocity": self.velocity.shape,
            "levelset": self.levelset.shape,
            "pressure": self.pressure.shape
        }
        if len(set(shapes.values())) > 1:
            raise ValueError(
                f"場の形状が一致しません: {shapes}"
            )

    def get_density(self) -> ScalarField:
        """密度場を計算"""
        # レベルセット関数から密度場を計算
        density = ScalarField(self.levelset.shape, self.levelset.dx)
        density.data = self.levelset.heaviside()
        return density

    def get_viscosity(self) -> ScalarField:
        """粘性場を計算"""
        # レベルセット関数から粘性場を計算
        viscosity = ScalarField(self.levelset.shape, self.levelset.dx)
        viscosity.data = self.levelset.heaviside()
        return viscosity

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "time": self.time,
            "velocity_max": float(np.max([np.abs(v.data).max() for v in self.velocity.components])),
            "pressure_max": float(np.abs(self.pressure.data).max()),
            "levelset_min": float(self.levelset.data.min()),
            "levelset_max": float(self.levelset.data.max()),
            **self.diagnostics
        }

    def save_state(self, filepath: str) -> None:
        """状態をファイルに保存

        Args:
            filepath: 保存先のファイルパス
        """
        np.savez_compressed(
            filepath,
            time=self.time,
            velocity_data=[v.data for v in self.velocity.components],
            levelset_data=self.levelset.data,
            pressure_data=self.pressure.data,
            diagnostics=self.diagnostics
        )

    @classmethod
    def load_state(cls, filepath: str) -> 'SimulationState':
        """ファイルから状態を読み込み

        Args:
            filepath: 読み込むファイルのパス

        Returns:
            読み込まれたシミュレーション状態
        """
        data = np.load(filepath)
        
        # 速度場の再構築
        velocity_shape = data["velocity_data"][0].shape
        velocity = VectorField(velocity_shape)
        for i, v_data in enumerate(data["velocity_data"]):
            velocity.components[i].data = v_data

        # レベルセット場の再構築
        levelset = LevelSetField(shape=data["levelset_data"].shape)
        levelset.data = data["levelset_data"]

        # 圧力場の再構築
        pressure = ScalarField(data["pressure_data"].shape)
        pressure.data = data["pressure_data"]

        return cls(
            time=float(data["time"]),
            velocity=velocity,
            levelset=levelset,
            pressure=pressure,
            diagnostics=data["diagnostics"].item()
        )
```

### simulations/config.py

```
"""シミュレーション設定を管理するモジュール"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
import numpy as np

from physics.levelset.initializer import Phase


@dataclass
class PhaseConfig:
    """流体の物性値を保持するクラス"""
    density: float
    viscosity: float
    surface_tension: float = 0.0


@dataclass
class DomainConfig:
    """計算領域の設定を保持するクラス"""
    dimensions: Dict[str, int]  # 'x', 'y', 'z'の格子点数
    size: Dict[str, float]      # 'x', 'y', 'z'の物理サイズ

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        if not all(dim > 0 for dim in self.dimensions.values()):
            raise ValueError("格子点数は正の値である必要があります")
        if not all(size > 0 for size in self.size.values()):
            raise ValueError("領域サイズは正の値である必要があります")


@dataclass
class InterfaceConfig:
    """界面の設定を保持するクラス"""
    phase: Phase
    object_type: str
    height: Optional[float] = None
    center: Optional[Tuple[float, float, float]] = None
    radius: Optional[float] = None

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        if self.object_type == "background":
            if any([self.height, self.center, self.radius]):
                raise ValueError("背景設定には追加パラメータは不要です")

        elif self.object_type == "layer":
            if not self.height or self.height <= 0:
                raise ValueError("レイヤーには正の高さが必要です")
            if any([self.center, self.radius]):
                raise ValueError("レイヤーには高さのみ指定してください")

        elif self.object_type == "sphere":
            if not self.center or not self.radius or self.radius <= 0:
                raise ValueError("球には中心座標と正の半径が必要です")
            if self.height is not None:
                raise ValueError("球には不要なパラメータが指定されています")


@dataclass
class SimulationConfig:
    """シミュレーション全体の設定を保持するクラス"""
    domain: DomainConfig
    phases: Dict[Phase, PhaseConfig]
    interfaces: List[InterfaceConfig] = field(default_factory=list)
    output_dir: str = "results"
    
    def validate(self) -> None:
        """設定値の妥当性を検証"""
        # ドメインの検証
        self.domain.validate()

        # 各界面設定の検証
        for interface in self.interfaces:
            interface.validate()
            if interface.phase not in self.phases:
                raise ValueError(f"未定義の相です: {interface.phase}")

        # 背景設定の確認
        background_objects = [obj for obj in self.interfaces if obj.object_type == "background"]
        if not background_objects:
            raise ValueError("背景相の設定が必要です")
        if len(background_objects) > 1:
            raise ValueError("背景相の設定は1つのみ可能です")

    @classmethod
    def from_dict(cls, config_dict: Dict) -> 'SimulationConfig':
        """辞書から設定を生成"""
        domain = DomainConfig(**config_dict["domain"])
        
        # 流体の物性値を設定
        phases = {
            Phase[name.upper()]: PhaseConfig(**props)
            for name, props in config_dict["phases"].items()
        }
        
        # 界面の設定を生成
        interfaces = []
        for obj_dict in config_dict.get("interfaces", []):
            interface_config = InterfaceConfig(
                phase=Phase[obj_dict["phase"].upper()],
                object_type=obj_dict["type"],
                height=obj_dict.get("height"),
                center=tuple(obj_dict.get("center", [])) if "center" in obj_dict else None,
                radius=obj_dict.get("radius")
            )
            interfaces.append(interface_config)
            
        return cls(
            domain=domain,
            phases=phases,
            interfaces=interfaces,
            output_dir=config_dict.get("output_dir", "results")
        )
```

### simulations/simulation.py

```
from physics import LevelSetMethod, NavierStokesSolver, TimeIntegrator
from .config import SimulationConfig
from .state import SimulationState
from .initializer import SimulationInitializer

class TwoPhaseFlowSimulator:
    def __init__(self, config: SimulationConfig):
        self.config = config
        self.time_integrator = TimeIntegrator()
        self.levelset_method = LevelSetMethod()
        self.navier_stokes_solver = NavierStokesSolver()

    def initialize(self):  
        initializer = SimulationInitializer(self.config)
        self.state = initializer.create_initial_state()
        
    def run(self, max_iterations):
        for _ in range(max_iterations):
            self.state = self._step_forward()
            self._output_state()
            
    def _step_forward(self):
        levelset = self.state.levelset
        velocity = self.state.velocity
        
        density = self.levelset_method.to_density(levelset)
        viscosity = self.levelset_method.to_viscosity(levelset)
        levelset_deriv = self.levelset_method.run(levelset)

        pressure, velocity_deriv = self.navier_stokes_solver.run(
            velocity=velocity,
            density=density,
            viscosity=viscosity,
        )

        dt = self._compute_dt()

        new_levelset = self.time_integrator.run(
            data=levelset.data, derivative=levelset_deriv, dt=dt
        )
        new_velocity = self.time_integrator.run(
            data=velocity, derivative=velocity_deriv, dt=dt  
        )

        return SimulationState(
            time=self.state.time + dt,
            velocity=new_velocity,
            levelset=new_levelset,
            pressure=pressure,  
        )

    def _compute_dt(self):
        # 安定性条件に基づきdtを計算
        return 0.01

    def _output_state(self):
        # 現在の状態を出力 
        pass
```

### simulations/__init__.py

```
from .simulation import TwoPhaseFlowSimulator
from .state import SimulationState
from .initializer import SimulationInitializer
from .config import SimulationConfig, DomainConfig, PhaseConfig, SolverConfig, OutputConfig

__all__ = [
    "TwoPhaseFlowSimulator",
    "SimulationState",
    "SimulationInitializer", 
    "SimulationConfig",
    "DomainConfig",
    "PhaseConfig", 
    "SolverConfig",
    "OutputConfig",
]
```

### visualization/core/base.py

```
"""可視化システムの基本クラスとインターフェースを提供するモジュール

このモジュールは可視化システムの設定とインターフェースを定義します。すべての
可視化コンポーネントの基盤となります。
"""

from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Union, Tuple
from pathlib import Path


@dataclass
class ViewConfig:
    """可視化の表示設定

    3D表示やスライス表示の視点・断面を制御します。

    Attributes:
        elevation: 仰角（度）
        azimuth: 方位角（度）
        distance: 視点距離
        focal_point: 注視点座標 (x, y, z)
        slice_positions: 各軸でのスライス位置 [0-1]
        slice_axes: 表示する断面の軸 (例: ["xy", "yz", "xz"])
    """

    elevation: float = 30.0
    azimuth: float = 45.0
    distance: float = 10.0
    focal_point: Tuple[float, float, float] = (0.5, 0.5, 0.5)
    slice_positions: List[float] = field(default_factory=lambda: [0.5, 0.5, 0.5])
    slice_axes: List[str] = field(default_factory=lambda: ["xy", "yz", "xz"])

    def validate(self):
        """設定値の検証"""
        if len(self.slice_positions) != 3:
            raise ValueError("slice_positionsは3つの要素を持つ必要があります")
        if any(not 0 <= pos <= 1 for pos in self.slice_positions):
            raise ValueError("slice_positionsは0から1の間である必要があります")
        valid_axes = {"xy", "yz", "xz", "yx", "zy", "zx"}
        if any(axis not in valid_axes for axis in self.slice_axes):
            raise ValueError(f"無効なslice_axes: {valid_axes}から選択してください")


@dataclass
class VisualizationConfig:
    """可視化の基本設定

    出力形式や表示オプションを制御します。

    Attributes:
        output_dir: 出力ディレクトリ
        format: 出力フォーマット
        dpi: 解像度
        colormap: デフォルトのカラーマップ
        show_colorbar: カラーバーの表示
        show_axes: 軸の表示
        show_grid: グリッドの表示
        fields: フィールドごとの可視化設定
    """

    output_dir: Union[str, Path] = "results/visualization"
    format: str = "png"
    dpi: int = 300
    colormap: str = "viridis"
    show_colorbar: bool = True
    show_axes: bool = True
    show_grid: bool = False

    # フィールドごとの可視化設定
    fields: Dict[str, Dict[str, Any]] = field(
        default_factory=lambda: {
            "velocity": {
                "enabled": True,
                "plot_types": ["vector", "magnitude"],
                "scale": 1.0,
                "density": 20,
                "color": "black",
                "alpha": 0.7,
            },
            "pressure": {
                "enabled": True,
                "plot_types": ["scalar", "contour"],
                "levels": 20,
                "alpha": 0.5,
            },
            "levelset": {
                "enabled": True,
                "plot_types": ["interface", "contour"],
                "levels": [0],
                "colors": ["black"],
                "linewidth": 2.0,
            },
        }
    )

    def __post_init__(self):
        """設定の後処理と検証"""
        if isinstance(self.output_dir, str):
            self.output_dir = Path(self.output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def get_output_path(self, name: str, timestamp: Optional[float] = None) -> Path:
        """出力ファイルパスを生成

        Args:
            name: ベース名
            timestamp: タイムスタンプ（オプション）

        Returns:
            生成されたパス
        """
        if timestamp is not None:
            filename = f"{name}_{timestamp:.6f}.{self.format}"
        else:
            filename = f"{name}.{self.format}"
        return self.output_dir / filename

    def get_field_config(
        self, section: str, default: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """指定されたセクションの設定を取得

        Args:
            section: 設定セクション名
            default: デフォルト値（オプション）

        Returns:
            設定辞書（存在しない場合はデフォルト設定）
        """
        import yaml
        import os

        # コンフィグファイルの読み込み
        config_path = os.path.join(os.getcwd(), "config.yaml")

        try:
            with open(config_path, "r") as f:
                full_config = yaml.safe_load(f)

            # 指定されたセクションの設定を取得
            section_config = full_config.get(section, {})
            return section_config
        except Exception as e:
            print(f"設定ファイルの読み込み中にエラー: {e}")
            return default or {}

    @classmethod
    def from_dict(cls, config: Dict[str, Any]) -> "VisualizationConfig":
        """辞書から設定を作成

        Args:
            config: 設定辞書

        Returns:
            設定インスタンス
        """
        # 基本設定の取得
        base_config = {
            "output_dir": config.get("output_dir", "results/visualization"),
            "format": config.get("format", "png"),
            "dpi": config.get("dpi", 300),
            "colormap": config.get("colormap", "viridis"),
            "show_colorbar": config.get("show_colorbar", True),
            "show_axes": config.get("show_axes", True),
            "show_grid": config.get("show_grid", False),
        }

        # フィールド設定の取得とマージ
        fields = {}
        for field_name, field_config in config.get("fields", {}).items():
            fields[field_name] = {
                "enabled": field_config.get("enabled", True),
                "plot_types": field_config.get("plot_types", ["scalar"]),
                **field_config,
            }

        return cls(**base_config, fields=fields)


class Exporter:
    """エクスポーターの基底クラス

    描画結果をファイルとして出力する基底クラス
    """

    def __init__(self, config: VisualizationConfig):
        """エクスポーターを初期化

        Args:
            config: 可視化設定
        """
        self.config = config

    def export(
        self, figure: Any, filepath: Path, metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """描画結果を出力

        Args:
            figure: 描画結果
            filepath: 出力パス
            metadata: メタデータ（オプション）
        """
        raise NotImplementedError("サブクラスで実装する必要があります")

```

### visualization/core/exporter.py

```
"""可視化結果のエクスポートを提供するモジュール

このモジュールは、Matplotlibの描画結果を画像ファイルとして
出力する機能を実装します。
"""

import json
from pathlib import Path
from typing import Dict, Any, Optional
import matplotlib.pyplot as plt

from .base import Exporter, VisualizationConfig


class ImageExporter(Exporter):
    """画像エクスポーター

    Matplotlibの描画結果を画像ファイルとして出力します。
    メタデータもJSONファイルとして保存できます。
    """

    def __init__(self, config: VisualizationConfig):
        """画像エクスポーターを初期化"""
        super().__init__(config)

    def export(
        self,
        figure: plt.Figure,
        filepath: Path,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> None:
        """描画結果を画像として出力

        Args:
            figure: Matplotlibの図
            filepath: 出力ファイルパス
            metadata: メタデータ（オプション）
        """
        # 出力ディレクトリの作成
        filepath.parent.mkdir(parents=True, exist_ok=True)

        # 画像として保存
        figure.savefig(
            filepath,
            dpi=self.config.dpi,
            format=self.config.format,
            bbox_inches="tight",
        )

        # メタデータの保存
        if metadata is not None:
            metadata_path = filepath.with_suffix(".json")
            with open(metadata_path, "w", encoding="utf-8") as f:
                json.dump(metadata, f, indent=2, ensure_ascii=False)

        # 図のクリーンアップ
        plt.close(figure)

```

### visualization/core/renderer.py

```
"""レンダリングエンジンの基底クラスを提供するモジュール

このモジュールは、2D/3Dレンダリングの基本機能を提供します。
matplotlibを使用した描画処理の共通部分を実装します。
"""

from abc import ABC, abstractmethod
from typing import Tuple, Dict, Any, Optional, List, Union, TYPE_CHECKING
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.axes import Axes
from matplotlib import colormaps
from matplotlib.colors import Normalize, LinearSegmentedColormap
from matplotlib.collections import QuadMesh

if TYPE_CHECKING:
    from .base import VisualizationConfig, ViewConfig


class BaseRenderer(ABC):
    """レンダラーの基底クラス

    全てのレンダラーに共通の機能を提供します。
    """

    def __init__(self, config: "VisualizationConfig"):
        """レンダラーを初期化

        Args:
            config: 可視化設定
        """
        self.config = config

    def create_figure(
        self, projection: Optional[str] = None, figsize: Tuple[float, float] = (10, 8)
    ) -> Tuple[Figure, Axes]:
        """図とAxesを作成

        Args:
            projection: プロジェクションの種類
            figsize: 図のサイズ

        Returns:
            (図, Axes)のタプル
        """
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection=projection)

        # 軸の設定
        if not self.config.show_axes:
            ax.set_axis_off()

        # グリッドの設定
        if self.config.show_grid:
            ax.grid(True)

        return fig, ax

    def setup_colorbar(
        self,
        mappable: Union[QuadMesh, plt.cm.ScalarMappable],
        ax: Axes,
        label: str = "",
        orientation: str = "vertical",
    ) -> Optional[Any]:
        """カラーバーを設定

        Args:
            mappable: カラーマップを持つオブジェクト
            ax: 対象のAxes
            label: カラーバーのラベル
            orientation: カラーバーの向き

        Returns:
            作成されたカラーバー
        """
        if self.config.show_colorbar:
            return plt.colorbar(mappable, ax=ax, label=label, orientation=orientation)
        return None

    def compute_data_range(
        self,
        data: np.ndarray,
        symmetric: bool = False,
        robust: bool = True,
        percentile: float = 2.0,
    ) -> Tuple[float, float]:
        """データの範囲を計算

        Args:
            data: 入力データ
            symmetric: 対称な範囲にするかどうか
            robust: 外れ値に対してロバストな範囲を使用するか
            percentile: ロバスト範囲計算時のパーセンタイル

        Returns:
            (最小値, 最大値)のタプル
        """
        valid_data = data[np.isfinite(data)]
        if len(valid_data) == 0:
            return 0.0, 1.0

        if robust:
            vmin = np.percentile(valid_data, percentile)
            vmax = np.percentile(valid_data, 100 - percentile)
        else:
            vmin = np.min(valid_data)
            vmax = np.max(valid_data)

        if symmetric:
            abs_max = max(abs(vmin), abs(vmax))
            return -abs_max, abs_max

        return vmin, vmax

    def create_normalizer(
        self, data: np.ndarray, symmetric: bool = False, robust: bool = True
    ) -> Normalize:
        """データの正規化オブジェクトを作成

        Args:
            data: 入力データ
            symmetric: 対称な範囲にするかどうか
            robust: 外れ値に対してロバストな範囲を使用するか

        Returns:
            正規化オブジェクト
        """
        vmin, vmax = self.compute_data_range(data, symmetric, robust)
        return Normalize(vmin=vmin, vmax=vmax)

    def create_colormap(
        self,
        name: Optional[str] = None,
        colors: Optional[List[str]] = None,
        reverse: bool = False,
    ) -> LinearSegmentedColormap:
        """カラーマップを作成

        Args:
            name: カラーマップ名（Noneの場合はcolorsを使用）
            colors: カラーのリスト
            reverse: カラーマップを反転するかどうか

        Returns:
            作成されたカラーマップ
        """
        if colors is not None:
            cmap = LinearSegmentedColormap.from_list("custom", colors)
        else:
            cmap = colormaps[name or self.config.colormap]

        if reverse:
            return LinearSegmentedColormap.from_list(
                f"{cmap.name}_r", cmap(np.linspace(1, 0, cmap.N))
            )
        return cmap

    @abstractmethod
    def render(self, *args, **kwargs) -> Tuple[Figure, Dict[str, Any]]:
        """描画を実行

        Args:
            *args: 位置引数
            **kwargs: キーワード引数

        Returns:
            (図, メタデータの辞書)のタプル
        """
        pass


class Renderer2D(BaseRenderer):
    """2Dレンダラーの基底クラス"""

    def setup_2d_axes(
        self,
        ax: Axes,
        extent: Optional[Tuple[float, float, float, float]] = None,
        aspect: str = "equal",
    ) -> None:
        """2D軸を設定

        Args:
            ax: 対象のAxes
            extent: データの表示範囲 [xmin, xmax, ymin, ymax]
            aspect: アスペクト比の設定
        """
        if extent is not None:
            ax.set_xlim(extent[0], extent[1])
            ax.set_ylim(extent[2], extent[3])

        ax.set_aspect(aspect)

        if self.config.show_axes:
            ax.set_xlabel("X")
            ax.set_ylabel("Y")

    def create_slice(self, data: np.ndarray, axis: int, position: float) -> np.ndarray:
        """3Dデータから2Dスライスを抽出

        Args:
            data: 3Dデータ
            axis: スライスする軸
            position: スライス位置（0-1）

        Returns:
            抽出された2Dスライス
        """
        if data.ndim != 3:
            raise ValueError("3Dデータが必要です")

        # スライスインデックスを計算
        idx = int(position * (data.shape[axis] - 1))

        # データのスライスを取得
        slices = [slice(None)] * 3
        slices[axis] = slice(idx, idx + 1)
        slice_data = data[tuple(slices)]

        # 余分な次元を削除
        return np.squeeze(slice_data)


class Renderer3D(BaseRenderer):
    """3Dレンダラーの基底クラス"""

    def setup_3d_axes(
        self,
        ax: Axes,
        view: Optional["ViewConfig"] = None,
        bounds: Optional[Tuple[np.ndarray, np.ndarray]] = None,
    ) -> None:
        """3D軸を設定

        Args:
            ax: 対象のAxes
            view: 視点設定
            bounds: データの境界 [(xmin, ymin, zmin), (xmax, ymax, zmax)]
        """
        if view is not None:
            ax.view_init(elev=view.elevation, azim=view.azimuth)
            ax.dist = view.distance

        if bounds is not None:
            min_point, max_point = bounds
            ax.set_xlim(min_point[0], max_point[0])
            ax.set_ylim(min_point[1], max_point[1])
            ax.set_zlim(min_point[2], max_point[2])

        if self.config.show_axes:
            ax.set_xlabel("X")
            ax.set_ylabel("Y")
            ax.set_zlabel("Z")

```

### visualization/core/__init__.py

```
"""可視化システムのコアモジュール

このパッケージは、可視化システムの中核となる基底クラスとインターフェースを提供します。
"""

# 基本的な設定とインターフェースを先にインポート
from .base import VisualizationConfig, ViewConfig

# その後でレンダラーをインポート
from .renderer import BaseRenderer, Renderer2D, Renderer3D
from .exporter import ImageExporter

__all__ = [
    "VisualizationConfig",
    "ViewConfig",
    "BaseRenderer",
    "Renderer2D",
    "Renderer3D",
    "ImageExporter",
]

```

### visualization/interfaces.py

```
"""可視化のためのインターフェースと抽象クラス"""

from abc import ABC, abstractmethod
from typing import Any, Optional, Dict
from .core.base import ViewConfig


class VisualizationStrategy(ABC):
    """可視化戦略の抽象基底クラス"""

    @abstractmethod
    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """データを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        pass


class MultiFieldVisualizationStrategy(VisualizationStrategy):
    """複数のフィールドを同時に可視化する戦略"""

    @abstractmethod
    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        pass


class VisualizationContext:
    """可視化のコンテキストを管理するクラス"""

    def __init__(self, strategy: VisualizationStrategy):
        """可視化戦略を設定

        Args:
            strategy: 使用する可視化戦略
        """
        self._strategy = strategy

    def set_strategy(self, strategy: VisualizationStrategy):
        """可視化戦略を動的に変更

        Args:
            strategy: 新しい可視化戦略
        """
        self._strategy = strategy

    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """データを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        return self._strategy.visualize(data, name, timestamp, view, **kwargs)

    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        if isinstance(self._strategy, MultiFieldVisualizationStrategy):
            return self._strategy.visualize_combined(
                fields, name, timestamp, view, **kwargs
            )
        raise NotImplementedError(
            "現在の可視化戦略は複数フィールドの可視化をサポートしていません"
        )


class VisualizationFactory:
    """可視化戦略を生成するファクトリクラス"""

    @staticmethod
    def create_strategy(
        strategy_type: str, config: Dict[str, Any]
    ) -> VisualizationStrategy:
        """指定された型の可視化戦略を生成

        Args:
            strategy_type: 可視化戦略の種類
            config: 設定辞書

        Returns:
            生成された可視化戦略
        """
        from .renderer_strategy import (
            Renderer2DVisualizationStrategy,
            Renderer3DVisualizationStrategy,
        )

        strategies = {
            "2d": Renderer2DVisualizationStrategy,
            "3d": Renderer3DVisualizationStrategy,
        }

        if strategy_type.lower() not in strategies:
            raise ValueError(f"未知の可視化戦略: {strategy_type}")

        return strategies[strategy_type.lower()](config)

```

### visualization/utils/colormap.py

```
"""カラーマップ操作のユーティリティを提供するモジュール

このモジュールは、データの可視化に使用するカラーマップの
生成と操作に関する機能を提供します。
"""

from typing import List, Optional
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap, Normalize


def create_custom_colormap(
    colors: List[str], name: str = "custom", n_bins: int = 256
) -> LinearSegmentedColormap:
    """カスタムカラーマップを作成

    Args:
        colors: カラーのリスト
        name: カラーマップの名前
        n_bins: 色の分割数

    Returns:
        作成されたカラーマップ
    """
    return LinearSegmentedColormap.from_list(name, colors, N=n_bins)


def create_diverging_colormap(
    neutral_point: float = 0.0,
    vmin: float = -1.0,
    vmax: float = 1.0,
    colors: Optional[List[str]] = None,
) -> LinearSegmentedColormap:
    """発散型カラーマップを作成

    Args:
        neutral_point: 中立点の値
        vmin: 最小値
        vmax: 最大値
        colors: カラーのリスト（省略時は blue-white-red）

    Returns:
        作成されたカラーマップ
    """
    if colors is None:
        colors = ["blue", "white", "red"]

    # 中立点の相対位置を計算
    total_range = vmax - vmin
    if total_range <= 0:
        raise ValueError("無効なデータ範囲です")

    neutral_pos = (neutral_point - vmin) / total_range
    neutral_pos = np.clip(neutral_pos, 0, 1)

    # カラーマップの作成
    if neutral_pos == 0.5:
        # 対称なカラーマップ
        return create_custom_colormap(colors)
    else:
        # 非対称なカラーマップ
        positions = [0, neutral_pos, 1]
        return LinearSegmentedColormap.from_list(
            "diverging", list(zip(positions, colors))
        )


def apply_colormap(
    data: np.ndarray,
    vmin: Optional[float] = None,
    vmax: Optional[float] = None,
    cmap: str = "viridis",
    symmetric: bool = False,
    alpha: Optional[float] = None,
) -> np.ndarray:
    """データにカラーマップを適用

    Args:
        data: 入力データ
        vmin: 最小値（省略時は自動計算）
        vmax: 最大値（省略時は自動計算）
        cmap: カラーマップ名
        symmetric: 対称な範囲にするかどうか
        alpha: 透明度

    Returns:
        RGBA形式のカラー配列
    """
    # データ範囲の計算
    if vmin is None:
        vmin = np.nanmin(data)
    if vmax is None:
        vmax = np.nanmax(data)

    if symmetric:
        abs_max = max(abs(vmin), abs(vmax))
        vmin, vmax = -abs_max, abs_max

    # 正規化とカラーマップの適用
    norm = Normalize(vmin=vmin, vmax=vmax)
    mapper = plt.get_cmap(cmap)
    colors = mapper(norm(data))

    # 透明度の設定
    if alpha is not None:
        colors[..., 3] = alpha

    return colors

```

### visualization/utils/camera.py

```
"""カメラ設定を管理するモジュール

このモジュールは、3D可視化におけるカメラパラメータの
管理と変換を担当します。
"""

from dataclasses import dataclass, field
import numpy as np
from typing import Tuple, Optional

from ..core.base import ViewConfig


@dataclass
class CameraState:
    """カメラの状態を表すクラス

    位置、方向、上方向ベクトルなどを保持します。
    """

    position: np.ndarray = field(default_factory=lambda: np.zeros(3))
    target: np.ndarray = field(default_factory=lambda: np.zeros(3))
    up: np.ndarray = field(default_factory=lambda: np.array([0, 0, 1]))

    @property
    def direction(self) -> np.ndarray:
        """視線方向を取得"""
        d = self.target - self.position
        return d / np.linalg.norm(d)

    @property
    def right(self) -> np.ndarray:
        """右方向を取得"""
        r = np.cross(self.direction, self.up)
        return r / np.linalg.norm(r)


class CameraController:
    """カメラ制御クラス

    ビュー設定とカメラ状態の変換や、
    カメラの移動・回転などの操作を提供します。
    """

    @staticmethod
    def view_to_camera(
        view: ViewConfig, bounds: Optional[Tuple[np.ndarray, np.ndarray]] = None
    ) -> CameraState:
        """ビュー設定からカメラ状態を計算

        Args:
            view: ビュー設定
            bounds: データの境界ボックス (最小点, 最大点)

        Returns:
            カメラ状態
        """
        # 注視点の設定
        if bounds is not None:
            min_point, max_point = bounds
            center = (min_point + max_point) / 2
            target = center
        else:
            target = np.array(view.focal_point)

        # 球面座標からカメラ位置を計算
        theta = np.radians(view.azimuth)  # 方位角
        phi = np.radians(90 - view.elevation)  # 極角（天頂角）

        # 単位球面上の位置
        x = np.sin(phi) * np.cos(theta)
        y = np.sin(phi) * np.sin(theta)
        z = np.cos(phi)

        # スケーリングと平行移動
        position = target + view.distance * np.array([x, y, z])

        return CameraState(position=position, target=target)

    @staticmethod
    def camera_to_view(camera: CameraState) -> ViewConfig:
        """カメラ状態からビュー設定を計算

        Args:
            camera: カメラ状態

        Returns:
            ビュー設定
        """
        # カメラから注視点へのベクトル
        direction = camera.target - camera.position
        distance = np.linalg.norm(direction)

        # 方位角と仰角を計算
        x, y, z = direction / distance

        azimuth = np.degrees(np.arctan2(y, x))
        elevation = 90 - np.degrees(np.arccos(z))

        return ViewConfig(
            elevation=elevation,
            azimuth=azimuth,
            distance=distance,
            focal_point=tuple(camera.target),
        )

    @staticmethod
    def orbit_camera(
        camera: CameraState, delta_azimuth: float, delta_elevation: float
    ) -> CameraState:
        """カメラを軌道運動させる

        Args:
            camera: 現在のカメラ状態
            delta_azimuth: 方位角の変化量（度）
            delta_elevation: 仰角の変化量（度）

        Returns:
            新しいカメラ状態
        """
        # 現在のビュー設定を取得
        view = CameraController.camera_to_view(camera)

        # 角度を更新
        view.azimuth += delta_azimuth
        view.elevation = np.clip(view.elevation + delta_elevation, -89, 89)

        # 新しいカメラ状態を計算
        return CameraController.view_to_camera(view)

    @staticmethod
    def zoom_camera(camera: CameraState, zoom_factor: float) -> CameraState:
        """カメラをズームする

        Args:
            camera: 現在のカメラ状態
            zoom_factor: ズーム倍率（1より大きい場合はズームイン）

        Returns:
            新しいカメラ状態
        """
        # 現在の距離を取得
        view = CameraController.camera_to_view(camera)

        # 距離を更新
        view.distance /= zoom_factor

        # 新しいカメラ状態を計算
        return CameraController.view_to_camera(view)

    @staticmethod
    def pan_camera(camera: CameraState, delta_x: float, delta_y: float) -> CameraState:
        """カメラをパンする

        Args:
            camera: 現在のカメラ状態
            delta_x: 水平方向の移動量
            delta_y: 垂直方向の移動量

        Returns:
            新しいカメラ状態
        """
        # 移動ベクトルを計算
        right = camera.right
        up = camera.up
        offset = delta_x * right + delta_y * up

        # カメラと注視点を移動
        new_position = camera.position + offset
        new_target = camera.target + offset

        return CameraState(position=new_position, target=new_target, up=camera.up)

```

### visualization/renderer_strategy.py

```
"""可視化戦略の実装"""

from typing import Any, Optional, Dict
from .core.base import ViewConfig
from .interfaces import MultiFieldVisualizationStrategy
from .visualizer import Visualizer


class Renderer2DVisualizationStrategy(MultiFieldVisualizationStrategy):
    """2Dレンダラーを使用した可視化戦略"""

    def __init__(self, config: Dict[str, Any]):
        """戦略を初期化

        Args:
            config: 可視化設定
        """
        self.visualizer = Visualizer(config)

    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """2Dデータを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        if isinstance(data, list):  # ベクトル場
            return self.visualizer.visualize_vector(
                data, name, timestamp, view, **kwargs
            )
        else:  # スカラー場
            return self.visualizer.visualize_scalar(
                data, name, timestamp, view, **kwargs
            )

    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        # マップされたフィールドを準備
        scalar_data = fields.get("scalar") or fields.get("pressure")
        vector_data = fields.get("vector")

        return self.visualizer.visualize_combined(
            scalar_data=scalar_data,
            vector_components=vector_data,
            name=name,
            timestamp=timestamp,
            view=view,
            **kwargs,
        )


class Renderer3DVisualizationStrategy(MultiFieldVisualizationStrategy):
    """3Dレンダラーを使用した可視化戦略"""

    def __init__(self, config: Dict[str, Any]):
        """戦略を初期化

        Args:
            config: 可視化設定
        """
        self.visualizer = Visualizer(config)

    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """3Dデータを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        if isinstance(data, list):  # ベクトル場
            return self.visualizer.visualize_vector(
                data, name, timestamp, view, **kwargs
            )
        else:  # スカラー場
            return self.visualizer.visualize_scalar(
                data, name, timestamp, view, **kwargs
            )

    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        # マップされたフィールドを準備
        scalar_data = fields.get("scalar") or fields.get("pressure")
        vector_data = fields.get("vector")
        levelset_data = fields.get("levelset")

        # レベルセットを追加の可視化オプションに含める
        if levelset_data is not None:
            if "scalar_options" not in kwargs:
                kwargs["scalar_options"] = {}
            kwargs["scalar_options"]["levelset"] = levelset_data

        return self.visualizer.visualize_combined(
            scalar_data=scalar_data,
            vector_components=vector_data,
            name=name,
            timestamp=timestamp,
            view=view,
            **kwargs,
        )

```

### visualization/renderers/vector2d.py

```
"""2Dベクトル場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any, List
from matplotlib.axes import Axes
from matplotlib.figure import Figure


class Vector2DRenderer:
    """2Dベクトル場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def render(
        self, vector_components: List[np.ndarray], ax: Optional[Axes] = None, **kwargs
    ) -> Tuple[Figure, Dict[str, Any]]:
        """2Dベクトル場を描画

        Args:
            vector_components: ベクトル場の各成分 [u, v]
            ax: 既存のAxes（Noneの場合は新規作成）
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力バリデーション
        if len(vector_components) != 2:
            raise ValueError("2次元ベクトル場には2つの成分が必要です")

        u, v = vector_components

        # 図とAxesの準備
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.figure

        # ベクトルの大きさを計算
        magnitude = np.sqrt(u**2 + v**2)

        # デフォルトのパラメータ設定
        density = kwargs.get("density", 20)
        scale = kwargs.get("scale", 1.0)
        skip = max(1, min(u.shape) // density)

        # メタデータの準備
        metadata = {
            "data_range": {
                "min_magnitude": float(np.min(magnitude)),
                "max_magnitude": float(np.max(magnitude)),
            },
            "display_type": ["vector"],
        }

        # グリッドの生成
        nx, ny = u.shape
        x = np.arange(nx)
        y = np.arange(ny)
        X, Y = np.meshgrid(x, y, indexing="ij")

        # ベクトル場の描画
        ax.quiver(
            X[::skip, ::skip],
            Y[::skip, ::skip],
            u[::skip, ::skip],
            v[::skip, ::skip],
            color="blue",  # 単純な静的な色
            scale=scale,
            alpha=kwargs.get("alpha", 0.7),
        )

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # アスペクト比と軸ラベル
        ax.set_aspect("equal")
        ax.set_xlabel("X")
        ax.set_ylabel("Y")

        return fig, metadata

```

### visualization/renderers/vector3d.py

```
"""3Dベクトル場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any, List
from matplotlib.axes import Axes


class Vector3DRenderer:
    """3Dベクトル場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def _get_slice(
        self, data: np.ndarray, slice_axis: str, slice_pos: float
    ) -> Tuple[np.ndarray, ...]:
        """指定された軸とスライス位置でデータをスライス

        Args:
            data: 入力データ配列
            slice_axis: スライス軸 ('xy', 'xz', 'yz')
            slice_pos: スライス位置 (0-1)

        Returns:
            スライスされたデータと座標
        """
        # データの形状を取得
        nx, ny, nz = data.shape

        # スライス位置のインデックスを計算
        if slice_axis == "xy":
            slice_idx = int(slice_pos * (nz - 1))
            slice_data = data[:, :, slice_idx]
            x, y = np.meshgrid(np.arange(nx), np.arange(ny), indexing="ij")
            z = np.full_like(x, slice_idx)
        elif slice_axis == "xz":
            slice_idx = int(slice_pos * (ny - 1))
            slice_data = data[:, slice_idx, :]
            x, z = np.meshgrid(np.arange(nx), np.arange(nz), indexing="ij")
            y = np.full_like(x, slice_idx)
        elif slice_axis == "yz":
            slice_idx = int(slice_pos * (nx - 1))
            slice_data = data[slice_idx, :, :]
            y, z = np.meshgrid(np.arange(ny), np.arange(nz), indexing="ij")
            x = np.full_like(y, slice_idx)
        else:
            raise ValueError(f"無効なスライス軸: {slice_axis}")

        return slice_data, x, y, z

    def render(
        self,
        vector_components: List[np.ndarray],
        ax: Optional[Axes] = None,
        view: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> Tuple[plt.Figure, Dict[str, Any]]:
        """3Dベクトル場を描画

        Args:
            vector_components: ベクトル場の各成分 [u, v, w]
            ax: 既存のAxes（Noneの場合は新規作成）
            view: スライス情報
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力バリデーション
        if len(vector_components) != 3:
            raise ValueError("3次元ベクトル場には3つの成分が必要です")

        u, v, w = vector_components

        # スライス情報の取得
        slice_axis = view.get("slice_axes", ["xy"])[0] if view else "xy"
        slice_pos = view.get("slice_positions", [0.5])[0] if view else 0.5

        # 図とAxesの準備
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="3d")
        else:
            fig = ax.figure

        # スライスの取得
        slice_data_list = []
        for component in [u, v, w]:
            slice_data, x, y, z = self._get_slice(component, slice_axis, slice_pos)
            slice_data_list.append(slice_data)

        # メタデータの準備
        metadata = {
            "data_range": {
                "min_magnitude": float(np.min(slice_data_list[0])),
                "max_magnitude": float(np.max(slice_data_list[0])),
            },
            "display_type": ["vector", "slice"],
            "slice_info": {"axis": slice_axis, "position": slice_pos},
        }

        # ベクトル場の描画
        ax.quiver(
            x,
            y,
            z,
            slice_data_list[0],
            slice_data_list[1],
            slice_data_list[2],
            color="blue",
            alpha=kwargs.get("alpha", 0.7),
        )

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # 軸ラベルの設定
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")

        return fig, metadata

```

### visualization/renderers/__init__.py

```
"""可視化レンダラーパッケージの初期化"""

from .scalar2d import Scalar2DRenderer
from .scalar3d import Scalar3DRenderer
from .vector2d import Vector2DRenderer
from .vector3d import Vector3DRenderer

__all__ = [
    "Scalar2DRenderer",
    "Scalar3DRenderer",
    "Vector2DRenderer",
    "Vector3DRenderer",
]

```

### visualization/renderers/scalar2d.py

```
"""2Dスカラー場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any
from matplotlib.axes import Axes
from matplotlib.figure import Figure


class Scalar2DRenderer:
    """2Dスカラー場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def render(
        self, data: np.ndarray, ax: Optional[Axes] = None, **kwargs
    ) -> Tuple[Figure, Dict[str, Any]]:
        """2Dスカラー場を描画

        Args:
            data: スカラー場データ
            ax: 既存のAxes（Noneの場合は新規作成）
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力バリデーション
        if data.ndim != 2:
            raise ValueError("2次元データが必要です")

        # 図とAxesの準備
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.figure

        # デフォルトのパラメータ設定
        cmap = kwargs.get("cmap", "viridis")
        interpolation = kwargs.get("interpolation", "nearest")

        # メタデータの準備
        metadata = {
            "data_range": {
                "min": float(np.nanmin(data)),
                "max": float(np.nanmax(data)),
            },
            "display_type": ["scalar"],
        }

        # スカラー場の描画
        im = ax.imshow(
            data.T,
            origin="lower",
            cmap=cmap,
            interpolation=interpolation,
            alpha=kwargs.get("alpha", 1.0),
        )

        # カラーバーの追加
        if kwargs.get("colorbar", True):
            plt.colorbar(im, ax=ax)

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # 軸ラベルの追加
        ax.set_xlabel(kwargs.get("xlabel", "X"))
        ax.set_ylabel(kwargs.get("ylabel", "Y"))

        return fig, metadata

```

### visualization/renderers/scalar3d.py

```
"""3Dスカラー場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any, Union
from matplotlib.axes import Axes


class Scalar3DRenderer:
    """3Dスカラー場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def render(
        self,
        data: Union[np.ndarray, int],
        ax: Optional[Axes] = None,
        view: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> Tuple[plt.Figure, Dict[str, Any]]:
        """3Dスカラー場を描画

        Args:
            data: スカラー場データ
            ax: 既存のAxes（Noneの場合は新規作成）
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力データのチェック
        if isinstance(data, int):
            raise ValueError("データは数値ではなく、numpy配列である必要があります")

        # 入力バリデーション
        if data.ndim != 3:
            raise ValueError("3次元データが必要です")

        # 図とAxesの準備
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="3d")
        else:
            fig = ax.figure

        # スライス位置の決定
        _ = {"yz": 0, "xz": 1, "xy": 2}
        if view is None:
            slice_axis = 2
            slice_pos = data.shape[0] // 2
        else:
            slice_axis = _[view.slice_axes[0]]
            slice_pos = int(view.slice_positions[0] * data.shape[0])

        # スライスの抽出
        slices = [slice(None)] * 3
        slices[slice_axis] = slice_pos
        slice_data = data[tuple(slices)].T

        # メタデータの準備
        metadata = {
            "data_range": {
                "min": float(np.nanmin(data)),
                "max": float(np.nanmax(data)),
            },
            "display_type": ["scalar", "slice"],
        }

        # グリッドの生成
        nx, ny = slice_data.shape
        x = np.arange(nx)
        y = np.arange(ny)
        X, Y = np.meshgrid(x, y)

        # 座標の調整
        if slice_axis == 0:
            X, Y, Z = slice_pos * np.ones_like(X), X, Y
        elif slice_axis == 1:
            X, Y, Z = X, slice_pos * np.ones_like(X), Y
        else:
            X, Y, Z = X, Y, slice_pos * np.ones_like(X)

        # カラーマップと色の設定
        cmap = kwargs.get("cmap", "viridis")

        # データの正規化
        normalized_data = (slice_data - slice_data.min()) / (
            slice_data.max() - slice_data.min()
        )

        im = ax.plot_surface(
            X,
            Y,
            Z,
            facecolors=plt.cm.get_cmap(cmap)(normalized_data),
            alpha=kwargs.get("alpha", 0.7),
        )

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # 軸ラベルの設定
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")

        return fig, metadata

```

### visualization/visualizer.py

```
"""可視化システムのメインクラスを提供するモジュール

このモジュールは、2次元・3次元の物理場の可視化機能を統合的に提供します。
"""

from typing import Optional, Dict, Any, Union, List

import numpy as np
from matplotlib import pyplot as plt

from .core.base import VisualizationConfig, ViewConfig
from .core.exporter import ImageExporter
from .renderers.scalar2d import Scalar2DRenderer
from .renderers.vector2d import Vector2DRenderer
from .renderers.scalar3d import Scalar3DRenderer
from .renderers.vector3d import Vector3DRenderer


class Visualizer:
    """可視化システムのメインクラス

    2次元・3次元の物理場の可視化を統合的に管理します。
    """

    def __init__(self, config: Union[VisualizationConfig, Dict[str, Any]]):
        """可視化システムを初期化

        Args:
            config: 設定（VisualizationConfigまたは辞書）
        """
        if isinstance(config, dict):
            self.config = VisualizationConfig.from_dict(config)
        else:
            self.config = config

        self.exporter = ImageExporter(self.config)

        # レンダラーの初期化
        self._renderers = {
            "2D": {
                "scalar": Scalar2DRenderer(self.config),
                "vector": Vector2DRenderer(self.config),
            },
            "3D": {
                "scalar": Scalar3DRenderer(self.config),
                "vector": Vector3DRenderer(self.config),
            },
        }

    def visualize_scalar(
        self,
        data: np.ndarray,
        name: str,
        timestamp: Optional[float] = None,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """スカラー場を可視化"""
        # データの次元に応じてレンダラーを選択
        renderer = self._renderers["3D" if data.ndim == 3 else "2D"]["scalar"]

        # 描画を実行
        fig, metadata = renderer.render(data, view=view, **kwargs)

        # 出力パスの生成
        filepath = self.config.get_output_path(name, timestamp)

        # 描画結果の出力
        self.exporter.export(fig, filepath, metadata)

        return str(filepath)

    def visualize_vector(
        self,
        vector_components: List[np.ndarray],
        name: str,
        timestamp: Optional[float] = None,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """ベクトル場を可視化"""
        # データの次元に応じてレンダラーを選択
        ndim = len(vector_components)
        renderer = self._renderers["3D" if ndim == 3 else "2D"]["vector"]

        # 描画を実行
        fig, metadata = renderer.render(vector_components, **kwargs)

        # 出力パスの生成
        filepath = self.config.get_output_path(name, timestamp)

        # 描画結果の出力
        self.exporter.export(fig, filepath, metadata)

        return str(filepath)

    def visualize_combined(
        self,
        scalar_data: Optional[np.ndarray] = None,
        vector_components: Optional[List[np.ndarray]] = None,
        name: str = "combined",
        timestamp: Optional[float] = None,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """スカラー場とベクトル場を重ねて可視化"""
        if scalar_data is not None:
            ndim = scalar_data.ndim
        elif vector_components is not None:
            ndim = len(vector_components)
        else:
            raise ValueError("スカラー場またはベクトル場が必要です")

        # 図の作成
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection="3d" if ndim == 3 else None)

        metadata = {}

        # スカラー場の描画
        if scalar_data is not None:
            renderer = self._renderers["3D" if ndim == 3 else "2D"]["scalar"]
            _, scalar_metadata = renderer.render(
                scalar_data, ax=ax, **kwargs.get("scalar_options", {})
            )
            metadata["scalar"] = scalar_metadata

        # ベクトル場の描画
        if vector_components is not None:
            renderer = self._renderers["3D" if ndim == 3 else "2D"]["vector"]
            _, vector_metadata = renderer.render(
                vector_components, ax=ax, **kwargs.get("vector_options", {})
            )
            metadata["vector"] = vector_metadata

        # 出力パスの生成
        filepath = self.config.get_output_path(name, timestamp)

        # 描画結果の出力
        self.exporter.export(fig, filepath, metadata)

        return str(filepath)

```

### visualization/__init__.py

```
"""可視化システムのメインモジュール

このパッケージは、2次元・3次元の物理場の可視化機能を統合的に提供します。
"""

from .core.base import VisualizationConfig, ViewConfig
from .visualizer import Visualizer
from .interfaces import VisualizationFactory, VisualizationContext
from .renderer_strategy import (
    Renderer2DVisualizationStrategy,
    Renderer3DVisualizationStrategy,
)

# レンダラー
from .renderers import (
    Scalar2DRenderer,
    Scalar3DRenderer,
    Vector2DRenderer,
    Vector3DRenderer,
)

# エクスポーター
from .core.exporter import ImageExporter

# 可視化関数
from .multiview import visualize_simulation_state, create_multiview_visualization

__all__ = [
    # 設定関連
    "VisualizationConfig",
    "ViewConfig",
    # メインクラス
    "Visualizer",
    # インターフェースと戦略
    "VisualizationFactory",
    "VisualizationContext",
    "Renderer2DVisualizationStrategy",
    "Renderer3DVisualizationStrategy",
    # レンダラー
    "Scalar2DRenderer",
    "Scalar3DRenderer",
    "Vector2DRenderer",
    "Vector3DRenderer",
    # エクスポーター
    "ImageExporter",
    # 可視化関数
    "visualize_simulation_state",
    "create_multiview_visualization",
]

```

### visualization/multiview.py

```
"""可視化システムの多視点可視化モジュール

このモジュールは、シミュレーション状態の多視点可視化を提供します。
"""

from pathlib import Path
from typing import List

from .core.base import VisualizationConfig, ViewConfig
from .interfaces import VisualizationContext, VisualizationFactory


def create_multiview_visualization(
    state,
    config: VisualizationConfig,
    timestamp: float = 0.0,
    base_name: str = "simulation_state",
) -> List[str]:
    """シミュレーション状態の多視点可視化を生成

    Args:
        state: シミュレーション状態
        config: 可視化設定
        timestamp: 現在の時刻
        base_name: 出力ファイル名のベース

    Returns:
        生成された可視化ファイルのパス一覧
    """
    # 出力ディレクトリの作成
    # configがSimulationConfigの場合
    if hasattr(config, "output_dir"):
        output_dir = Path(config.output_dir)
    # configが辞書の場合
    elif isinstance(config, dict):
        output_dir = Path(config.get("output_dir", "results/visualization"))
    else:
        output_dir = Path("results/visualization")

    output_dir.mkdir(parents=True, exist_ok=True)

    # 出力ファイルのパスを格納するリスト
    output_files = []

    # 可視化戦略の選択（次元数に基づく）
    ndim = len(state.velocity.components[0].data.shape)
    strategy_type = "3d" if ndim == 3 else "2d"
    viz_context = VisualizationContext(
        VisualizationFactory.create_strategy(strategy_type, config)
    )

    # 可視化設定の取得
    if isinstance(config, dict):
        viz_config = config.get("visualization", {})
    elif hasattr(config, "output"):
        viz_config = getattr(config.output, "fields", {})
    else:
        viz_config = {}

    # スライス設定の取得
    slice_axes = viz_config.get("slices", {}).get("axes", ["xy"])
    slice_positions = viz_config.get("slices", {}).get("positions", [0.5])

    # 可視化する物理量の設定
    fields_config = viz_config.get("fields", {})
    physics_fields = []

    # 速度場の設定
    if fields_config.get("velocity", {}).get("enabled", False):
        physics_fields.append(
            {
                "name": "velocity",
                "data": [comp.data for comp in state.velocity.components],
                "plot_type": "vector",
            }
        )

    # 圧力場の設定
    if fields_config.get("pressure", {}).get("enabled", False):
        physics_fields.append(
            {"name": "pressure", "data": state.pressure.data, "plot_type": "scalar"}
        )

    # レベルセット場の設定
    if fields_config.get("levelset", {}).get("enabled", False):
        physics_fields.append(
            {"name": "levelset", "data": state.levelset.data, "plot_type": "scalar"}
        )

    # 可視化の実行
    for field in physics_fields:
        for slice_axis in slice_axes:
            for slice_pos in slice_positions:
                try:
                    # ViewConfigの作成
                    view_config = ViewConfig(
                        slice_axes=[slice_axis], slice_positions=[slice_pos]
                    )

                    # ファイル名の生成
                    filename = (
                        f"{base_name}_{field['name']}"
                        f"_{slice_axis}_slice_{slice_pos:.2f}_{timestamp:.3f}"
                    )

                    # 可視化の実行
                    filepath = viz_context.visualize(
                        field["data"],
                        name=filename,
                        timestamp=timestamp,
                        view=view_config,
                    )

                    output_files.append(filepath)

                except Exception as e:
                    print(f"可視化中にエラー発生: {e}")
                    import traceback

                    traceback.print_exc()

    return output_files


def visualize_simulation_state(state, config, timestamp: float = 0.0) -> List[str]:
    """シミュレーション状態を可視化

    Args:
        state: シミュレーション状態
        config: 可視化設定
        timestamp: 現在の時刻

    Returns:
        生成された可視化ファイルのパス一覧
    """
    # 設定が辞書の場合、VisualizationConfigに変換
    if isinstance(config, dict):
        config = VisualizationConfig.from_dict(config)

    return create_multiview_visualization(state, config, timestamp=timestamp)

```

### numerics/spatial/stencil.py

```
"""差分ステンシルを定義するモジュール

このモジュールは、各種の差分スキームで使用されるステンシルを定義します。
2次、4次、6次の中心差分と、境界での特殊なステンシルを提供します。
"""

import numpy as np
from dataclasses import dataclass


@dataclass
class StencilCoefficients:
    """差分ステンシルの係数を保持するクラス

    Attributes:
        points: ステンシル点の相対位置
        coefficients: 各点での係数
    """

    points: np.ndarray
    coefficients: np.ndarray

    def validate(self):
        """ステンシル係数の妥当性を検証"""
        if len(self.points) != len(self.coefficients):
            raise ValueError("点の数と係数の数が一致しません")


class DifferenceStencils:
    """差分ステンシルの定義を提供するクラス"""

    # 1階微分の中心差分ステンシル
    CENTRAL_FIRST = {
        2: StencilCoefficients(  # 2次精度
            points=np.array([-1, 0, 1]),
            coefficients=np.array([-1 / 2, 0, 1 / 2]),
        ),
        4: StencilCoefficients(  # 4次精度
            points=np.array([-2, -1, 0, 1, 2]),
            coefficients=np.array([1 / 12, -2 / 3, 0, 2 / 3, -1 / 12]),
        ),
        6: StencilCoefficients(  # 6次精度
            points=np.array([-3, -2, -1, 0, 1, 2, 3]),
            coefficients=np.array([-1 / 60, 3 / 20, -3 / 4, 0, 3 / 4, -3 / 20, 1 / 60]),
        ),
    }

    # 2階微分の中心差分ステンシル
    CENTRAL_SECOND = {
        2: StencilCoefficients(  # 2次精度
            points=np.array([-1, 0, 1]),
            coefficients=np.array([1, -2, 1]),
        ),
        4: StencilCoefficients(  # 4次精度
            points=np.array([-2, -1, 0, 1, 2]),
            coefficients=np.array([-1 / 12, 4 / 3, -5 / 2, 4 / 3, -1 / 12]),
        ),
        6: StencilCoefficients(  # 6次精度
            points=np.array([-3, -2, -1, 0, 1, 2, 3]),
            coefficients=np.array(
                [1 / 90, -3 / 20, 3 / 2, -49 / 18, 3 / 2, -3 / 20, 1 / 90]
            ),
        ),
    }

    # 境界での1階微分ステンシル（前方差分）
    FORWARD_FIRST = {
        2: StencilCoefficients(  # 2次精度
            points=np.array([0, 1, 2]),
            coefficients=np.array([-3 / 2, 2, -1 / 2]),
        ),
        4: StencilCoefficients(  # 4次精度
            points=np.array([0, 1, 2, 3, 4]),
            coefficients=np.array([-25 / 12, 4, -3, 4 / 3, -1 / 4]),
        ),
    }

    # 境界での1階微分ステンシル（後方差分）
    BACKWARD_FIRST = {
        2: StencilCoefficients(  # 2次精度
            points=np.array([-2, -1, 0]),
            coefficients=np.array([1 / 2, -2, 3 / 2]),
        ),
        4: StencilCoefficients(  # 4次精度
            points=np.array([-4, -3, -2, -1, 0]),
            coefficients=np.array([1 / 4, -4 / 3, 3, -4, 25 / 12]),
        ),
    }

    @classmethod
    def get_first_derivative_stencil(
        cls, order: int, boundary: bool = False, side: int = 0
    ) -> StencilCoefficients:
        """1階微分のステンシルを取得

        Args:
            order: 精度次数
            boundary: 境界用のステンシルかどうか
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシル係数
        """
        if not boundary:
            if order not in cls.CENTRAL_FIRST:
                raise ValueError(f"未対応の次数です: {order}")
            return cls.CENTRAL_FIRST[order]
        else:
            if order not in cls.FORWARD_FIRST:
                raise ValueError(f"境界では未対応の次数です: {order}")
            if side == 0:
                return cls.FORWARD_FIRST[order]
            else:
                return cls.BACKWARD_FIRST[order]

    @classmethod
    def get_second_derivative_stencil(cls, order: int) -> StencilCoefficients:
        """2階微分のステンシルを取得

        Args:
            order: 精度次数

        Returns:
            ステンシル係数
        """
        if order not in cls.CENTRAL_SECOND:
            raise ValueError(f"未対応の次数です: {order}")
        return cls.CENTRAL_SECOND[order]

    @staticmethod
    def apply_stencil(
        data: np.ndarray, stencil: StencilCoefficients, axis: int, dx: float
    ) -> np.ndarray:
        """ステンシルを適用して微分を計算

        Args:
            data: 入力データ
            stencil: 適用するステンシル
            axis: 微分を計算する軸
            dx: グリッド間隔

        Returns:
            計算された微分
        """
        result = np.zeros_like(data)
        for point, coef in zip(stencil.points, stencil.coefficients):
            result += coef * np.roll(data, point, axis=axis)
        return result / (dx ** len(stencil.points))

```

### numerics/spatial/base.py

```
"""空間微分スキームの基底クラスを提供するモジュール

このモジュールは、空間微分計算のための基底クラスとインターフェースを定義します。
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Tuple, Optional
import numpy as np
from dataclasses import dataclass


@dataclass
class DifferentiationConfig:
    """空間微分の設定クラス

    Attributes:
        order: 差分近似の次数
        padding_mode: 境界での補完方法
        boundary_order: 境界での近似次数
    """

    order: int = 2
    padding_mode: str = "reflect"
    boundary_order: Optional[int] = None

    def validate(self):
        """設定値の妥当性を検証"""
        if self.order not in [2, 4, 6]:
            raise ValueError("差分近似の次数は2, 4, 6のいずれかである必要があります")

        valid_padding_modes = ["reflect", "constant", "nearest", "mirror"]
        if self.padding_mode not in valid_padding_modes:
            raise ValueError(f"無効なpadding_mode。選択肢: {valid_padding_modes}")

        if self.boundary_order is not None and self.boundary_order > self.order:
            raise ValueError("境界での近似次数は内部の次数以下である必要があります")


class SpatialDerivative(ABC):
    """空間微分の基底クラス

    この抽象基底クラスは、空間微分計算の共通インターフェースを定義します。
    """

    def __init__(self, config: Optional[DifferentiationConfig] = None):
        """空間微分計算器を初期化

        Args:
            config: 微分計算の設定
        """
        self.config = config or DifferentiationConfig()
        self.config.validate()

    @abstractmethod
    def __call__(self, data: np.ndarray, axis: int, dx: float) -> np.ndarray:
        """空間微分を計算

        Args:
            data: 入力データ
            axis: 微分を計算する軸
            dx: グリッド間隔

        Returns:
            計算された微分
        """
        pass

    @abstractmethod
    def get_stencil(self) -> Tuple[np.ndarray, np.ndarray]:
        """差分ステンシルを取得

        Returns:
            (points, coefficients) - ステンシルの位置と係数のタプル
        """
        pass

    def _validate_input(self, data: np.ndarray, axis: int, dx: float):
        """入力データの妥当性を検証

        Args:
            data: 入力データ
            axis: 微分を計算する軸
            dx: グリッド間隔

        Raises:
            ValueError: 無効な入力が指定された場合
        """
        if not isinstance(data, np.ndarray):
            raise ValueError("dataはnumpy配列である必要があります")

        if not 0 <= axis < data.ndim:
            raise ValueError(f"無効な軸です: {axis}")

        if dx <= 0:
            raise ValueError("グリッド間隔は正の値である必要があります")

    def get_padding_width(self) -> int:
        """必要なパディング幅を取得

        Returns:
            パディングが必要な点の数
        """
        return self.config.order // 2

    def apply_padding(
        self, data: np.ndarray, axis: int, width: Optional[int] = None
    ) -> np.ndarray:
        """データにパディングを適用

        Args:
            data: 入力データ
            axis: パディングを適用する軸
            width: パディング幅（Noneの場合は次数から自動決定）

        Returns:
            パディングが適用されたデータ
        """
        width = width or self.get_padding_width()
        # 軸ごとのパディング幅を指定
        pad_width = [(0, 0)] * data.ndim
        pad_width[axis] = (width, width)

        return np.pad(data, pad_width, mode=self.config.padding_mode)

    def get_boundary_stencil(self, side: int) -> Tuple[np.ndarray, np.ndarray]:
        """境界での差分ステンシルを取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            (points, coefficients) - 境界ステンシルの位置と係数のタプル
        """
        # デフォルトでは境界でも同じステンシルを使用
        return self.get_stencil()

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得

        Returns:
            診断情報の辞書
        """
        return {
            "order": self.config.order,
            "padding_mode": self.config.padding_mode,
            "boundary_order": self.config.boundary_order,
        }

```

### numerics/spatial/schemes/central.py

```
"""中心差分スキームを提供するモジュール

このモジュールは、2次、4次、6次の中心差分スキームを実装します。
"""

import numpy as np
from typing import Dict, Any
from ..base import SpatialDerivative, DifferentiationConfig
from ..stencil import DifferenceStencils, StencilCoefficients


class CentralDifference(SpatialDerivative):
    """中心差分による空間微分計算クラス

    2次、4次、6次の中心差分スキームを提供します。
    """

    def __init__(
        self,
        config: DifferentiationConfig = None,
        derivative_order: int = 1,
    ):
        """中心差分計算器を初期化

        Args:
            config: 差分計算の設定
            derivative_order: 微分の階数（1または2）
        """
        super().__init__(config)
        if derivative_order not in [1, 2]:
            raise ValueError("微分の階数は1または2である必要があります")
        self.derivative_order = derivative_order

    def __call__(self, data: np.ndarray, axis: int, dx: float) -> np.ndarray:
        """中心差分により微分を計算

        Args:
            data: 入力データ
            axis: 微分を計算する軸
            dx: グリッド間隔

        Returns:
            計算された微分
        """
        self._validate_input(data, axis, dx)

        # パディングの適用
        padded_data = self.apply_padding(data, axis)

        # ステンシルの取得と適用
        stencil = self.get_stencil()
        derivative = DifferenceStencils.apply_stencil(padded_data, stencil, axis, dx)

        # パディング部分の除去
        padding = self.get_padding_width()
        slices = [slice(None)] * data.ndim
        slices[axis] = slice(padding, -padding)
        return derivative[tuple(slices)]

    def get_stencil(self) -> StencilCoefficients:
        """差分ステンシルを取得

        Returns:
            ステンシル係数
        """
        if self.derivative_order == 1:
            return DifferenceStencils.get_first_derivative_stencil(self.config.order)
        else:  # derivative_order == 2
            return DifferenceStencils.get_second_derivative_stencil(self.config.order)

    def get_boundary_stencil(self, side: int) -> StencilCoefficients:
        """境界での差分ステンシルを取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界用のステンシル係数
        """
        if self.derivative_order == 1:
            order = self.config.boundary_order or self.config.order
            return DifferenceStencils.get_first_derivative_stencil(
                order, boundary=True, side=side
            )
        else:
            # 2階微分の場合は中心差分を使用
            return self.get_stencil()

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得

        Returns:
            診断情報の辞書
        """
        diag = super().get_diagnostics()
        diag.update(
            {
                "derivative_order": self.derivative_order,
                "method": "central",
                "stencil_width": self.get_padding_width() * 2 + 1,
            }
        )
        return diag

```

### numerics/spatial/__init__.py

```
"""空間微分計算パッケージ

このパッケージは、空間微分の計算に必要な各種スキームを提供します。
"""

from .base import SpatialDerivative, DifferentiationConfig
from .stencil import DifferenceStencils, StencilCoefficients
from .schemes.central import CentralDifference

__all__ = [
    # 基底クラスと設定
    "SpatialDerivative",
    "DifferentiationConfig",
    # ステンシル定義
    "DifferenceStencils",
    "StencilCoefficients",
    # 差分スキーム
    "CentralDifference",
]

```

### numerics/time_evolution/runge_kutta.py

```
from .base import BaseTimeIntegrator
from typing import Callable, TypeVar

T = TypeVar("T")


class ForwardEuler(BaseTimeIntegrator[T]):
    """前進オイラー法による時間積分"""

    def integrate(self, state: T, dt: float, derivative_fn: Callable[[T], T]) -> T:
        """前進オイラー法で時間積分を実行

        Args:
            state: 現在の状態
            dt: 時間刻み幅
            derivative_fn: 時間微分を計算する関数

        Returns:
            更新された状態
        """
        derivative = derivative_fn(state)
        return state + dt * derivative

    def get_order(self) -> int:
        """積分スキームの次数を返す"""
        return 1

    def get_error_estimate(self) -> float:
        """打切り誤差の推定値を返す"""
        return 0.5

```

### numerics/time_evolution/euler.py

```
"""時間積分スキームを提供するモジュール

このモジュールは、異なる時間積分法を実装します。
"""

from typing import Any, Callable, Dict, TypeVar
from .base import TimeIntegrator

StateType = TypeVar("StateType")


class ForwardEuler(TimeIntegrator[StateType]):
    """前進Euler法による時間積分"""

    def integrate(
        self,
        state: StateType,
        dt: float,
        derivative_fn: Callable[[StateType], StateType],
        **kwargs,
    ) -> StateType:
        """前進Euler法で状態を更新

        Args:
            state: 現在の状態
            dt: 時間刻み幅
            derivative_fn: 時間微分を計算する関数
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        derivative = derivative_fn(state, **kwargs)
        return state + dt * derivative

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "method": "Forward Euler",
            "order": 1,
            "stability": "条件付き安定",
            "error_estimate": 0.5,
        }


class RungeKutta4(TimeIntegrator[StateType]):
    """4次のRunge-Kutta法による時間積分"""

    def integrate(
        self,
        state: StateType,
        dt: float,
        derivative_fn: Callable[[StateType], StateType],
        **kwargs,
    ) -> StateType:
        """4次のRunge-Kutta法で状態を更新

        Args:
            state: 現在の状態
            dt: 時間刻み幅
            derivative_fn: 時間微分を計算する関数
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        # 各ステージの微分を計算
        k1 = derivative_fn(state, **kwargs)
        k2 = derivative_fn(state + 0.5 * dt * k1, **kwargs)
        k3 = derivative_fn(state + 0.5 * dt * k2, **kwargs)
        k4 = derivative_fn(state + dt * k3, **kwargs)

        # 状態を更新
        return state + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "method": "Runge-Kutta 4",
            "order": 4,
            "stability": "無条件安定",
            "error_estimate": 1 / 30,
        }


def create_integrator(method: str = "rk4", **kwargs) -> TimeIntegrator[StateType]:
    """時間積分器を生成

    Args:
        method: 積分法の種類 ('euler', 'rk4')
        **kwargs: 追加のパラメータ

    Returns:
        生成された時間積分器
    """
    integrators = {"euler": ForwardEuler, "rk4": RungeKutta4}

    if method.lower() not in integrators:
        raise ValueError(f"サポートされていない積分法: {method}")

    return integrators[method.lower()](**kwargs)

```

### numerics/time_evolution/base.py

```
from abc import ABC, abstractmethod
from typing import Callable, TypeVar, Generic

T = TypeVar("T")


class TimeIntegrator(ABC, Generic[T]):
    """時間積分のための抽象基底クラス"""

    def __init__(self, stability_limit: float = float("inf")):
        """
        Args:
            stability_limit: 安定性限界（CFL条件など）
        """
        self._stability_limit = stability_limit

    @abstractmethod
    def integrate(self, state: T, dt: float, derivative_fn: Callable[[T], T]) -> T:
        """時間積分を実行する抽象メソッド"""
        pass

    def check_stability(self, dt: float, state_derivative: T) -> bool:
        """安定性条件をチェック"""
        return True

    @abstractmethod
    def get_order(self) -> int:
        """積分スキームの次数を返す"""
        pass

    @abstractmethod
    def get_error_estimate(self) -> float:
        """打切り誤差の推定値を返す"""
        pass

```

### numerics/poisson/solver.py

```
"""Poisson方程式のソルバーを提供するモジュール

このモジュールは、Poisson方程式 ∇²φ = f を解くための反復法ソルバーを実装します。
"""

import numpy as np
from typing import Optional, List, Dict, Any, Union

from core.solver import IterativeSolver
from core.boundary import BoundaryCondition
from .base import PoissonSolverBase, PoissonSolverConfig, PoissonSolverTerm


class PoissonSolver(PoissonSolverBase, IterativeSolver):
    """Poisson方程式のソルバークラス

    このクラスは、Poisson方程式を解くための基本機能を提供します。
    具体的な反復法は派生クラスで実装します。
    """

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        boundary_conditions: Optional[List[BoundaryCondition]] = None,
        terms: Optional[List[PoissonSolverTerm]] = None,
        **kwargs,
    ):
        """Poissonソルバーを初期化

        Args:
            config: ソルバー設定
            boundary_conditions: 各方向の境界条件
            terms: 追加の項
            **kwargs: 基底クラスに渡すパラメータ
        """
        # デフォルト設定の処理
        config = config or PoissonSolverConfig()
        kwargs.setdefault("name", "Poisson")
        kwargs.setdefault("tolerance", config.convergence.get("tolerance", 1e-6))
        kwargs.setdefault(
            "max_iterations", config.convergence.get("max_iterations", 1000)
        )

        # 基底クラスの初期化
        PoissonSolverBase.__init__(
            self,
            config=config,
            boundary_conditions=boundary_conditions,
            logger=kwargs.get("logger"),
        )
        IterativeSolver.__init__(self, **kwargs)

        # 追加の項
        self.terms = terms or []

        # 収束判定フラグ
        self._converged = False

    def solve(
        self,
        rhs: np.ndarray,
        initial_solution: Optional[np.ndarray] = None,
        dx: Union[float, np.ndarray] = 1.0,
        **kwargs,
    ) -> np.ndarray:
        """Poisson方程式を解く

        Args:
            rhs: 右辺ベクトル
            initial_solution: 初期推定解
            dx: グリッド間隔
            **kwargs: 追加のパラメータ

        Returns:
            計算された解
        """
        try:
            # 初期解のセットアップ
            if initial_solution is None:
                initial_solution = np.zeros_like(rhs)

            # dx の正規化
            if np.isscalar(dx):
                dx = np.full(rhs.ndim, dx)
            elif len(dx) != rhs.ndim:
                raise ValueError(f"dxは{rhs.ndim}次元である必要があります")

            # 初期化処理
            self.reset()
            self._converged = False

            # 反復解法の実行
            solution = initial_solution.copy()
            residual = float("inf")  # 初期残差

            diagnostics_config = self.config.get_config_for_component("diagnostics")
            log_frequency = diagnostics_config.get("log_frequency", 10)

            while self._iteration_count < self.max_iterations:
                # 1回の反復
                new_solution = self.iterate(solution, rhs, dx)

                # 残差の計算
                residual = self.compute_residual(new_solution, rhs, dx)
                self._residual_history.append(residual)

                # 反復回数の更新
                self._iteration_count += 1

                # ログ出力
                if self._iteration_count % log_frequency == 0 and self.logger:
                    self.logger.info(
                        f"反復 {self._iteration_count}: 残差 = {residual:.3e}"
                    )

                # 収束判定
                if self.check_convergence(residual):
                    self._converged = True
                    break

                solution = new_solution

            # 結果の後処理
            if not self._converged and self.logger:
                self.logger.warning(
                    f"最大反復回数に到達: 残差 = {residual:.3e}, "
                    f"相対残差 = {residual / self._residual_history[0]:.3e}"
                )

            return solution

        except Exception as e:
            if self.logger:
                self.logger.error(f"Poissonソルバー実行中にエラー: {e}")
            raise

    def compute_residual(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> float:
        """残差を計算

        Args:
            solution: 現在の解
            rhs: 右辺
            dx: グリッド間隔（スカラーまたは配列）

        Returns:
            L2ノルムで測った残差
        """
        # dx の正規化
        if np.isscalar(dx):
            dx = np.full(solution.ndim, dx)
        elif len(dx) != solution.ndim:
            raise ValueError(f"dxは{solution.ndim}次元である必要があります")

        # ラプラシアンの計算
        laplacian = np.zeros_like(solution)
        for axis in range(solution.ndim):
            # 2次精度中心差分
            # 各方向のグリッド間隔を考慮
            forward = np.roll(solution, 1, axis=axis)
            backward = np.roll(solution, -1, axis=axis)
            laplacian += (forward + backward - 2 * solution) / (dx[axis] ** 2)

        # 残差の計算と境界条件の適用
        residual = laplacian - rhs

        # 境界条件の適用
        if self.boundary_conditions:
            for i, bc in enumerate(self.boundary_conditions):
                if bc is not None:
                    residual = bc.apply_all(residual, i)

        # L2ノルムを計算（ゼロ除算を防ぐ）
        residual_norm = np.sqrt(np.mean(residual**2))
        return max(residual_norm, 1e-15)  # 最小値を保証

    def iterate(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> np.ndarray:
        """デフォルトの反復計算（サブクラスでオーバーライド）

        Args:
            solution: 現在の解
            rhs: 右辺
            dx: グリッド間隔

        Raises:
            NotImplementedError: サブクラスで実装する必要がある
        """
        raise NotImplementedError("具体的な反復法はサブクラスで実装する必要があります")

    def check_convergence(self, residual: float) -> bool:
        """収束判定

        Args:
            residual: 現在の残差

        Returns:
            収束したかどうか
        """
        # 収束判定設定の取得
        convergence_config = self.config.get_config_for_component("convergence")
        relative_tolerance = convergence_config.get("relative_tolerance", False)

        # 初期残差の記録（最初の呼び出し時）
        if not self._residual_history:
            return False

        # 絶対残差または相対残差による収束判定
        if relative_tolerance:
            # 相対残差
            return (
                residual / self._residual_history[0] < self.tolerance
                and residual < self.tolerance
            )
        else:
            # 絶対残差
            return residual < self.tolerance

    def get_status(self) -> Dict[str, Any]:
        """ソルバーの状態を取得

        Returns:
            ソルバーの状態を表す辞書
        """
        status = super().get_status()
        status.update(
            {
                "terms_count": len(self.terms),
                "boundary_conditions_count": len(self.boundary_conditions),
                "config": {
                    "convergence": self.config.get_config_for_component("convergence"),
                    "solver_specific": self.config.get_config_for_component(
                        "solver_specific"
                    ),
                },
            }
        )
        return status

```

### numerics/poisson/base.py

```
"""Poisson方程式ソルバーの基底クラスとプロトコル

このモジュールは、Poisson方程式を解くためのインターフェースと基底クラスを定義します。
"""

from abc import ABC, abstractmethod
from typing import Protocol, Optional, List, Dict, Any, Union
import numpy as np

from core.boundary import BoundaryCondition


class PoissonSolverConfig(Protocol):
    """Poissonソルバーの設定プロトコル"""

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        ...

    def get_config_for_component(self, component: str) -> Dict[str, Any]:
        """特定のコンポーネントの設定を取得"""
        ...


class PoissonSolverTerm(Protocol):
    """Poisson方程式の項のプロトコル"""

    @property
    def name(self) -> str:
        """項の名前"""
        ...

    def compute(self, solution: np.ndarray, **kwargs) -> np.ndarray:
        """項の寄与を計算"""
        ...

    def get_diagnostics(self, solution: np.ndarray, **kwargs) -> Dict[str, Any]:
        """診断情報を取得"""
        ...


class PoissonSolverBase(ABC):
    """Poisson方程式ソルバーの基底抽象クラス"""

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        boundary_conditions: Optional[List[BoundaryCondition]] = None,
        logger=None,
    ):
        """ソルバーを初期化

        Args:
            config: ソルバー設定
            boundary_conditions: 境界条件
            logger: ロガー
        """
        self.config = config
        self.boundary_conditions = boundary_conditions or []
        self.logger = logger

        # 計算状態の追跡
        self._iteration_count = 0
        self._residual_history: List[float] = []
        self._converged = False

    @abstractmethod
    def solve(
        self, rhs: np.ndarray, initial_solution: Optional[np.ndarray] = None, **kwargs
    ) -> np.ndarray:
        """Poisson方程式を解く"""
        pass

    @abstractmethod
    def compute_residual(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> float:
        """残差を計算"""
        pass

    def initialize(self, **kwargs):
        """ソルバーを初期化

        デフォルトの実装では基本的な状態をリセット
        サブクラスでオーバーライド可能
        """
        # 計算状態のリセット
        self._iteration_count = 0
        self._residual_history = []
        self._converged = False

        # ロギング
        if self.logger:
            self.logger.info(f"{self.__class__.__name__}ソルバーを初期化")

    def get_diagnostics(self) -> Dict[str, Any]:
        """ソルバーの診断情報を取得

        Returns:
            診断情報の辞書
        """
        return {
            "iteration_count": self._iteration_count,
            "converged": self._converged,
            "residual_history": self._residual_history,
            "final_residual": (
                self._residual_history[-1] if self._residual_history else None
            ),
        }

    def reset(self):
        """ソルバーの状態をリセット"""
        self._iteration_count = 0
        self._residual_history = []
        self._converged = False

    def log_diagnostics(self):
        """診断情報をログ出力"""
        if self.logger:
            diag = self.get_diagnostics()
            self.logger.info(f"Poissonソルバー診断情報: {diag}")

```

### numerics/poisson/config.py

```
"""Poisson方程式ソルバーの設定を管理するモジュール

このモジュールは、Poisson方程式の数値計算パラメータを定義・管理します。
"""

from dataclasses import dataclass, field
from typing import Dict, Any
import yaml


@dataclass
class PoissonSolverConfig:
    """Poisson方程式ソルバーの数値計算パラメータ"""

    # 収束判定パラメータ
    convergence: Dict[str, Any] = field(
        default_factory=lambda: {
            "tolerance": 1e-6,
            "max_iterations": 1000,
            "relative_tolerance": False,
        }
    )

    # ソルバー固有のパラメータ
    solver_specific: Dict[str, Any] = field(
        default_factory=lambda: {
            "relaxation_parameter": 1.5,  # SORなどで使用
            "auto_tune": False,
            "method": "sor",
        }
    )

    # 診断情報の保存設定
    diagnostics: Dict[str, Any] = field(
        default_factory=lambda: {"save_residual_history": True, "log_frequency": 10}
    )

    def validate(self):
        """設定値の妥当性を検証"""
        # 収束判定パラメータの検証
        if not 0 < self.convergence.get("tolerance", 1e-6) < 1:
            raise ValueError("許容誤差は0から1の間である必要があります")

        if not isinstance(self.convergence.get("max_iterations", 1000), int):
            raise ValueError("最大反復回数は整数である必要があります")

        # ソルバー固有のパラメータ検証
        if not 0 < self.solver_specific.get("relaxation_parameter", 1.5) <= 2:
            raise ValueError("緩和パラメータは0から2の間である必要があります")

        # 有効なソルバー方法のチェック
        valid_methods = ["sor", "jacobi", "gauss_seidel"]
        if self.solver_specific.get("method") not in valid_methods:
            raise ValueError(f"無効なソルバー方法。選択肢: {valid_methods}")

    def get_config_for_component(self, component: str) -> Dict[str, Any]:
        """特定のコンポーネントの設定を取得

        Args:
            component: 設定を取得するコンポーネント名

        Returns:
            コンポーネント固有の設定
        """
        component_configs = {
            "convergence": self.convergence,
            "solver_specific": self.solver_specific,
            "diagnostics": self.diagnostics,
        }
        return component_configs.get(component, {})

    def save(self, filepath: str):
        """設定をYAMLファイルに保存

        Args:
            filepath: 保存先のパス
        """
        with open(filepath, "w", encoding="utf-8") as f:
            yaml.dump(
                {
                    "convergence": self.convergence,
                    "solver_specific": self.solver_specific,
                    "diagnostics": self.diagnostics,
                },
                f,
                default_flow_style=False,
            )

    @classmethod
    def from_yaml(cls, filepath: str) -> "PoissonSolverConfig":
        """YAMLファイルから設定を読み込む

        Args:
            filepath: 読み込むYAMLファイルのパス

        Returns:
            読み込まれた設定インスタンス
        """
        with open(filepath, "r", encoding="utf-8") as f:
            config_dict = yaml.safe_load(f)

        # 設定の検証を含めた初期化
        config = cls(
            convergence=config_dict.get("convergence", {}),
            solver_specific=config_dict.get("solver_specific", {}),
            diagnostics=config_dict.get("diagnostics", {}),
        )
        config.validate()
        return config

```

### numerics/poisson/__init__.py

```
"""Poisson方程式のソルバーパッケージ

このパッケージは、Poisson方程式を解くための各種ソルバーを提供します。
"""

from .base import (
    PoissonSolverBase,
    PoissonSolverConfig as PoissonConfig,
    PoissonSolverTerm,
)
from .solver import PoissonSolver
from .methods.sor import SORSolver

__all__ = [
    # ベースクラスとインターフェース
    "PoissonSolverBase",
    "PoissonConfig",
    "PoissonSolverTerm",
    # ソルバー
    "PoissonSolver",
    "SORSolver",
]

```

### numerics/poisson/methods/sor.py

```
"""SOR法によるPoissonソルバーを提供するモジュール

このモジュールは、Successive Over-Relaxation (SOR)法による
Poisson方程式のソルバーを実装します。
"""

import numpy as np
from typing import Optional, List, Dict, Any, Union

from physics.poisson.solver import PoissonSolver
from physics.poisson.config import PoissonSolverConfig
from core.boundary import BoundaryCondition
from ..base import PoissonSolverTerm


class SORSolver(PoissonSolver):
    """SOR法によるPoissonソルバー"""

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        boundary_conditions: Optional[List[BoundaryCondition]] = None,
        terms: Optional[List[PoissonSolverTerm]] = None,
        **kwargs,
    ):
        """SORソルバーを初期化

        Args:
            config: ソルバー設定
            boundary_conditions: 境界条件のリスト
            terms: 追加の項
            **kwargs: 追加のパラメータ
        """
        # デフォルト設定の取得
        solver_config = config or PoissonSolverConfig()
        solver_specific = solver_config.get_config_for_component("solver_specific")

        # 緩和パラメータの取得
        self.omega = kwargs.get(
            "omega", solver_specific.get("relaxation_parameter", 1.5)
        )

        # 赤黒順序付けの設定
        self.use_redblack = kwargs.get(
            "use_redblack", solver_specific.get("use_redblack", True)
        )

        # 自動調整の設定
        self.auto_tune = kwargs.get(
            "auto_tune", solver_specific.get("auto_tune", False)
        )

        # スペクトル半径の追跡
        self._spectral_radius = None
        self._update_interval = 10
        self._previous_diff = None

        # 親クラスの初期化
        super().__init__(
            config=solver_config,
            boundary_conditions=boundary_conditions,
            terms=terms,
            **kwargs,
        )

    def initialize(self, **kwargs):
        """ソルバーを初期化

        Args:
            **kwargs: 初期化に必要なパラメータ
        """
        # 基本的な初期化処理
        self.reset()  # 基底クラスのリセットメソッド

        # オプションでより詳細な初期化が必要な場合はここに追加可能
        if self.logger:
            self.logger.info("SORソルバーを初期化")

        # スペクトル半径などの追跡変数もリセット
        self._spectral_radius = None
        self._previous_diff = None

    def iterate(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> np.ndarray:
        """1回のSOR反復を実行

        Args:
            solution: 現在の解
            rhs: 右辺ベクトル
            dx: グリッド間隔

        Returns:
            更新された解
        """
        result = solution.copy()

        # dx配列の正規化と設定
        if np.isscalar(dx):
            dx = np.full(result.ndim, dx)
        elif len(dx) != result.ndim:
            raise ValueError(f"dxは{result.ndim}次元である必要があります")

        # グリッド間隔の2乗を計算
        dx_squared = np.prod(dx) ** 2

        if self.use_redblack:
            # 赤黒順序付けによる更新
            for color in [0, 1]:  # 0: 赤, 1: 黒
                # 赤黒マスクの生成
                mask = np.ones_like(result, dtype=bool)
                for axis in range(result.ndim):
                    # 各軸で交互のインデックスを選択
                    axis_indices = np.arange(result.shape[axis]) % 2 == color
                    # ブロードキャスト可能な形に変換
                    broadcast_shape = [1] * result.ndim
                    broadcast_shape[axis] = -1
                    axis_mask = axis_indices.reshape(broadcast_shape)
                    # 論理積で絞り込み
                    mask &= axis_mask

                # 近傍点の和を計算
                neighbors_sum = np.zeros_like(result)
                for axis in range(result.ndim):
                    # 各軸で前後の点を取得
                    forward = np.roll(result, 1, axis=axis)
                    backward = np.roll(result, -1, axis=axis)
                    neighbors_sum += forward + backward

                # SOR更新
                gauss_seidel = (dx_squared * rhs[mask] + neighbors_sum[mask]) / (
                    2 * result.ndim
                )
                result[mask] = (1 - self.omega) * result[
                    mask
                ] + self.omega * gauss_seidel

        else:
            # 通常のSOR反復
            for axis in range(result.ndim):
                neighbors_sum = np.roll(result, 1, axis=axis) + np.roll(
                    result, -1, axis=axis
                )
                gauss_seidel = (dx_squared * rhs + neighbors_sum) / (2 * result.ndim)
                result = (1 - self.omega) * result + self.omega * gauss_seidel

        # 境界条件の適用
        if self.boundary_conditions:
            for i, bc in enumerate(self.boundary_conditions):
                if bc is not None:
                    result = bc.apply_all(result, i)

        # 必要に応じて緩和係数を調整
        if self.auto_tune and self._iteration_count % self._update_interval == 0:
            self._update_omega(solution, result)

        return result

    def _update_omega(self, old_solution: np.ndarray, new_solution: np.ndarray):
        """緩和係数を自動調整

        Args:
            old_solution: 前回の解
            new_solution: 新しい解
        """
        # 解の変化から反復行列のスペクトル半径を推定
        diff = new_solution - old_solution
        if self._iteration_count > self._update_interval:
            old_diff = self._previous_diff
            numerator = np.sum(diff * diff)
            denominator = np.sum(old_diff * old_diff)

            if denominator > 1e-10:
                new_radius = np.sqrt(numerator / denominator)

                if self._spectral_radius is None:
                    self._spectral_radius = new_radius
                else:
                    # 指数移動平均で更新
                    alpha = 0.2
                    self._spectral_radius = (
                        1 - alpha
                    ) * self._spectral_radius + alpha * new_radius

                # 最適な緩和係数を計算
                self.omega = 2 / (1 + np.sqrt(1 - self._spectral_radius**2))

        # 現在の差分を保存
        self._previous_diff = diff.copy()

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得

        Returns:
            診断情報の辞書
        """
        diag = super().get_diagnostics()
        diag.update(
            {
                "method": "SOR",
                "omega": self.omega,
                "spectral_radius": self._spectral_radius,
                "redblack_ordering": self.use_redblack,
                "auto_tune": self.auto_tune,
            }
        )
        return diag

```

### core/boundary/dirichlet.py

```
"""ディリクレ境界条件を提供するモジュール

このモジュールは、流体シミュレーションで使用されるディリクレ境界条件を実装します。
ディリクレ境界条件では、境界上で物理量の値を指定します。
"""

import numpy as np
from .base import BoundaryCondition, StencilInfo


class DirichletBoundary(BoundaryCondition):
    """ディリクレ境界条件クラス

    ディリクレ境界条件は、境界上で物理量の値を指定します。
    壁面での速度や温度などを指定する場合に使用されます。
    """

    def __init__(self, value: float = 0.0, order: int = 2):
        """ディリクレ境界条件を初期化

        Args:
            value: 境界での値
            order: 差分近似の次数
        """
        super().__init__(order)
        self.value = value

    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """ディリクレ境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()

        # 境界面のスライスを取得
        boundary_slice = self.get_boundary_slice(field, axis, side, 1)

        # 境界値を設定
        result[boundary_slice] = self.value

        return result

    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        # 2次精度の場合
        if self.order == 2:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1, 2]),
                    coefficients=np.array([-3 / 2, 2, -1 / 2]),
                )
            else:
                return StencilInfo(
                    points=np.array([-2, -1, 0]),
                    coefficients=np.array([1 / 2, -2, 3 / 2]),
                )
        # 4次精度の場合
        elif self.order == 4:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1, 2, 3, 4]),
                    coefficients=np.array([-25 / 12, 4, -3, 4 / 3, -1 / 4]),
                )
            else:
                return StencilInfo(
                    points=np.array([-4, -3, -2, -1, 0]),
                    coefficients=np.array([1 / 4, -4 / 3, 3, -4, 25 / 12]),
                )
        else:
            raise ValueError(f"未対応の次数です: {self.order}")

```

### core/boundary/base.py

```
"""境界条件の基底クラスを提供するモジュール

このモジュールは、流体シミュレーションで使用される境界条件の基底クラスを定義します。
すべての具体的な境界条件（周期境界、ディリクレ境界など）は、この基底クラスを継承します。
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Tuple
import numpy as np


@dataclass
class StencilInfo:
    """差分ステンシルの情報を保持するクラス

    Attributes:
        points: ステンシルの位置（中心からの相対位置）
        coefficients: 各点での係数
    """

    points: np.ndarray  # 形状: (N,)
    coefficients: np.ndarray  # 形状: (N,)


class BoundaryCondition(ABC):
    """境界条件の基底クラス

    この抽象基底クラスは、すべての境界条件に共通のインターフェースを定義します。
    """

    def __init__(self, order: int = 2):
        """境界条件を初期化

        Args:
            order: 差分近似の次数（デフォルトは2次精度）
        """
        self.order = order

    @abstractmethod
    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        pass

    @abstractmethod
    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        pass

    def validate_field(self, field: np.ndarray, axis: int) -> None:
        """場の妥当性をチェック

        Args:
            field: チェックする場
            axis: チェックする軸

        Raises:
            ValueError: 無効な場や軸が指定された場合
        """
        if not isinstance(field, np.ndarray):
            raise ValueError("fieldはnumpy配列である必要があります")
        if not 0 <= axis < field.ndim:
            raise ValueError(f"無効な軸です: {axis}")

    def apply_all(self, field: np.ndarray, axis: int) -> np.ndarray:
        """両側の境界に境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()

        # 負側の境界に適用
        result = self.apply(result, axis, 0)

        # 正側の境界に適用
        result = self.apply(result, axis, 1)

        return result

    def get_boundary_slice(
        self, field: np.ndarray, axis: int, side: int, width: int
    ) -> Tuple[slice, ...]:
        """境界領域のスライスを取得

        Args:
            field: 対象の場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）
            width: 境界領域の幅

        Returns:
            境界領域を選択するスライスのタプル
        """
        slices = [slice(None)] * field.ndim
        if side == 0:
            slices[axis] = slice(0, width)
        else:
            slices[axis] = slice(-width, None)
        return tuple(slices)

    def get_ghost_points(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """ゴースト点の座標を取得

        Args:
            field: 対象の場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ゴースト点の座標配列
        """
        # ステンシル情報から必要なゴースト点の数を決定
        stencil = self.get_stencil(side)
        n_ghost = len(stencil.points)

        # 境界に沿った座標グリッドを生成
        shape = list(field.shape)
        shape[axis] = n_ghost
        coordinates = np.empty(shape + [field.ndim])

        # 各次元の座標を設定
        for dim in range(field.ndim):
            if dim == axis:
                if side == 0:
                    coords = np.arange(-n_ghost, 0)
                else:
                    coords = np.arange(field.shape[axis], field.shape[axis] + n_ghost)
            else:
                coords = np.arange(field.shape[dim])
            coordinates[..., dim] = coords

        return coordinates

```

### core/boundary/periodic.py

```
"""周期境界条件を提供するモジュール

このモジュールは、流体シミュレーションで使用される周期境界条件を実装します。
周期境界条件では、計算領域の両端が接続されているとして扱います。
"""

import numpy as np
from .base import BoundaryCondition, StencilInfo


class PeriodicBoundary(BoundaryCondition):
    """周期境界条件クラス

    周期境界条件は、計算領域の両端が接続されているとして扱います。
    物理量は領域の境界で連続的に繰り返されます。
    """

    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """周期境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()

        # ステンシル情報から必要なゴースト点の数を決定
        stencil = self.get_stencil(side)
        n_ghost = len(stencil.points)

        # 境界領域のスライスを取得
        ghost_slice = self.get_boundary_slice(field, axis, side, n_ghost)

        # 反対側の内部領域から値をコピー
        if side == 0:  # 負側の境界
            source_slice = self.get_boundary_slice(field, axis, 1, n_ghost)
            result[ghost_slice] = field[source_slice]
        else:  # 正側の境界
            source_slice = self.get_boundary_slice(field, axis, 0, n_ghost)
            result[ghost_slice] = field[source_slice]

        return result

    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        # 2次精度中心差分の場合
        if self.order == 2:
            return StencilInfo(
                points=np.array([-1, 0, 1]), coefficients=np.array([-0.5, 0.0, 0.5])
            )
        # 4次精度中心差分の場合
        elif self.order == 4:
            return StencilInfo(
                points=np.array([-2, -1, 0, 1, 2]),
                coefficients=np.array([1 / 12, -2 / 3, 0, 2 / 3, -1 / 12]),
            )
        else:
            raise ValueError(f"未対応の次数です: {self.order}")

```

### core/boundary/neumann.py

```
"""ノイマン境界条件を提供するモジュール

このモジュールは、流体シミュレーションで使用されるノイマン境界条件を実装します。
ノイマン境界条件では、境界上で物理量の勾配を指定します。
"""

import numpy as np
from .base import BoundaryCondition, StencilInfo


class NeumannBoundary(BoundaryCondition):
    """ノイマン境界条件クラス

    ノイマン境界条件は、境界上で物理量の勾配を指定します。
    断熱壁や流出境界などで使用されます。
    """

    def __init__(self, gradient: float = 0.0, order: int = 2):
        """ノイマン境界条件を初期化

        Args:
            gradient: 境界での勾配
            order: 差分近似の次数
        """
        super().__init__(order)
        self.gradient = gradient

    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """ノイマン境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()
        dx = 1.0  # 正規化された格子間隔

        # 境界近傍の値を取得
        if side == 0:  # 負側の境界
            interior_slice = self.get_boundary_slice(field, axis, 1, 1)
            interior_value = field[interior_slice]
            # 勾配条件に基づいて境界値を設定
            boundary_slice = self.get_boundary_slice(field, axis, 0, 1)
            result[boundary_slice] = interior_value - self.gradient * dx
        else:  # 正側の境界
            interior_slice = self.get_boundary_slice(field, axis, 0, 1)
            interior_value = field[interior_slice]
            # 勾配条件に基づいて境界値を設定
            boundary_slice = self.get_boundary_slice(field, axis, 1, 1)
            result[boundary_slice] = interior_value + self.gradient * dx

        return result

    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        # 2次精度の場合
        if self.order == 2:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1]), coefficients=np.array([-1.0, 1.0])
                )
            else:
                return StencilInfo(
                    points=np.array([-1, 0]), coefficients=np.array([-1.0, 1.0])
                )
        # 4次精度の場合
        elif self.order == 4:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1, 2, 3]),
                    coefficients=np.array([-11 / 6, 3, -3 / 2, 1 / 3]),
                )
            else:
                return StencilInfo(
                    points=np.array([-3, -2, -1, 0]),
                    coefficients=np.array([-1 / 3, 3 / 2, -3, 11 / 6]),
                )
        else:
            raise ValueError(f"未対応の次数です: {self.order}")

```

### core/boundary/__init__.py

```
"""境界条件パッケージ

このパッケージは、流体シミュレーションで使用される各種境界条件を提供します。
"""

from .base import BoundaryCondition, StencilInfo
from .periodic import PeriodicBoundary
from .dirichlet import DirichletBoundary
from .neumann import NeumannBoundary

__all__ = [
    "BoundaryCondition",
    "StencilInfo",
    "PeriodicBoundary",
    "DirichletBoundary",
    "NeumannBoundary",
]

```

### core/solver/base.py

```
"""ソルバーの基底クラスを提供するモジュール

このモジュールは、数値解法の基底となる抽象クラスを定義します。
全ての具体的なソルバーはこの基底クラスを継承します。
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from datetime import datetime


class Solver(ABC):
    """ソルバーの基底クラス

    この抽象基底クラスは、全てのソルバーに共通のインターフェースと
    基本機能を提供します。
    """

    def __init__(
        self,
        name: str,
        tolerance: float = 1e-6,
        max_iterations: int = 1000,
        logger=None,
        **extra_kwargs,  # 追加のキーワード引数を許可
    ):
        """ソルバーを初期化

        Args:
            name: ソルバーの名前
            tolerance: 収束判定の許容誤差
            max_iterations: 最大反復回数
            logger: ロガー（オプション）
            **extra_kwargs: 追加のキーワード引数（柔軟性のため）
        """
        self.name = name
        self._tolerance = tolerance
        self._max_iterations = max_iterations
        self._iteration_count = 0
        self._residual_history = []
        self._start_time = None
        self._end_time = None
        self._logger = logger

        # 追加のキーワード引数を属性として保存（必要に応じて）
        for key, value in extra_kwargs.items():
            setattr(self, f"_{key}", value)

    @property
    def tolerance(self) -> float:
        """収束判定の許容誤差を取得"""
        return self._tolerance

    @tolerance.setter
    def tolerance(self, value: float):
        """収束判定の許容誤差を設定"""
        if value <= 0:
            raise ValueError("許容誤差は正の値である必要があります")
        self._tolerance = value

    @property
    def max_iterations(self) -> int:
        """最大反復回数を取得"""
        return self._max_iterations

    @max_iterations.setter
    def max_iterations(self, value: int):
        """最大反復回数を設定"""
        if value <= 0:
            raise ValueError("最大反復回数は正の整数である必要があります")
        self._max_iterations = value

    @property
    def iteration_count(self) -> int:
        """現在の反復回数を取得"""
        return self._iteration_count

    @property
    def residual_history(self) -> list:
        """残差の履歴を取得"""
        return self._residual_history.copy()

    @property
    def elapsed_time(self) -> Optional[float]:
        """計算経過時間を取得（秒）"""
        if self._start_time is None:
            return None
        end_time = self._end_time or datetime.now()
        return (end_time - self._start_time).total_seconds()

    @abstractmethod
    def initialize(self, **kwargs) -> None:
        """ソルバーの初期化"""
        pass

    @abstractmethod
    def solve(self, **kwargs) -> Dict[str, Any]:
        """ソルバーを実行"""
        pass

    def reset(self):
        """ソルバーの状態をリセット"""
        self._iteration_count = 0
        self._residual_history = []
        self._start_time = None
        self._end_time = None

    def _start_solving(self):
        """計算開始時の処理"""
        self.reset()
        self._start_time = datetime.now()
        if self._logger:
            self._logger.info(f"{self.name}ソルバーの計算を開始")

    def _end_solving(self):
        """計算終了時の処理"""
        self._end_time = datetime.now()
        if self._logger:
            self._logger.info(
                f"{self.name}ソルバーの計算を終了 (経過時間: {self.elapsed_time:.2f}秒)"
            )

    def get_status(self) -> Dict[str, Any]:
        """ソルバーの現在の状態を取得"""
        return {
            "name": self.name,
            "iteration_count": self.iteration_count,
            "residual": self._residual_history[-1] if self._residual_history else None,
            "elapsed_time": self.elapsed_time,
        }

    def __str__(self) -> str:
        """ソルバーの文字列表現を取得"""
        status = self.get_status()
        return (
            f"Solver: {status['name']}\n"
            f"Iterations: {status['iteration_count']}\n"
            f"Current Residual: {status['residual']}\n"
            f"Elapsed Time: {status['elapsed_time']:.2f}s"
        )

```

### core/solver/temporal.py

```
"""時間発展ソルバーの基底クラスを提供するモジュール

このモジュールは、時間発展問題を解くためのソルバーの基底クラスを定義します。
"""

from abc import abstractmethod
from typing import Dict, Any, Optional
from .base import Solver


class TemporalSolver(Solver):
    """時間発展ソルバーの基底クラス"""

    def __init__(
        self,
        name: str,
        cfl: float = 0.5,
        min_dt: float = 1e-6,
        max_dt: float = 1.0,
        tolerance: float = 1e-6,
        max_iterations: int = 1000,
        logger=None,
    ):
        """時間発展ソルバーを初期化"""
        super().__init__(
            name=name, tolerance=tolerance, max_iterations=max_iterations, logger=logger
        )
        self._time = 0.0
        self._dt = None
        self._cfl = cfl
        self._min_dt = min_dt
        self._max_dt = max_dt
        self._time_history = []

    @property
    def time(self) -> float:
        """現在の時刻を取得"""
        return self._time

    @property
    def dt(self) -> Optional[float]:
        """時間刻み幅を取得"""
        return self._dt

    @property
    def cfl(self) -> float:
        """CFL数を取得"""
        return self._cfl

    @cfl.setter
    def cfl(self, value: float):
        """CFL数を設定"""
        if value <= 0:
            raise ValueError("CFL数は正の値である必要があります")
        self._cfl = value

    @abstractmethod
    def compute_timestep(self, **kwargs) -> float:
        """時間刻み幅を計算"""
        pass

    @abstractmethod
    def advance(self, dt: float, **kwargs) -> Dict[str, Any]:
        """1時間ステップ進める"""
        pass

```

### core/solver/iterative.py

```
"""反復法ソルバーの基底クラスを提供するモジュール

このモジュールは、反復法による方程式求解のための基底クラスを定義します。
"""

from abc import abstractmethod
from typing import Dict, Any
import numpy as np
from .base import Solver


class IterativeSolver(Solver):
    """反復法ソルバーの基底クラス

    この抽象基底クラスは、反復法による求解を行うソルバーに共通の
    機能を提供します。
    """

    def __init__(self, name: str, omega: float = 1.0, **kwargs):
        """反復法ソルバーを初期化

        Args:
            name: ソルバーの名前
            omega: 緩和係数
            **kwargs: 基底クラスに渡すパラメータ
        """
        super().__init__(name, **kwargs)
        self._omega = omega
        self._initial_residual = None
        self._convergence_history = []

    @property
    def omega(self) -> float:
        """緩和係数を取得"""
        return self._omega

    @omega.setter
    def omega(self, value: float):
        """緩和係数を設定

        Args:
            value: 設定する緩和係数

        Raises:
            ValueError: 不適切な値が指定された場合
        """
        if value <= 0 or value > 2:
            raise ValueError("緩和係数は0から2の間である必要があります")
        self._omega = value

    @abstractmethod
    def compute_residual(self, solution: np.ndarray, **kwargs) -> float:
        """残差を計算

        Args:
            solution: 現在の解
            **kwargs: 計算に必要なパラメータ

        Returns:
            計算された残差
        """
        pass

    @abstractmethod
    def iterate(self, solution: np.ndarray, **kwargs) -> np.ndarray:
        """1回の反復を実行

        Args:
            solution: 現在の解
            **kwargs: 計算に必要なパラメータ

        Returns:
            更新された解
        """
        pass

    def check_convergence(self, residual: float) -> bool:
        """収束判定

        Args:
            residual: 現在の残差

        Returns:
            収束したかどうか
        """
        # 初回の残差を記録
        if self._initial_residual is None:
            self._initial_residual = residual
            return False

        # 初期残差が非常に小さい場合の特別な処理
        if self._initial_residual < 1e-15:
            return residual < 1e-10

        # 相対残差による収束判定
        relative_residual = residual / self._initial_residual
        self._convergence_history.append(relative_residual)

        # 相対残差と絶対残差の両方でチェック
        return (relative_residual < self.tolerance) and (residual < 1e-10)

    def solve(self, initial_solution: np.ndarray, **kwargs) -> Dict[str, Any]:
        """反復法で方程式を解く

        Args:
            initial_solution: 初期推定解
            **kwargs: 計算に必要なパラメータ

        Returns:
            計算結果と統計情報を含む辞書

        Raises:
            RuntimeError: 最大反復回数に達しても収束しない場合
        """
        self._start_solving()

        # 初期解のコピー
        solution = initial_solution.copy()

        # 初期残差の計算
        self._initial_residual = self.compute_residual(solution, **kwargs)
        self._residual_history.append(self._initial_residual)

        while self._iteration_count < self.max_iterations:
            # 1回の反復
            solution = self.iterate(solution, **kwargs)

            # 残差の計算
            residual = self.compute_residual(solution, **kwargs)
            self._residual_history.append(residual)

            # 反復回数の更新
            self._iteration_count += 1

            # 収束判定
            if self.check_convergence(residual):
                self._end_solving()
                return {
                    "solution": solution,
                    "converged": True,
                    "iterations": self._iteration_count,
                    "residual": residual,
                    "convergence_history": self._convergence_history,
                    "elapsed_time": self.elapsed_time,
                }

        self._end_solving()
        raise RuntimeError(
            f"ソルバーが収束しませんでした: 残差 = {residual}, "
            f"相対残差 = {residual / self._initial_residual}"
        )

    def get_status(self) -> Dict[str, Any]:
        """ソルバーの状態を取得"""
        status = super().get_status()
        status.update(
            {
                "omega": self._omega,
                "initial_residual": self._initial_residual,
                "current_convergence": self._convergence_history[-1]
                if self._convergence_history
                else None,
            }
        )
        return status

```

### core/solver/__init__.py

```
"""ソルバーパッケージ

このパッケージは、数値計算のための様々なソルバーの基底クラスを提供します。
"""

from .base import Solver
from .temporal import TemporalSolver
from .iterative import IterativeSolver

__all__ = ["Solver", "TemporalSolver", "IterativeSolver"]

```

### core/field/scalar.py

```
"""スカラー場クラスを提供するモジュール

このモジュールは、スカラー量（圧力、温度など）を表現するための場のクラスを定義します。
"""

from typing import Tuple, Optional
import numpy as np
from .field import Field
from typing import Dict, Any


class ScalarField(Field):
    """スカラー場クラス

    温度、圧力などのスカラー量を表現するためのクラスです。
    基本的な微分演算や補間機能を提供します。
    """

    def __init__(
        self, shape: Tuple[int, ...], dx: float = 1.0, initial_value: float = 0.0
    ):
        """スカラー場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔
            initial_value: 初期値
        """
        super().__init__(shape, dx)
        if initial_value != 0.0:
            self._data.fill(initial_value)

    def interpolate(self, points: np.ndarray) -> np.ndarray:
        """任意の点での値を線形補間

        Args:
            points: 補間点の座標 (N, ndim)

        Returns:
            補間された値 (N,)
        """
        # 各次元のインデックスと重みを計算
        indices = []
        weights = []

        for dim in range(self.ndim):
            # 座標をインデックスに変換
            idx = points[:, dim] / self._dx
            idx0 = np.floor(idx).astype(int)
            idx1 = idx0 + 1
            w1 = idx - idx0
            w0 = 1.0 - w1

            # 境界条件の適用
            idx0 = np.clip(idx0, 0, self.shape[dim] - 1)
            idx1 = np.clip(idx1, 0, self.shape[dim] - 1)

            indices.append((idx0, idx1))
            weights.append((w0, w1))

        # 全ての隣接点での重み付き和を計算
        result = np.zeros(len(points))
        for i in range(2**self.ndim):
            # i のビット表現から各次元でのインデックスを決定
            idx = []
            w = 1.0
            for d in range(self.ndim):
                bit = (i >> d) & 1
                idx.append(indices[d][bit])
                w *= weights[d][bit]

            # インデックスでの値を重み付きで加算
            result += w * self._data[tuple(idx)]

        return result

    def integrate(self) -> float:
        """場の積分値を計算"""
        return np.sum(self._data) * self._dx**self.ndim

    def mean(self) -> float:
        """場の平均値を計算"""
        return np.mean(self._data)

    def min(self) -> float:
        """場の最小値を取得"""
        return np.min(self._data)

    def max(self) -> float:
        """場の最大値を取得"""
        return np.max(self._data)

    def normalize(self):
        """場を正規化

        場の値を[0, 1]の範囲に正規化します。
        """
        min_val = self.min()
        max_val = self.max()
        if max_val > min_val:
            self._data = (self._data - min_val) / (max_val - min_val)

    def clip(self, min_val: Optional[float] = None, max_val: Optional[float] = None):
        """場の値を指定範囲に制限

        Args:
            min_val: 最小値（Noneの場合は制限なし）
            max_val: 最大値（Noneの場合は制限なし）
        """
        self._data = np.clip(self._data, min_val, max_val)

    def smooth(self, sigma: float = 1.0):
        """場をガウシアンフィルタで平滑化

        Args:
            sigma: ガウシアンフィルタの標準偏差
        """
        from scipy.ndimage import gaussian_filter

        self._data = gaussian_filter(self._data, sigma)

    def __add__(self, other):
        """加算演算子の実装"""
        result = self.__class__(self.shape, self.dx)
        if isinstance(other, (int, float)):
            result.data = self.data + other
        elif isinstance(other, ScalarField):
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result.data = self.data + other.data
        else:
            raise TypeError("無効な型との演算です")
        return result

    def __mul__(self, other):
        """乗算演算子の実装"""
        result = self.__class__(self.shape, self.dx)
        if isinstance(other, (int, float)):
            result.data = self.data * other
        elif isinstance(other, ScalarField):
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result.data = self.data * other.data
        else:
            raise TypeError("無効な型との演算です")
        return result

    def __rmul__(self, other):
        """右乗算演算子の実装"""
        return self.__mul__(other)

    def __truediv__(self, other):
        """除算演算子の実装"""
        result = self.__class__(self.shape, self.dx)
        if isinstance(other, (int, float)):
            result.data = self.data / other
        elif isinstance(other, ScalarField):
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result.data = self.data / other.data
        else:
            raise TypeError("無効な型との演算です")
        return result

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        return {
            "data": self.data.copy(),
            "shape": self.shape,
            "dx": self.dx,
            "time": self.time,
        }

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        # データの復元
        if tuple(state["shape"]) != self.shape:
            raise ValueError("形状が一致しません")

        self.data = state["data"].copy()

        # 時刻の復元
        self.time = state.get("time", 0.0)

        # グリッド間隔の確認（必要に応じて）
        if abs(state["dx"] - self.dx) > 1e-10:
            raise ValueError("グリッド間隔が一致しません")

```

### core/field/vector.py

```
"""ベクトル場クラスを提供するモジュール

このモジュールは、ベクトル量（速度、運動量など）を表現するためのベクトル場クラスを定義します。
"""

from typing import List, Tuple, Optional
import numpy as np
from .scalar import ScalarField
from typing import Dict, Any


class VectorField:
    """ベクトル場クラス

    速度、運動量などのベクトル量を表現するためのクラスです。
    各成分をスカラー場として保持し、ベクトル演算のメソッドを提供します。
    """

    def __init__(self, shape: Tuple[int, ...], dx: float = 1.0):
        """ベクトル場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔
        """
        self._components = [ScalarField(shape, dx) for _ in range(len(shape))]
        self._shape = shape
        self._dx = dx

    @property
    def components(self) -> List[ScalarField]:
        """ベクトル場の各成分を取得"""
        return self._components

    @property
    def shape(self) -> Tuple[int, ...]:
        """場の形状を取得"""
        return self._shape

    @property
    def dx(self) -> float:
        """グリッド間隔を取得"""
        return self._dx

    @property
    def ndim(self) -> int:
        """次元数を取得"""
        return len(self._shape)

    def magnitude(self) -> ScalarField:
        """ベクトル場の大きさを計算

        Returns:
            計算されたベクトルの大きさを表すスカラー場
        """
        result = ScalarField(self.shape, self.dx)
        result.data = np.sqrt(sum(c.data**2 for c in self._components))
        return result

    def divergence(self) -> ScalarField:
        """発散を計算

        Returns:
            計算された発散を表すスカラー場
        """
        result = ScalarField(self.shape, self.dx)
        result.data = sum(c.gradient(i) for i, c in enumerate(self._components))
        return result

    def curl(self) -> Optional["VectorField"]:
        """回転を計算

        Returns:
            3次元の場合は計算された回転を表すベクトル場
            2次元の場合はNone
        """
        if self.ndim != 3:
            return None

        result = VectorField(self.shape, self.dx)
        u, v, w = [c.data for c in self._components]

        # ∂w/∂y - ∂v/∂z
        result.components[0].data = np.gradient(w, self.dx, axis=1) - np.gradient(
            v, self.dx, axis=2
        )
        # ∂u/∂z - ∂w/∂x
        result.components[1].data = np.gradient(u, self.dx, axis=2) - np.gradient(
            w, self.dx, axis=0
        )
        # ∂v/∂x - ∂u/∂y
        result.components[2].data = np.gradient(v, self.dx, axis=0) - np.gradient(
            u, self.dx, axis=1
        )

        return result

    def integrate(self) -> float:
        """場の積分値を計算

        Returns:
            各成分の積分値の二乗和の平方根
        """
        return np.sqrt(sum(c.integrate() ** 2 for c in self._components))

    def copy(self) -> "VectorField":
        """場の深いコピーを作成

        Returns:
            コピーされた場
        """
        result = VectorField(self.shape, self.dx)
        for i, component in enumerate(self._components):
            result.components[i] = component.copy()
        return result

    def __add__(self, other: "VectorField") -> "VectorField":
        """加算演算子の実装"""
        if not isinstance(other, VectorField):
            raise TypeError("ベクトル場同士の演算のみ可能です")
        if self.shape != other.shape:
            raise ValueError("場の形状が一致しません")

        result = VectorField(self.shape, self.dx)
        for i, (c1, c2) in enumerate(zip(self.components, other.components)):
            result.components[i] = c1 + c2
        return result

    def __mul__(self, other) -> "VectorField":
        """スカラー倍の実装"""
        if not isinstance(other, (int, float)):
            raise TypeError("スカラー倍のみ可能です")

        result = VectorField(self.shape, self.dx)
        for i, component in enumerate(self.components):
            result.components[i] = component * other
        return result

    def __rmul__(self, other) -> "VectorField":
        """右スカラー倍の実装"""
        return self.__mul__(other)

    def dot(self, other: "VectorField") -> ScalarField:
        """内積を計算

        Args:
            other: 内積を取るベクトル場

        Returns:
            計算された内積を表すスカラー場
        """
        if not isinstance(other, VectorField):
            raise TypeError("ベクトル場同士の演算のみ可能です")
        if self.shape != other.shape:
            raise ValueError("場の形状が一致しません")

        result = ScalarField(self.shape, self.dx)
        result.data = sum(
            c1.data * c2.data for c1, c2 in zip(self.components, other.components)
        )
        return result

    def cross(self, other: "VectorField") -> Optional["VectorField"]:
        """外積を計算（3次元のみ）

        Args:
            other: 外積を取るベクトル場

        Returns:
            3次元の場合は計算された外積を表すベクトル場
            2次元の場合はNone
        """
        if self.ndim != 3:
            return None
        if not isinstance(other, VectorField):
            raise TypeError("ベクトル場同士の演算のみ可能です")
        if self.shape != other.shape:
            raise ValueError("場の形状が一致しません")

        result = VectorField(self.shape, self.dx)
        u1, v1, w1 = [c.data for c in self.components]
        u2, v2, w2 = [c.data for c in other.components]

        result.components[0].data = v1 * w2 - w1 * v2
        result.components[1].data = w1 * u2 - u1 * w2
        result.components[2].data = u1 * v2 - v1 * u2

        return result

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        return {
            "components": [comp.save_state() for comp in self.components],
            "shape": self.shape,
            "dx": self.dx,
        }

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        # コンポーネントの復元
        if len(state["components"]) != len(self.components):
            raise ValueError("コンポーネントの数が一致しません")

        for i, comp_state in enumerate(state["components"]):
            self.components[i].load_state(comp_state)

        # その他の属性の確認（必要に応じて）
        if tuple(state["shape"]) != self.shape:
            raise ValueError("形状が一致しません")

        # dx値の確認は省略可（必要に応じて追加）

```

### core/field/conserved.py

```
"""保存則を持つ場のクラスを提供するモジュール

このモジュールは、保存則を持つ場（質量、運動量など）の基底クラスを定義します。
"""

from typing import Dict, Any
import numpy as np
from .field import Field


class ConservedField(Field):
    """保存則を持つ場の基底クラス

    この基底クラスは、保存則を持つ物理量（質量、運動量など）の場に共通の
    機能を提供します。初期状態の積分値を保持し、保存則の検証を可能にします。

    Attributes:
        initial_integral (float): 初期状態での積分値
    """

    def __init__(self, *args, **kwargs):
        """保存則を持つ場を初期化

        Args:
            *args: Field.__init__に渡される位置引数
            **kwargs: Field.__init__に渡されるキーワード引数
        """
        super().__init__(*args, **kwargs)
        self._initial_integral = self.integrate()

    def integrate(self) -> float:
        """場の積分値を計算

        空間全体にわたる場の積分値を計算します。

        Returns:
            計算された積分値
        """
        return np.sum(self._data) * self._dx**self.ndim

    def check_conservation(self) -> float:
        """保存則の確認

        現在の積分値と初期積分値を比較し、相対誤差を計算します。

        Returns:
            保存則の相対誤差
        """
        current_integral = self.integrate()
        if abs(self._initial_integral) < 1e-10:  # ゼロ除算を防ぐ
            return 0.0 if abs(current_integral) < 1e-10 else float("inf")
        return abs(current_integral - self._initial_integral) / abs(
            self._initial_integral
        )

    def reset_reference(self):
        """参照積分値をリセット

        現在の状態を新しい参照状態として設定します。
        """
        self._initial_integral = self.integrate()

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        state = super().save_state()
        state["initial_integral"] = self._initial_integral
        return state

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        super().load_state(state)
        self._initial_integral = state["initial_integral"]

    @property
    def conservation_error(self) -> float:
        """保存則の誤差を取得"""
        return self.check_conservation()

    @property
    def initial_integral(self) -> float:
        """初期積分値を取得"""
        return self._initial_integral

```

### core/field/field.py

```
"""場の基底クラスを提供するモジュール

このモジュールは流体シミュレーションで使用される場の基底クラスを定義します。
すべての具体的な場の実装（スカラー場、ベクトル場など）は、この基底クラスを継承します。
"""

from abc import ABC, abstractmethod
from typing import Tuple, Dict, Any
import numpy as np


class Field(ABC):
    """場の基底クラス

    この抽象基底クラスは、流体シミュレーションで使用される全ての場に共通の
    インターフェースと基本機能を提供します。

    Attributes:
        shape (Tuple[int, ...]): グリッドの形状
        dx (float): グリッド間隔
        time (float): 現在の時刻
    """

    def __init__(self, shape: Tuple[int, ...], dx: float = 1.0):
        """場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔
        """
        self._data = np.zeros(shape)
        self._dx = dx
        self._time = 0.0

    @property
    def data(self) -> np.ndarray:
        """場のデータを取得"""
        return self._data

    @data.setter
    def data(self, value: np.ndarray):
        """場のデータを設定

        Args:
            value: 設定するデータ配列

        Raises:
            ValueError: データの形状が不一致の場合
        """
        if value.shape != self._data.shape:
            raise ValueError(f"形状が一致しません: {value.shape} != {self._data.shape}")
        self._data = value.copy()  # 防御的コピー

    @property
    def shape(self) -> Tuple[int, ...]:
        """場の形状を取得"""
        return self._data.shape

    @property
    def ndim(self) -> int:
        """次元数を取得"""
        return self._data.ndim

    @property
    def dx(self) -> float:
        """グリッド間隔を取得"""
        return self._dx

    @property
    def time(self) -> float:
        """現在の時刻を取得"""
        return self._time

    @time.setter
    def time(self, value: float):
        """時刻を設定

        Args:
            value: 設定する時刻

        Raises:
            ValueError: 負の時刻が指定された場合
        """
        if value < 0:
            raise ValueError("時刻は非負である必要があります")
        self._time = value

    def gradient(self, axis: int) -> np.ndarray:
        """指定軸方向の勾配を計算

        中心差分による2次精度の勾配計算を行います。

        Args:
            axis: 勾配を計算する軸のインデックス

        Returns:
            計算された勾配
        """
        return np.gradient(self._data, self._dx, axis=axis)

    def laplacian(self) -> np.ndarray:
        """ラプラシアンを計算

        中心差分による2次精度のラプラシアン計算を行います。

        Returns:
            計算されたラプラシアン
        """
        return sum(
            np.gradient(np.gradient(self._data, self._dx, axis=i), self._dx, axis=i)
            for i in range(self.ndim)
        )

    def copy(self) -> "Field":
        """場の深いコピーを作成

        Returns:
            コピーされた場
        """
        new_field = self.__class__(self.shape, self.dx)
        new_field.data = self.data.copy()
        new_field.time = self.time
        return new_field

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        return {"data": self._data.copy(), "time": self._time, "dx": self._dx}

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        self._data = state["data"].copy()
        self._time = state["time"]
        self._dx = state["dx"]

    @abstractmethod
    def integrate(self) -> float:
        """場の積分値を計算

        Returns:
            計算された積分値
        """
        pass

```

### core/field/__init__.py

```
# core/__init__.py
from .field import Field
from .scalar import ScalarField
from .vector import VectorField
from .conserved import ConservedField

__all__ = ["Field", "ScalarField", "VectorField", "ConservedField"]

# プロジェクトのディレクトリ構造:
"""
project_root/
├── core/
│   ├── __init__.py
│   ├── field.py      # 基底Field クラス
│   ├── scalar.py     # ScalarField クラス
│   ├── vector.py     # VectorField クラス
│   └── conserved.py  # ConservedField クラス
├── simulations/
│   ├── __init__.py
│   ├── state.py
│   └── ...
└── main.py
"""

```

### main.py

```
import sys
import argparse
import yaml
from pathlib import Path
from logger import SimulationLogger, LogConfig
from simulations import SimulationManager, SimulationInitializer
from visualization import visualize_simulation_state


def parse_args():
    """コマンドライン引数をパース"""
    parser = argparse.ArgumentParser(description="二相流シミュレーション")
    parser.add_argument("--config", type=str, required=True, help="設定ファイルのパス")
    parser.add_argument("--checkpoint", type=str, help="チェックポイントファイルのパス")
    parser.add_argument("--debug", action="store_true", help="デバッグモードを有効化")
    return parser.parse_args()


def load_config(config_path: str) -> dict:
    """設定ファイルを読み込み"""
    with open(config_path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def setup_logging(config: dict, debug: bool) -> SimulationLogger:
    """ロギングを設定"""
    # デバッグモードでない場合は、情報レベルのログを抑制
    log_level = "debug" if debug else "warning"
    log_dir = Path(config.get("visualization", {}).get("output_dir", "results"))
    log_dir.mkdir(parents=True, exist_ok=True)
    return SimulationLogger("TwoPhaseFlow", LogConfig(level=log_level, log_dir=log_dir))


def initialize_simulation(
    config: dict, logger: SimulationLogger, checkpoint: Path = None
):
    """シミュレーションを初期化"""
    output_dir = Path(config["visualization"]["output_dir"])
    output_dir.mkdir(parents=True, exist_ok=True)

    if checkpoint:
        logger.info(f"チェックポイントから再開: {checkpoint}")
        initializer = SimulationInitializer(config, logger)
        runner, state = initializer.load_checkpoint(checkpoint)
    else:
        logger.info("新規シミュレーションを開始")
        initializer = SimulationInitializer(config, logger)
        state = initializer.create_initial_state()
        manager = SimulationManager(config, logger)
        runner = manager.runner
        runner.initialize(state)

    # 初期状態の可視化
    visualize_simulation_state(state, config, timestamp=0.0)

    return runner, state


def run_simulation(runner, initial_state, config, logger):
    """シミュレーションを実行"""
    # シミュレーションパラメータの取得
    save_interval = config["numerical"].get("save_interval", 0.1)
    max_time = config["numerical"].get("max_time", 1.0)
    output_dir = Path(config["visualization"]["output_dir"])

    current_time = 0.0
    next_save_time = save_interval

    logger.info(
        f"シミュレーションを開始: max_time = {max_time}, save_interval = {save_interval}"
    )

    while current_time < max_time:
        try:
            # 時間発展の実行
            state, step_info = runner.step_forward()
            current_time = step_info["time"]

            # 結果の可視化と保存
            if current_time >= next_save_time:
                visualize_simulation_state(state, config, timestamp=current_time)
                checkpoint_path = output_dir / f"checkpoint_{current_time:.3f}.npz"
                runner.save_checkpoint(checkpoint_path)
                next_save_time += save_interval

            # ログに進捗を出力
            logger.info(
                f"Time: {current_time:.3f}/{max_time:.1f} "
                f"(dt={step_info['dt']:.3e}), "
                f"Diagnostics: {step_info['diagnostics']}"
            )

        except Exception as e:
            logger.error(f"シミュレーションステップ中にエラー: {e}")
            break

    # シミュレーション終了処理
    runner.finalize(output_dir)
    logger.info("シミュレーション正常終了")


def main():
    """メイン関数"""
    # コマンドライン引数の解析
    args = parse_args()

    # 設定ファイルの読み込み
    config = load_config(args.config)

    # ロガーの設定
    logger = setup_logging(config, args.debug)

    # チェックポイントファイルのパス
    checkpoint = Path(args.checkpoint) if args.checkpoint else None

    try:
        # シミュレーションの初期化
        runner, initial_state = initialize_simulation(config, logger, checkpoint)

        # シミュレーションの実行
        run_simulation(runner, initial_state, config, logger)

        return 0

    except Exception as e:
        logger.error(f"シミュレーション中にエラーが発生: {e}")
        import traceback

        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())

```

### config.yaml

```
# Two-phase flow simulation configuration

# 物理パラメータ
physics:
  gravity: 9.81  # 重力加速度 [m/s²]
  surface_tension: 0.072  # 表面張力係数 [N/m]

# 相の物性値
phases:
  water:
    density: 1000.0  # 密度 [kg/m³]
    viscosity: 1.0e-3  # 動粘性係数 [Pa·s]
    surface_tension: 0.07  # 表面張力係数 [N/m]
  nitrogen:
    density: 1.25  # 密度 [kg/m³]
    viscosity: 1.81e-5  # 動粘性係数 [Pa·s]
    surface_tension: 0.0  # 表面張力係数 [N/m]

# 計算領域の設定
domain:
  dimensions: [32, 32, 32]  # X, Y, Z方向のグリッドポイント数
  size: [1.0, 1.0, 1.0]  # X, Y, Z方向の物理的サイズ [m]

# 境界条件
boundary_conditions:
  x: 
    left: periodic
    right: periodic
  y: 
    front: periodic
    back: periodic
  z: 
    bottom: neumann
    top: neumann

# 初期条件
initial_conditions:
  background:
    phase: water
    height_fraction: 0.80

  objects:
    - type: sphere
      phase: nitrogen
      center: [0.5, 0.5, 0.4]
      radius: 0.2

  velocity:
    type: zero

# 数値スキーム
numerical:
  time_integrator: "euler"  # または "rk4"
  max_time: 2.0
  initial_dt: 0.001
  save_interval: 0.01

  level_set:
    epsilon: 1.0e-2
    reinit_interval: 5
    reinit_steps: 2

# 可視化設定
output:
  output_dir: "results/visualization"
  format: "png"  # 出力フォーマット
  dpi: 300       # 解像度
  colormap: "viridis"  # デフォルトのカラーマップ
  show_colorbar: true  # カラーバーの表示
  show_axes: true      # 軸の表示
  show_grid: false     # グリッドの表示

  # スライス位置と軸を明示的に指定
  slices:
    axes: 
      - "xy"   # XY面
      - "xz"   # XZ面
      - "yz"   # YZ面
    positions: 
      - 0.5    # 中央

  # 可視化する物理量を選択
  fields:
    velocity:
      enabled: false   # 速度場を可視化
    pressure:
      enabled: true   # 圧力場を可視化
    levelset:
      enabled: true

# デバッグ設定
debug:
  level: "info"
  save_fields: true
  check_divergence: true
  plot_residuals: true
  profiling: false
```

### physics/levelset/operations.py

```
import numpy as np
from .field import LevelSetField


class LevelSetOperations:
    """Level Set関数に対する基本的な操作を提供"""

    @staticmethod
    def advect(
        levelset: LevelSetField, velocity: np.ndarray, dt: float
    ) -> LevelSetField:
        """Level Set関数を移流"""
        advected_data = levelset.data.copy()

        for i in range(levelset.shape[0]):
            for j in range(levelset.shape[1]):
                for k in range(levelset.shape[2]):
                    # Lagrange的な移流計算（簡略化）
                    x, y, z = i * levelset.dx, j * levelset.dx, k * levelset.dx
                    u, v, w = (
                        velocity[0][i, j, k],
                        velocity[1][i, j, k],
                        velocity[2][i, j, k],
                    )

                    x_prev = x - u * dt
                    y_prev = y - v * dt
                    z_prev = z - w * dt

                    # バイリニア補間
                    advected_data[i, j, k] = np.interp(
                        x_prev,
                        np.linspace(
                            0, levelset.shape[0] * levelset.dx, levelset.shape[0]
                        ),
                        levelset.data[i, j, :],
                    )

        return LevelSetField(data=advected_data, dx=levelset.dx, params=levelset.params)

    @staticmethod
    def dilate(levelset: LevelSetField, distance: float) -> LevelSetField:
        """Level Set関数を膨張"""
        dilated_data = levelset.data - distance
        return LevelSetField(data=dilated_data, dx=levelset.dx, params=levelset.params)

    @staticmethod
    def erode(levelset: LevelSetField, distance: float) -> LevelSetField:
        """Level Set関数を収縮"""
        eroded_data = levelset.data + distance
        return LevelSetField(data=eroded_data, dx=levelset.dx, params=levelset.params)

```

### physics/levelset/initializer.py

```
"""Level Set関数の初期化を担当するモジュール"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional, Tuple, List
import numpy as np

from .field import LevelSetField, LevelSetParameters


class Phase(Enum):
    """流体の相を表す列挙型"""
    PHASE_1 = 1  # 第1相（例：水）
    PHASE_2 = 2  # 第2相（例：空気）


@dataclass
class InterfaceObject:
    """界面オブジェクトを表すデータクラス"""
    phase: Phase
    object_type: str  # "background", "layer", "sphere"
    height: Optional[float] = None  # レイヤー用
    center: Optional[Tuple[float, float, float]] = None  # 球体用
    radius: Optional[float] = None  # 球体用


class LevelSetInitializer:
    """Level Set関数の初期化を担当するクラス"""

    def __init__(self, dx: float, epsilon: float = None):
        """初期化子を構築
        
        Args:
            dx: グリッド間隔
            epsilon: 界面の厚さ（指定がない場合はdxから自動設定）
        """
        self.dx = dx
        self.epsilon = epsilon or (1.5 * dx)

    def initialize(
        self,
        shape: Tuple[int, ...],
        objects: List[InterfaceObject]
    ) -> LevelSetField:
        """Level Set関数を初期化
        
        Args:
            shape: グリッドの形状
            objects: 界面オブジェクトのリスト

        Returns:
            初期化されたLevel Set場
        """
        # Level Setパラメータの設定
        params = LevelSetParameters(
            epsilon=self.epsilon,
            reinit_interval=5,
            reinit_steps=2
        )

        # Level Set場の作成
        levelset = LevelSetField(shape=shape, dx=self.dx, params=params)

        # 背景相の設定
        background = next(obj for obj in objects if obj.object_type == "background")
        self._set_background(levelset, background.phase)

        # その他のオブジェクトを適用
        for obj in objects:
            if obj.object_type != "background":
                self._apply_object(levelset, obj)

        return levelset

    def _set_background(self, levelset: LevelSetField, phase: Phase) -> None:
        """背景相を設定"""
        # PHASE_1なら負の値（内部）、PHASE_2なら正の値（外部）で初期化
        levelset.data.fill(-1.0 if phase == Phase.PHASE_1 else 1.0)

    def _apply_object(self, levelset: LevelSetField, obj: InterfaceObject) -> None:
        """オブジェクトを適用"""
        if obj.object_type == "layer":
            self._apply_layer(levelset, obj)
        elif obj.object_type == "sphere":
            self._apply_sphere(levelset, obj)

    def _apply_layer(self, levelset: LevelSetField, obj: InterfaceObject) -> None:
        """水平レイヤーを適用"""
        if obj.height is None:
            raise ValueError("レイヤーには高さの指定が必要です")

        # 座標グリッドを作成
        coords = np.meshgrid(
            *[np.arange(n) * self.dx for n in levelset.shape],
            indexing='ij'
        )
        
        # 高さ方向の座標（最後の次元）
        z = coords[-1]
        
        # 符号付き距離関数を計算
        phi = obj.height - z
        
        # 相に応じて符号を反転
        if obj.phase == Phase.PHASE_2:
            phi = -phi
            
        # Level Set関数を更新（CSG演算）
        levelset.data = np.minimum(levelset.data, phi)

    def _apply_sphere(self, levelset: LevelSetField, obj: InterfaceObject) -> None:
        """球体を適用"""
        if obj.center is None or obj.radius is None:
            raise ValueError("球体には中心座標と半径の指定が必要です")

        # 座標グリッドを作成
        coords = np.meshgrid(
            *[np.arange(n) * self.dx for n in levelset.shape],
            indexing='ij'
        )
        
        # 球の中心からの距離を計算
        squared_distance = sum(
            (coord - center) ** 2 
            for coord, center in zip(coords, obj.center)
        )
        distance = np.sqrt(squared_distance)
        
        # 符号付き距離関数を計算
        phi = obj.radius - distance
        
        # 相に応じて符号を反転
        if obj.phase == Phase.PHASE_2:
            phi = -phi
            
        # Level Set関数を更新（CSG演算）
        levelset.data = np.minimum(levelset.data, phi)
```

### physics/levelset/reinitializer.py

```
import numpy as np
from scipy.ndimage import gaussian_filter
from .field import LevelSetField


def reinitialize_levelset(
    levelset: LevelSetField,
    dt: float = 0.1,
    n_steps: int = 5,
    method: str = "fast_marching",
) -> LevelSetField:
    """Level Set関数を再初期化"""
    if method == "fast_marching":
        return _fast_marching_reinit(levelset, dt, n_steps)
    elif method == "pde":
        return _pde_reinit(levelset, dt, n_steps)
    else:
        raise ValueError(f"未対応の再初期化手法: {method}")


def _fast_marching_reinit(
    levelset: LevelSetField, dt: float, n_steps: int
) -> LevelSetField:
    """高速行進法による再初期化"""
    result = levelset.data.copy()
    sign = np.sign(result)

    for _ in range(n_steps):
        # 界面近傍の点を特定
        interface_points = np.abs(result) < levelset.params.epsilon

        for point in np.argwhere(interface_points):
            # 最近傍点の符号付き距離を計算
            distances = _compute_signed_distance(point, result, sign, levelset.dx)
            result[tuple(point)] = sign[tuple(point)] * np.min(np.abs(distances))

        # 数値的安定化のためにガウシアンフィルタを適用
        result = gaussian_filter(result, sigma=0.5 * levelset.dx)

    return LevelSetField(data=result, dx=levelset.dx, params=levelset.params)


def _pde_reinit(levelset: LevelSetField, dt: float, n_steps: int) -> LevelSetField:
    """PDE法による再初期化"""
    result = levelset.data.copy()
    sign = np.sign(result)

    for _ in range(n_steps):
        # 勾配を計算
        grad = np.array(np.gradient(result, levelset.dx))
        grad_norm = np.sqrt(np.sum(grad**2, axis=0))

        # 時間発展
        result = result - dt * sign * (grad_norm - 1.0)

        # 数値的安定化
        result = gaussian_filter(result, sigma=0.5 * levelset.dx)

    return LevelSetField(data=result, dx=levelset.dx, params=levelset.params)


def _compute_signed_distance(
    point: np.ndarray, phi: np.ndarray, sign: np.ndarray, dx: float
) -> np.ndarray:
    """指定された点の符号付き距離を計算"""
    # 近傍点からの距離を計算する実装（省略）
    pass

```

### physics/levelset/method.py

```
import numpy as np

from .field import LevelSetField
from .reinitializer import reinitialize_levelset
from .utils import extend_velocity


class LevelSetMethod:
    """Level Set法の主要な計算ロジックを実装"""

    def __init__(self, use_weno: bool = True, weno_order: int = 5):
        """
        Level Set法を初期化

        Args:
            use_weno: WENOスキームを使用するかどうか
            weno_order: WENOスキームの次数
        """
        self.use_weno = use_weno
        self.weno_order = weno_order

    def compute_derivative(
        self, levelset: LevelSetField, velocity: np.ndarray, dt: float = 0.0
    ) -> LevelSetField:
        """Level Set関数の時間微分を計算"""
        if self.use_weno:
            return self._weno_derivative(levelset, velocity, dt)
        else:
            return self._central_derivative(levelset, velocity, dt)

    def _weno_derivative(
        self, levelset: LevelSetField, velocity: np.ndarray, dt: float
    ) -> LevelSetField:
        """WENOスキームによる時間微分の計算"""
        # WENOスキームの実装（複雑な実装は省略）
        raise NotImplementedError("WENO derivative not implemented")

    def _central_derivative(
        self, levelset: LevelSetField, velocity: np.ndarray, dt: float
    ) -> LevelSetField:
        """中心差分による時間微分の計算"""
        # 中心差分の実装
        derivatives = [
            np.gradient(v * comp, levelset.dx, axis=i)
            for i, (v, comp) in enumerate(zip(velocity, levelset.data.T))
        ]

        derivative_data = -sum(derivatives)

        return LevelSetField(
            data=levelset.data + dt * derivative_data,
            dx=levelset.dx,
            params=levelset.params,
        )

    def reinitialize(self, levelset: LevelSetField) -> LevelSetField:
        """Level Set関数を再初期化"""
        return reinitialize_levelset(
            levelset, dt=levelset.params.epsilon, n_steps=levelset.params.reinit_steps
        )

    def extend_velocity(
        self, velocity: np.ndarray, levelset: LevelSetField
    ) -> np.ndarray:
        """界面に沿って速度場を延長"""
        return extend_velocity(velocity, levelset.data, levelset.dx)

```

### physics/levelset/field.py

```
from dataclasses import dataclass
from typing import Optional, Tuple
import numpy as np
import numpy.typing as npt

from .utils import compute_volume, compute_area, heaviside, delta, compute_curvature


@dataclass
class LevelSetParameters:
    """Level Set法のパラメータを管理するデータクラス"""

    epsilon: float = 1.0e-2  # 界面の厚さ
    reinit_interval: int = 5  # 再初期化の間隔
    reinit_steps: int = 2  # 再初期化のステップ数
    min_value: float = 1.0e-10  # 最小値の閾値


class LevelSetField:
    """Level Set関数を表現し、界面追跡のための操作を提供するクラス"""

    def __init__(
        self,
        data: npt.NDArray,
        dx: float = 1.0,
        params: Optional[LevelSetParameters] = None,
    ):
        """
        Level Set関数を初期化

        Args:
            data: Level Set関数の数値データ
            dx: グリッド間隔
            params: Level Set法のパラメータ
        """
        self._data = np.asarray(data)
        self._dx = dx
        self.params = params or LevelSetParameters()
        self._steps_since_reinit = 0

    @property
    def data(self) -> npt.NDArray:
        """Level Set関数のデータを取得"""
        return self._data

    @property
    def shape(self) -> Tuple[int, ...]:
        """グリッドの形状を取得"""
        return self._data.shape

    @property
    def dx(self) -> float:
        """グリッド間隔を取得"""
        return self._dx

    def volume(self) -> float:
        """体積を計算"""
        return compute_volume(self._data, self._dx)

    def area(self) -> float:
        """界面の面積を計算"""
        return compute_area(self._data, self._dx)

    def curvature(self) -> npt.NDArray:
        """界面の曲率を計算"""
        return compute_curvature(self._data, self._dx)

    def heaviside(self) -> npt.NDArray:
        """Heaviside関数を計算"""
        return heaviside(self._data, self.params.epsilon)

    def delta(self) -> npt.NDArray:
        """Delta関数を計算"""
        return delta(self._data, self.params.epsilon)

    def needs_reinit(self) -> bool:
        """再初期化が必要かどうかを判定"""
        return (
            self._steps_since_reinit >= self.params.reinit_interval
            or not self._is_signed_distance()
        )

    def _is_signed_distance(self, tolerance: float = 1e-2) -> bool:
        """符号付き距離関数としての性質を検証"""
        grad = np.gradient(self._data, self._dx)
        grad_norm = np.sqrt(sum(g**2 for g in grad))
        return np.abs(grad_norm - 1.0).mean() < tolerance

    def copy(self) -> "LevelSetField":
        """深いコピーを作成"""
        return LevelSetField(data=self._data.copy(), dx=self._dx, params=self.params)

```

### physics/levelset/__init__.py

```
from .field import LevelSetField, LevelSetParameters
from .method import LevelSetMethod
from .initializer import LevelSetInitializer
from .reinitializer import reinitialize_levelset
from .utils import (
    heaviside,
    delta,
    compute_curvature,
    compute_volume,
    compute_area,
    extend_velocity,
)
from .operations import LevelSetOperations

__all__ = [
    # クラス
    "LevelSetField",
    "LevelSetParameters",
    "LevelSetMethod",
    "LevelSetInitializer",
    "LevelSetOperations",
    # 関数
    "reinitialize_levelset",
    "heaviside",
    "delta",
    "compute_curvature",
    "compute_volume",
    "compute_area",
    "extend_velocity",
]

```

### physics/levelset/utils.py

```
import numpy as np
import numpy.typing as npt


def heaviside(phi: npt.NDArray, epsilon: float = 1.0e-2) -> npt.NDArray:
    """正則化されたHeaviside関数"""
    return 0.5 * (1.0 + np.tanh(phi / epsilon))


def delta(phi: npt.NDArray, epsilon: float = 1.0e-2) -> npt.NDArray:
    """正則化されたDelta関数"""
    return 0.5 / epsilon * (1.0 - np.tanh(phi / epsilon) ** 2)


def compute_curvature(phi: npt.NDArray, dx: float) -> npt.NDArray:
    """界面の曲率を計算"""
    grad = np.array(np.gradient(phi, dx))
    grad_norm = np.sqrt(np.sum(grad**2, axis=0))
    grad_norm = np.maximum(grad_norm, 1e-10)

    return sum(np.gradient(grad[i] / grad_norm, dx, axis=i) for i in range(phi.ndim))


def compute_volume(phi: npt.NDArray, dx: float) -> float:
    """Level Set関数から体積を計算"""
    return float(np.sum(heaviside(phi)) * dx**phi.ndim)


def compute_area(phi: npt.NDArray, dx: float) -> float:
    """Level Set関数から界面の面積を計算"""
    return float(np.sum(delta(phi)) * dx**phi.ndim)


def extend_velocity(
    velocity: npt.NDArray, phi: npt.NDArray, dx: float, n_steps: int = 5
) -> npt.NDArray:
    """界面に沿って速度場を延長"""
    result = velocity.copy()

    for _ in range(n_steps):
        # 法線ベクトルを計算
        grad = np.array(np.gradient(phi, dx))
        grad_norm = np.sqrt(np.sum(grad**2, axis=0))
        grad_norm = np.maximum(grad_norm, 1e-10)
        normal = grad / grad_norm

        # 速度勾配を計算
        vel_grad = np.array(np.gradient(result, dx))

        # 法線方向の速度勾配を解消
        result -= sum(normal[i] * vel_grad[i] for i in range(phi.ndim))

    return result

```

### physics/navier_stokes/core/interfaces.py

```
from typing import Protocol, Dict, Any, List, Optional, TypeVar, Generic, Tuple
import numpy as np

from core.field import VectorField

StateType = TypeVar("StateType")


class NavierStokesTerm(Protocol):
    """Navier-Stokes方程式の項のプロトコル"""

    @property
    def name(self) -> str: ...

    @property
    def enabled(self) -> bool: ...

    def compute(self, velocity: VectorField, **kwargs) -> List[np.ndarray]: ...

    def compute_timestep(self, velocity: VectorField, **kwargs) -> float: ...

    def get_diagnostics(self) -> Dict[str, Any]: ...


class TimeIntegrator(Protocol, Generic[StateType]):
    """時間発展スキームのプロトコル"""

    def step(
        self, state: StateType, dt: float, compute_derivative: Any, **kwargs
    ) -> StateType: ...


class NavierStokesSolver(Protocol, Generic[StateType]):
    """Navier-Stokesソルバーのプロトコル"""

    @property
    def time(self) -> float: ...

    def initialize(self, state: Optional[StateType] = None) -> None: ...

    def step_forward(self, dt: Optional[float] = None, **kwargs) -> Dict[str, Any]: ...

    def get_state(self) -> Tuple[StateType, Dict[str, Any]]: ...

```

### physics/navier_stokes/core/__init__.py

```
"""Navier-Stokes方程式のコアインターフェースを提供するパッケージ

このパッケージは、Navier-Stokes方程式に関する基本的なプロトコルとインターフェースを定義します。
"""

from .interfaces import (
    NavierStokesTerm,
    NavierStokesSolver
)

__all__ = [
    "NavierStokesTerm",
    "NavierStokesSolver",
]
```

### physics/navier_stokes/terms/force.py

```
from typing import List, Dict, Any, Optional
import numpy as np

from core.field import VectorField, ScalarField
from .base import BaseNavierStokesTerm


class GravityForce(BaseNavierStokesTerm):
    """重力項クラス"""

    def __init__(
        self,
        gravity: float = 9.81,
        direction: int = -1,
        name: str = "Gravity",
        enabled: bool = True,
    ):
        """
        Args:
            gravity: 重力加速度
            direction: 重力方向の軸インデックス（負値は逆方向）
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        super().__init__(name, enabled)
        self._gravity = gravity
        self._direction = direction

    def compute(
        self, velocity: VectorField, density: Optional[ScalarField] = None, **kwargs
    ) -> List[np.ndarray]:
        """重力項の寄与を計算

        Args:
            velocity: 速度場
            density: 密度場（オプション）

        Returns:
            各方向の速度成分への重力項の寄与
        """
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        result = [np.zeros_like(v.data) for v in velocity.components]
        axis = abs(self._direction) % velocity.ndim
        sign = -1 if self._direction < 0 else 1

        # 密度場が提供されている場合は密度に応じた重力
        if density is not None:
            result[axis] = sign * self._gravity * density.data
        else:
            # デフォルトは一様な重力
            result[axis].fill(sign * self._gravity)

        # 診断情報の更新
        self._diagnostics = {
            "gravity": self._gravity,
            "direction": self._direction,
            "max_force": float(np.max(np.abs(result[axis]))),
        }

        return result

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "gravity": self._gravity,
                "direction": self._direction,
                "max_force": self._diagnostics.get("max_force", 0.0),
            }
        )
        return diag


class SurfaceTensionForce(BaseNavierStokesTerm):
    """表面張力項クラス"""

    def __init__(
        self,
        surface_tension: float = 0.072,
        name: str = "SurfaceTension",
        enabled: bool = True,
    ):
        """
        Args:
            surface_tension: 表面張力係数
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        super().__init__(name, enabled)
        self._surface_tension = surface_tension

    def compute(
        self, velocity: VectorField, levelset: ScalarField, **kwargs
    ) -> List[np.ndarray]:
        """表面張力項の寄与を計算

        Args:
            velocity: 速度場
            levelset: レベルセット関数場

        Returns:
            各方向の速度成分への表面張力項の寄与
        """
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        result = [np.zeros_like(v.data) for v in velocity.components]
        dx = velocity.dx

        # 界面の法線ベクトルと曲率の計算
        grad_norm = 1e-10  # ゼロ除算防止
        grad_phi = []
        for i in range(velocity.ndim):
            g = np.gradient(levelset.data, dx, axis=i)
            grad_phi.append(g)
            grad_norm += g**2
        grad_norm = np.sqrt(grad_norm)

        # 曲率の計算
        kappa = sum(
            np.gradient(g / grad_norm, dx, axis=i) for i, g in enumerate(grad_phi)
        )

        # デルタ関数の計算（界面の特徴づけ）
        epsilon = kwargs.get("epsilon", 1e-2)
        delta = 0.5 / epsilon * (1.0 - np.tanh(levelset.data / epsilon) ** 2)

        # 表面張力の計算
        force = self._surface_tension * kappa * delta
        for i in range(velocity.ndim):
            result[i] = force * grad_phi[i] / grad_norm

        # 診断情報の更新
        self._diagnostics = {
            "surface_tension": self._surface_tension,
            "max_curvature": float(np.max(np.abs(kappa))),
            "max_force": float(np.max(np.abs(force))),
        }

        return result

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "surface_tension": self._surface_tension,
                "max_curvature": self._diagnostics.get("max_curvature", 0.0),
                "max_force": self._diagnostics.get("max_force", 0.0),
            }
        )
        return diag

```

### physics/navier_stokes/terms/base.py

```
from abc import ABC, abstractmethod
from typing import Dict, Any, List
import numpy as np

from core.field import VectorField


class BaseNavierStokesTerm(ABC):
    """Navier-Stokes方程式の項の基底クラス"""

    def __init__(self, name: str = "BaseTerm", enabled: bool = True):
        self._name = name
        self._enabled = enabled
        self._diagnostics: Dict[str, Any] = {}

    @property
    def name(self) -> str:
        return self._name

    @property
    def enabled(self) -> bool:
        return self._enabled

    @abstractmethod
    def compute(self, velocity: VectorField, **kwargs) -> List[np.ndarray]:
        """項の寄与を計算する抽象メソッド"""
        pass

    def compute_timestep(self, velocity: VectorField, **kwargs) -> float:
        """デフォルトの時間刻み幅計算"""
        return float("inf")

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {"name": self.name, "enabled": self.enabled, **self._diagnostics}

```

### physics/navier_stokes/terms/advection.py

```
from typing import List, Dict, Any
import numpy as np

from core.field import VectorField
from .base import BaseNavierStokesTerm


class AdvectionTerm(BaseNavierStokesTerm):
    """移流項クラス"""

    def __init__(
        self,
        use_weno: bool = True,
        weno_order: int = 5,
        name: str = "Advection",
        enabled: bool = True,
    ):
        super().__init__(name, enabled)
        self._use_weno = use_weno
        self._weno_order = weno_order

    def compute(self, velocity: VectorField, **kwargs) -> List[np.ndarray]:
        """移流項の寄与を計算"""
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        result = []
        for i, v_i in enumerate(velocity.components):
            flux = -sum(
                v_j.data * v_i.gradient(j) for j, v_j in enumerate(velocity.components)
            )
            result.append(flux)

        self._diagnostics["flux_max"] = float(max(np.max(np.abs(r)) for r in result))
        self._diagnostics["scheme"] = "WENO" if self._use_weno else "Central"

        return result

    def compute_timestep(self, velocity: VectorField, **kwargs) -> float:
        """移流項に基づく時間刻み幅の制限を計算"""
        if not self.enabled:
            return float("inf")

        max_velocity = max(np.max(np.abs(comp.data)) for comp in velocity.components)

        cfl = kwargs.get("cfl", 0.5)
        return cfl * velocity.dx / (max_velocity + 1e-10)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "weno": {
                    "enabled": self._use_weno,
                    "order": self._weno_order if self._use_weno else None,
                }
            }
        )
        return diag

```

### physics/navier_stokes/terms/acceleration.py

```
"""
二相流のナビエ・ストークス方程式における速度場の加速度項

支配方程式:
∂(ρu)/∂t + ∇⋅(ρu⊗u) = -∇p + ∇⋅τ + ρg + Fσ

速度場の時間発展に必要な項の統合を行う
"""

from typing import List, Dict, Any
import numpy as np

from core.field import VectorField, ScalarField
from .base import BaseNavierStokesTerm
from ..terms.advection import AdvectionTerm
from ..terms.diffusion import DiffusionTerm
from ..terms.pressure import PressureTerm
from ..terms.force import GravityForce


class AccelerationTerm(BaseNavierStokesTerm):
    """
    速度場の加速度項を計算するクラス

    Navier-Stokes方程式の右辺を統合して速度場の時間微分を計算
    """

    def __init__(
        self, 
        name: str = "Acceleration", 
        enabled: bool = True
    ):
        """
        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        super().__init__(name, enabled)
        
        # 各項のインスタンスを事前に作成
        self._advection_term = AdvectionTerm()
        self._pressure_term = PressureTerm()
        self._diffusion_term = DiffusionTerm()
        self._gravity_term = GravityForce()

    def compute(
        self,
        velocity: VectorField, 
        density: ScalarField,
        viscosity: ScalarField,
        pressure: ScalarField,
        **kwargs
    ) -> List[np.ndarray]:
        """
        速度場の時間微分（加速度）を計算

        Args:
            velocity: 速度場
            density: 密度場
            viscosity: 粘性場
            pressure: 圧力場
            **kwargs: 追加のパラメータ

        Returns:
            各方向の速度の時間微分（加速度）
        """
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        # 各項を計算
        advection = self._advection_term.compute(velocity)
        pressure_term = self._pressure_term.compute(velocity, pressure)
        diffusion = self._diffusion_term.compute(velocity)
        gravity = self._gravity_term.compute(velocity, density)

        # 項を統合
        acceleration = [
            -adv + press + diff + grav
            for adv, press, diff, grav in zip(
                advection, pressure_term, diffusion, gravity
            )
        ]

        # 診断情報の更新
        self._diagnostics = {
            'advection': self._advection_term.get_diagnostics(),
            'pressure': self._pressure_term.get_diagnostics(),
            'diffusion': self._diffusion_term.get_diagnostics(),
            'gravity': self._gravity_term.get_diagnostics(),
            'max_acceleration': float(max(np.max(np.abs(a)) for a in acceleration))
        }

        return acceleration

    def get_diagnostics(self) -> Dict[str, Any]:
        """
        診断情報を取得

        Returns:
            加速度項の診断情報
        """
        diag = super().get_diagnostics()
        diag.update(self._diagnostics)
        return diag
```

### physics/navier_stokes/terms/diffusion.py

```
from typing import List, Dict, Any
import numpy as np

from core.field import VectorField
from .base import BaseNavierStokesTerm


class DiffusionTerm(BaseNavierStokesTerm):
    """粘性項（拡散項）クラス"""

    def __init__(
        self, viscosity: float = 1.0e-3, name: str = "Diffusion", enabled: bool = True
    ):
        """
        Args:
            viscosity: 動粘性係数
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        super().__init__(name, enabled)
        self._viscosity = viscosity

    def compute(self, velocity: VectorField, **kwargs) -> List[np.ndarray]:
        """粘性項の寄与を計算

        Args:
            velocity: 速度場

        Returns:
            各方向の速度成分への拡散項の寄与
        """
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        result = []
        dx = velocity.dx

        # 各成分の粘性項を計算
        for i, v_i in enumerate(velocity.components):
            # ラプラシアンの計算
            laplacian = sum(
                np.gradient(np.gradient(v_i.data, dx, axis=j), dx, axis=j)
                for j in range(velocity.ndim)
            )

            # 粘性による加速度
            result.append(self._viscosity * laplacian)

        # 診断情報の更新
        total_dissipation = self._compute_dissipation(velocity)
        self._diagnostics = {
            "total_dissipation": float(total_dissipation),
            "viscosity": self._viscosity,
        }

        return result

    def _compute_dissipation(self, velocity: VectorField) -> float:
        """粘性散逸の計算

        Args:
            velocity: 速度場

        Returns:
            粘性散逸の総和
        """
        strain_rate_squared = np.zeros_like(velocity.components[0].data)
        dx = velocity.dx

        # 速度勾配の計算
        for i in range(velocity.ndim):
            for j in range(velocity.ndim):
                # ひずみ速度テンソルの計算
                if i == j:
                    # 対角成分
                    dui_dxi = np.gradient(velocity.components[i].data, dx, axis=i)
                    strain_rate_squared += dui_dxi**2
                else:
                    # 非対角成分
                    dui_dxj = np.gradient(velocity.components[i].data, dx, axis=j)
                    duj_dxi = np.gradient(velocity.components[j].data, dx, axis=i)
                    strain_rate_squared += 2 * ((dui_dxj + duj_dxi) / 2) ** 2

        return np.sum(self._viscosity * strain_rate_squared)

    def compute_timestep(self, velocity: VectorField, **kwargs) -> float:
        """粘性項に基づく時間刻み幅の制限を計算

        Args:
            velocity: 速度場

        Returns:
            計算された時間刻み幅の制限
        """
        if not self.enabled:
            return float("inf")

        # 安定性条件: dx² / (2ν)
        return 0.5 * velocity.dx**2 / (self._viscosity + 1e-10)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "viscosity": self._viscosity,
                "dissipation": self._diagnostics.get("total_dissipation", 0.0),
            }
        )
        return diag

```

### physics/navier_stokes/terms/__init__.py

```
"""Navier-Stokes方程式の各項を提供するパッケージ

このパッケージは、Navier-Stokes方程式を構成する各項（移流項、粘性項、圧力項、外力項、加速度項）
を実装したクラスを提供します。
"""

from .base import BaseNavierStokesTerm
from .advection import AdvectionTerm
from .diffusion import DiffusionTerm
from .pressure import PressureTerm
from .force import GravityForce, SurfaceTensionForce
from .acceleration import AccelerationTerm

__all__ = [
    # 基底クラス
    "BaseNavierStokesTerm",
    
    # 具体的な項の実装
    "AdvectionTerm",
    "DiffusionTerm",
    "PressureTerm",
    "AccelerationTerm",
    
    # 外力関連
    "GravityForce",
    "SurfaceTensionForce",
]
```

### physics/navier_stokes/terms/pressure.py

```
from typing import List, Dict, Any
import numpy as np

from core.field import VectorField, ScalarField
from .base import BaseNavierStokesTerm


class PressureTerm(BaseNavierStokesTerm):
    """圧力項クラス"""

    def __init__(
        self, density: float = 1000.0, name: str = "Pressure", enabled: bool = True
    ):
        """
        Args:
            density: 参照密度
            name: 項の名前
            enabled: 項を有効にするかどうか
        """
        super().__init__(name, enabled)
        self._density = density

    def compute(
        self, velocity: VectorField, pressure: ScalarField, **kwargs
    ) -> List[np.ndarray]:
        """圧力項の寄与を計算

        Args:
            velocity: 速度場
            pressure: 圧力場

        Returns:
            各方向の速度成分への圧力項の寄与
        """
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        result = []
        dx = velocity.dx

        # 各方向の圧力勾配を計算
        for i in range(velocity.ndim):
            grad_p = np.gradient(pressure.data, dx, axis=i)
            result.append(-grad_p / self._density)

        # 診断情報の更新
        self._diagnostics = {
            "pressure_min": float(np.min(pressure.data)),
            "pressure_max": float(np.max(pressure.data)),
            "pressure_mean": float(np.mean(pressure.data)),
            "density": self._density,
        }

        return result

    def compute_timestep(
        self, velocity: VectorField, pressure: ScalarField, **kwargs
    ) -> float:
        """圧力項に基づく時間刻み幅の制限を計算

        Args:
            velocity: 速度場
            pressure: 圧力場

        Returns:
            計算された時間刻み幅の制限
        """
        if not self.enabled:
            return float("inf")

        # 音速の粗い見積もり
        sound_speed = np.sqrt(np.max(pressure.data) / self._density)

        # CFL条件に基づく制限
        return 0.5 * velocity.dx / (sound_speed + 1e-10)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "pressure": {
                    "min": self._diagnostics.get("pressure_min", 0.0),
                    "max": self._diagnostics.get("pressure_max", 0.0),
                    "mean": self._diagnostics.get("pressure_mean", 0.0),
                },
                "density": self._density,
            }
        )
        return diag

```

### physics/navier_stokes/solvers/__init__.py

```
"""Navier-Stokes方程式のソルバーパッケージ

このパッケージは、Navier-Stokes方程式を解くための各種ソルバーを提供します。
"""

from .projection import PressureProjectionSolver

__all__ = [
    "PressureProjectionSolver",
]
```

### physics/navier_stokes/solvers/projection.py

```
"""
二相流のナビエ・ストークス（NS）方程式と圧力ポアソン方程式の導出

理論的背景:
1. 基本方程式
連続の式（質量保存則）:
∂ρ/∂t + ∇⋅(ρu) = 0

ナビエ・ストークス方程式（運動方程式）:
∂(ρu)/∂t + ∇⋅(ρu⊗u) = -∇p + ∇⋅τ + ρg + Fσ

2. 圧力ポアソン方程式の導出
方程式の両辺に発散∇⋅を作用させると：
∇⋅(∂(ρu)/∂t + ∇⋅(ρu⊗u)) = -∇²p + ∇⋅(∇⋅τ) + ∇⋅(ρg) + ∇⋅Fσ

粘性の不均一性を考慮した最終的な形:
∇²p = ∇⋅(∂(ρu)/∂t + ∇⋅(ρu⊗u)) - ∇⋅(ρg) - ∇⋅Fσ 
       + ∇⋅((∇μ)⋅∇u) - ∇⋅(∇⋅[μ(∇u + (∇u)T)])

特に二相流では:
- 密度と粘性の不連続性を考慮
- 界面での物理量の補間が重要
"""

from typing import Dict, Any
import numpy as np

from core.field import VectorField, ScalarField
from numerics.poisson import PoissonSolver, PoissonConfig


class PressureProjectionSolver:
    """
    圧力投影法による速度場の発散除去
    
    二相流のナビエ・ストークス方程式を解くための圧力投影法
    """

    def __init__(
        self, 
        solver_config: PoissonConfig = None
    ):
        """
        Args:
            solver_config: ポアソンソルバーの設定
        """
        # ポアソンソルバーの初期化
        self._poisson_solver = PoissonSolver(solver_config)
        
        # 診断情報
        self._diagnostics = {}

    def compute_rhs(
        self,
        velocity: VectorField, 
        density: ScalarField,
        viscosity: ScalarField,
        dt: float
    ) -> np.ndarray:
        """
        圧力ポアソン方程式の右辺を計算

        Args:
            velocity: 速度場
            density: 密度場
            viscosity: 粘性場
            dt: 時間刻み幅

        Returns:
            右辺項の配列
        """
        # 密度と速度の発散を計算
        div_rho_u = self._compute_density_velocity_divergence(
            velocity, density, dt
        )

        # 粘性の不均一性を考慮した粘性項を計算
        viscosity_term = self._compute_viscosity_term(
            velocity, viscosity
        )

        # 右辺を計算: -div(ρu)/dt + 粘性項
        rhs = -div_rho_u / dt + viscosity_term

        return rhs

    def _compute_density_velocity_divergence(
        self, 
        velocity: VectorField, 
        density: ScalarField, 
        dt: float
    ) -> np.ndarray:
        """密度と速度の発散を計算"""
        dx = velocity.dx
        result = np.zeros_like(density.data)

        for i in range(velocity.ndim):
            # 密度と速度の積の勾配を計算
            rho_u = density.data * velocity.components[i].data
            div_rho_u = np.gradient(rho_u, dx, axis=i)
            result += div_rho_u

        return result

    def _compute_viscosity_term(
        self, 
        velocity: VectorField, 
        viscosity: ScalarField
    ) -> np.ndarray:
        """粘性の不均一性を考慮した粘性項を計算"""
        dx = velocity.dx
        result = np.zeros_like(viscosity.data)

        # 粘性勾配項の計算
        viscosity_gradient = []
        for i in range(velocity.ndim):
            viscosity_gradient.append(np.gradient(viscosity.data, dx, axis=i))

        # 粘性の不均一性を考慮した項の計算
        for i in range(velocity.ndim):
            # μ∇²u項
            laplacian_u = np.gradient(
                np.gradient(velocity.components[i].data, dx, axis=i), 
                dx, 
                axis=i
            )
            mu_laplacian_u = viscosity.data * laplacian_u

            # (∇μ)⋅∇u項
            grad_dot_u = sum(
                viscosity_gradient[j] * 
                np.gradient(velocity.components[i].data, dx, axis=j)
                for j in range(velocity.ndim)
            )

            result += np.gradient(mu_laplacian_u, dx, axis=i) + grad_dot_u

        return result

    def solve_pressure(
        self,
        rhs: np.ndarray,
        velocity: VectorField
    ) -> ScalarField:
        """
        圧力ポアソン方程式を解く

        Args:
            rhs: ポアソン方程式の右辺
            velocity: 速度場

        Returns:
            計算された圧力場
        """
        # ポアソンソルバーを使用して圧力を計算
        pressure = ScalarField(velocity.shape, velocity.dx)
        pressure.data = self._poisson_solver.solve(rhs)

        # 診断情報の更新
        self._diagnostics.update(
            self._poisson_solver.get_status()
        )

        return pressure

    def project_velocity(
        self,
        velocity: VectorField,
        pressure: ScalarField
    ) -> VectorField:
        """
        圧力勾配を用いて速度場を修正（発散除去）

        Args:
            velocity: 元の速度場
            pressure: 計算された圧力場

        Returns:
            発散除去された速度場
        """
        dx = velocity.dx

        # 各方向に圧力勾配を減算
        for i in range(velocity.ndim):
            grad_p = np.gradient(pressure.data, dx, axis=i)
            velocity.components[i].data -= grad_p

        return velocity

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return self._diagnostics
```

### physics/navier_stokes/__init__.py

```
"""Navier-Stokes方程式の数値計算パッケージ

このパッケージは、Navier-Stokes方程式の数値解法に必要な各種機能を提供します。
主な機能には以下が含まれます：

- 項の実装 (移流項、粘性項、圧力項、外力項)
- 圧力投影法ソルバー
"""

from .terms.advection import AdvectionTerm
from .terms.diffusion import DiffusionTerm
from .terms.force import GravityForce, SurfaceTensionForce
from .terms.pressure import PressureTerm
from .solvers.projection import PressureProjectionSolver

__all__ = [
    # 項の実装
    "AdvectionTerm",
    "DiffusionTerm",
    "PressureTerm",
    "GravityForce",
    "SurfaceTensionForce",
    
    # ソルバー
    "PressureProjectionSolver",
]
```

### main2.py

```
"""二相流シミュレーションの実行スクリプト"""

import sys
import argparse
from pathlib import Path

from logger import SimulationLogger, LogConfig
from simulations import TwoPhaseFlowSimulator, SimulationConfig
from visualization import visualize_simulation_state
from typing import Optional


def parse_args():
    """コマンドライン引数をパース"""
    parser = argparse.ArgumentParser(
        description="Level Set法による二相流シミュレーション"
    )
    parser.add_argument("--config", type=str, required=True, help="設定ファイルのパス")
    parser.add_argument("--checkpoint", type=str, help="チェックポイントファイルのパス")
    parser.add_argument("--debug", action="store_true", help="デバッグモードを有効化")
    return parser.parse_args()


def setup_logging(config: SimulationConfig, debug: bool) -> SimulationLogger:
    """ロギングを設定"""
    log_level = "debug" if debug else "info"
    log_dir = Path(config.output_dir) / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    return SimulationLogger("TwoPhaseFlow", LogConfig(level=log_level, log_dir=log_dir))


def initialize_simulation(
    config: SimulationConfig,
    logger: SimulationLogger,
    checkpoint: Optional[Path] = None,
) -> TwoPhaseFlowSimulator:
    """シミュレーションを初期化"""
    # 出力ディレクトリの作成
    output_dir = Path(config.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    if checkpoint:
        logger.info(f"チェックポイントから再開: {checkpoint}")
        sim = TwoPhaseFlowSimulator(config, logger)
        sim.initialize(state=sim.load_checkpoint(str(checkpoint)))
        return sim
    else:
        logger.info("新規シミュレーションを開始")
        sim = TwoPhaseFlowSimulator(config, logger)
        sim.initialize()
        return sim


def main():
    """メイン関数"""
    # コマンドライン引数の解析
    args = parse_args()

    # 設定ファイルの読み込み
    config = SimulationConfig.from_yaml(args.config)

    # ロガーの設定
    logger = setup_logging(config, args.debug)

    # チェックポイントファイルのパス
    checkpoint = Path(args.checkpoint) if args.checkpoint else None

    try:
        # シミュレーションの初期化
        sim = initialize_simulation(config, logger, checkpoint)

        # 初期状態の可視化と保存
        state, _ = sim.get_state()
        visualize_simulation_state(state, config, timestamp=0.0)

        # 初期チェックポイントを保存（オプション）
        output_dir = Path(config.output_dir) / "checkpoints"
        output_dir.mkdir(parents=True, exist_ok=True)
        initial_checkpoint = output_dir / "initial_checkpoint.npz"
        sim.save_checkpoint(str(initial_checkpoint))

        # シミュレーションパラメータ
        save_interval = config.time.save_interval
        max_time = config.time.max_time
        next_save_time = save_interval

        # 最初の時間刻み幅を計算
        current_dt = sim._time_solver.compute_timestep(state=state)

        logger.info(
            f"シミュレーション開始:\n"
            f"  最大時間: {max_time} [s]\n"
            f"  保存間隔: {save_interval} [s]\n"
            f"  初期時間刻み幅: {current_dt:.3e} [s]"
        )

        while next_save_time <= max_time:
            try:
                # 時間発展の実行（時間刻み幅を明示的に渡す）
                result = sim._time_solver.step_forward(dt=current_dt, state=state)
                state = result["state"]
                step_info = result.get("diagnostics", {})

                # 結果の保存
                if step_info.get("time", 0.0) >= next_save_time:
                    visualize_simulation_state(
                        state, config, timestamp=step_info["time"]
                    )

                    # チェックポイントを保存
                    output_dir = Path(config.output_dir) / "checkpoints"
                    output_dir.mkdir(parents=True, exist_ok=True)
                    checkpoint_filename = f"checkpoint_{step_info['time']:.4f}.npz"
                    checkpoint_path = output_dir / checkpoint_filename
                    sim.save_checkpoint(str(checkpoint_path))

                    next_save_time += save_interval

                # 次のステップの時間刻み幅を計算
                current_dt = sim._time_solver.compute_timestep(state=state)

                # 進捗の出力
                logger.info(
                    f"Time: {step_info.get('time', 0.0):.3f}/{max_time:.1f} "
                    f"(dt={current_dt:.3e}), "
                    f"Diagnostics: {step_info}"
                )

            except Exception as e:
                logger.error(f"シミュレーションステップ中にエラー: {e}")
                import traceback

                traceback.print_exc()
                break

        logger.info("シミュレーション正常終了")
        return 0

    except Exception as e:
        logger.error(f"実行中にエラーが発生: {e}")
        import traceback

        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())

```

### .vscode/launch.json

```
{
    // IntelliSense を使用して利用可能な属性を学べます。
    // 既存の属性の説明をホバーして表示します。
    // 詳細情報は次を確認してください: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        
        {
            "name": "Python デバッガー: 現在のファイル",
            "type": "debugpy",
            "request": "launch",
            "program": "main2.py",
            "console": "integratedTerminal",
            "args": ["--config", "config.yaml"]
        }
    ]
}
```

