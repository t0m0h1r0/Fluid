# .

## Directory Structure

- ./
  - .venv/
  - simulations/
    - initializer.py
    - state.py
    - config.py
    - simulation.py
    - __init__.py
  - visualization/
    - core/
      - base.py
      - exporter.py
      - renderer.py
      - __init__.py
    - interfaces.py
    - utils/
      - colormap.py
      - camera.py
    - renderer_strategy.py
    - renderers/
      - vector2d.py
      - vector3d.py
      - __init__.py
      - scalar2d.py
      - scalar3d.py
    - visualizer.py
    - __init__.py
    - multiview.py
  - core/
    - boundary/
      - dirichlet.py
      - base.py
      - periodic.py
      - neumann.py
      - __init__.py
    - solver/
      - base.py
      - temporal.py
      - iterative.py
      - __init__.py
    - field/
      - scalar.py
      - vector.py
      - conserved.py
      - field.py
      - __init__.py
  - up.py
  - main.py
  - config.yaml
  - tree.txt
  - physics/
    - levelset/
      - solver.py
      - base.py
      - properties.py
      - field.py
      - __init__.py
      - utils.py
      - reinitialize.py
    - utils/
    - navier_stokes/
      - core/
        - base_solver.py
        - interfaces.py
        - state.py
      - terms/
        - force.py
        - base.py
        - advection.py
        - diffusion.py
        - __init__.py
        - pressure.py
      - utils/
        - time_integration.py
        - __init__.py
        - projection.py
      - solvers/
        - basic_solver.py
        - projection_solver.py
        - __init__.py
      - __init__.py
    - time_evolution/
      - solver.py
      - base.py
      - integrator.py
      - __init__.py
      - methods/
        - runge_kutta.py
        - euler.py
        - __init__.py
    - poisson/
      - solver.py
      - base.py
      - config.py
      - __init__.py
      - methods/
        - sor.py
  - logger/
    - formatters.py
    - config.py
    - handlers.py
    - logger.py
    - __init__.py
  - main2.py
  - .vscode/
    - launch.json
  - .ruff_cache/

## File Contents

### simulations/initializer.py

```
"""シミュレーションの初期化を担当するモジュール

リファクタリングされたphysics/パッケージに対応した更新版
"""

from typing import Optional, Tuple
import numpy as np

from physics.levelset import LevelSetField, LevelSetParameters
from physics.levelset.properties import LevelSetPropertiesManager

from core.field import VectorField, ScalarField

from .config import SimulationConfig, ObjectConfig
from .state import SimulationState


class SimulationInitializer:
    """二相流シミュレーションの初期化クラス"""

    def __init__(
        self,
        config: SimulationConfig,
        properties: Optional[LevelSetPropertiesManager] = None,
    ):
        """初期化クラスを初期化

        Args:
            config: シミュレーション設定
            properties: 物性値マネージャー（オプション）
        """
        self.config = config
        self.properties = properties or LevelSetPropertiesManager(
            phase1=config.phases["water"].to_properties(),
            phase2=config.phases["nitrogen"].to_properties(),
        )

    def create_initial_state(self) -> SimulationState:
        """初期状態を生成

        Returns:
            初期化された状態
        """
        # グリッドの設定
        shape = tuple(self.config.domain.dimensions)
        dx = self.config.domain.size[0] / shape[0]

        # フィールドの初期化
        velocity = self._initialize_velocity(shape, dx)
        levelset = self._initialize_levelset(shape, dx)
        pressure = self._initialize_pressure(shape, dx)

        # 状態の作成
        return SimulationState(
            velocity=velocity,
            levelset=levelset,
            pressure=pressure,
            properties=self.properties,
        )

    def _initialize_velocity(self, shape: Tuple[int, ...], dx: float) -> VectorField:
        """速度場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔

        Returns:
            初期化された速度場
        """
        velocity = VectorField(shape, dx)

        # 初期速度設定
        vel_config = self.config.initial_condition.velocity
        if vel_config.get("type", "zero") == "uniform":
            values = vel_config.get("values", [0, 0, 0])
            for i, component in enumerate(velocity.components):
                if i < len(values):
                    component.data.fill(values[i])

        return velocity

    def _initialize_levelset(self, shape: Tuple[int, ...], dx: float) -> LevelSetField:
        """レベルセット場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔

        Returns:
            初期化されたレベルセット場
        """
        levelset = LevelSetField(
            shape, dx, params=LevelSetParameters(**self.config.solver.level_set)
        )

        # 背景水層の初期化
        if self.config.initial_condition.background_layer:
            height = self.config.initial_condition.background_layer
            z = np.linspace(0, 1, shape[2])
            Z = np.tile(z, (shape[0], shape[1], 1))
            levelset.data = height - Z

        # オブジェクトの初期化
        for obj in self.config.initial_condition.objects:
            self._initialize_object(levelset, obj)

        return levelset

    def _initialize_object(self, levelset: LevelSetField, obj: ObjectConfig):
        """オブジェクトを初期化

        Args:
            levelset: レベルセット場
            obj: オブジェクトの設定
        """
        if obj.type == "sphere":
            center = np.array(obj.center)
            radius = obj.radius

            # グリッド座標の生成
            x = np.linspace(0, 1, levelset.shape[0])
            y = np.linspace(0, 1, levelset.shape[1])
            z = np.linspace(0, 1, levelset.shape[2])
            X, Y, Z = np.meshgrid(x, y, z, indexing="ij")

            # 球の距離関数を計算
            dist = np.sqrt(
                (X - center[0]) ** 2 + (Y - center[1]) ** 2 + (Z - center[2]) ** 2
            )

            # レベルセット場を更新
            phi_sphere = dist - radius
            phi_sphere *= -1 if obj.phase == "water" else 1

            if obj.phase == "water":
                levelset.data = np.minimum(levelset.data, phi_sphere)
            else:
                levelset.data = np.maximum(levelset.data, phi_sphere)

    def _initialize_pressure(self, shape: Tuple[int, ...], dx: float) -> ScalarField:
        """静水圧分布を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔

        Returns:
            初期化された圧力場
        """
        pressure = ScalarField(shape, dx)

        # 重力加速度
        g = self.config.physics.gravity

        # 密度場の計算
        density = self.properties.compute_density(
            np.zeros(shape)  # 初期状態での密度計算用の疑似レベルセット
        )

        # 高さ方向に静水圧分布を設定
        z = np.linspace(0, 1, shape[2])
        Z = np.tile(z, (shape[0], shape[1], 1))

        pressure.data = density * g * (1.0 - Z)

        return pressure

```

### simulations/state.py

```
"""シミュレーション状態を保持するモジュール

リファクタリングされたphysics/パッケージに対応した更新版
"""

from dataclasses import dataclass
from typing import Optional
import numpy as np

from physics.levelset import LevelSetField, LevelSetPropertiesManager
from core.field import VectorField, ScalarField, ConservedField


@dataclass
class SimulationState:
    """シミュレーションの状態を保持するクラス

    流れ場と界面の情報を保持し、高度な状態管理を実現
    """

    velocity: VectorField
    levelset: LevelSetField
    pressure: ScalarField
    time: float = 0.0
    properties: Optional[LevelSetPropertiesManager] = None

    def copy(self) -> "SimulationState":
        """状態の深いコピーを作成

        Returns:
            コピーされた状態
        """
        return SimulationState(
            velocity=self.velocity.copy(),
            levelset=self.levelset.copy(),
            pressure=self.pressure.copy(),
            time=self.time,
            properties=self.properties,
        )

    def get_phase_fields(self) -> dict:
        """各相の特性を表すフィールドを取得

        Returns:
            フィールドの辞書
        """
        if self.properties is None:
            return {}

        return {
            "density": self.properties.compute_density(self.levelset),
            "viscosity": self.properties.compute_viscosity(self.levelset),
        }

    def get_energy(self) -> dict:
        """エネルギー関連の量を計算

        Returns:
            エネルギー関連の値の辞書
        """
        # 運動エネルギー
        kinetic_energy = sum(
            0.5 * np.sum(comp.data**2) for comp in self.velocity.components
        )

        # 位置エネルギー（重力による）
        potential_energy = 0.0
        if self.properties is not None:
            density = self.properties.compute_density(self.levelset)
            g = 9.81  # 重力加速度
            z = np.linspace(0, 1, self.levelset.shape[2])
            potential_energy = np.sum(density * g * z)

        return {
            "kinetic": float(kinetic_energy),
            "potential": float(potential_energy),
            "total": float(kinetic_energy + potential_energy),
        }

    def compute_conservation(self) -> dict:
        """保存則の評価

        Returns:
            各物理量の保存則評価結果
        """
        conserved_vars = {
            "mass": ConservedField(self.properties.compute_density(self.levelset)),
            "momentum": ConservedField(sum(v.data for v in self.velocity.components)),
        }

        return {var: field.conservation_error for var, field in conserved_vars.items()}

```

### simulations/config.py

```
"""シミュレーション設定を管理するモジュール

リファクタリングされたphysics/パッケージに対応した更新版
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Union
import yaml

from physics.levelset import FluidPhaseProperties


@dataclass
class DomainConfig:
    """計算領域の設定"""

    dimensions: List[int]
    size: List[float]

    def validate(self):
        """設定値の妥当性を検証"""
        if len(self.dimensions) != 3 or len(self.size) != 3:
            raise ValueError("dimensionsとsizeは3次元である必要があります")
        if any(n <= 0 for n in self.dimensions):
            raise ValueError("グリッド数は正の整数である必要があります")
        if any(s <= 0 for s in self.size):
            raise ValueError("領域サイズは正の値である必要があります")


@dataclass
class PhysicsConfig:
    """物理パラメータの設定"""

    gravity: float = 9.81
    surface_tension: float = 0.072


@dataclass
class PhaseConfig:
    """各相の物性値設定"""

    density: float
    viscosity: float
    surface_tension: Optional[float] = None

    def to_properties(self) -> FluidPhaseProperties:
        """FluidPropertiesインスタンスに変換"""
        return FluidPhaseProperties(
            density=self.density,
            viscosity=self.viscosity,
            surface_tension=self.surface_tension,
        )


@dataclass
class SolverConfig:
    """ソルバーの設定"""

    time_integrator: str = "rk4"
    use_weno: bool = True
    weno_order: int = 5
    level_set: Dict[str, Any] = field(
        default_factory=lambda: {
            "epsilon": 1.0e-2,
            "reinit_interval": 5,
            "reinit_steps": 2,
        }
    )
    pressure_solver: Dict[str, Any] = field(
        default_factory=lambda: {
            "method": "sor",
            "relaxation_parameter": 1.5,
            "tolerance": 1e-6,
            "max_iterations": 1000,
        }
    )


@dataclass
class TimeConfig:
    """時間発展の設定"""

    max_time: float
    cfl: float = 0.5
    min_dt: float = 1e-6
    max_dt: float = 1.0
    save_interval: float = 0.1


@dataclass
class ObjectConfig:
    """物体の設定"""

    type: str
    phase: str
    center: List[float]
    radius: float


@dataclass
class InitialConditionConfig:
    """初期条件の設定"""

    background_layer: Optional[float] = None
    objects: List[ObjectConfig] = field(default_factory=list)
    velocity: Dict[str, Any] = field(default_factory=lambda: {"type": "zero"})


@dataclass
class OutputConfig:
    """出力の設定"""

    directory: str = "results/visualization"
    output_dir: str = "results/visualization"
    format: str = "png"
    dpi: int = 300
    colormap: str = "viridis"
    show_colorbar: bool = True
    show_axes: bool = True
    show_grid: bool = False

    fields: Dict[str, Dict[str, Any]] = field(
        default_factory=lambda: {
            "velocity": {"enabled": False, "plot_types": ["vector"]},
            "pressure": {"enabled": True, "plot_types": ["scalar"]},
            "levelset": {"enabled": True, "plot_types": ["interface"]},
        }
    )

    slices: Dict[str, List[Union[str, float]]] = field(
        default_factory=lambda: {"axes": ["xy", "xz", "yz"], "positions": [0.5]}
    )

    def __post_init__(self):
        """初期化後の処理"""
        if self.output_dir:
            self.directory = self.output_dir


@dataclass
class SimulationConfig:
    """シミュレーション全体の設定"""

    domain: DomainConfig
    physics: PhysicsConfig
    phases: Dict[str, PhaseConfig]
    solver: SolverConfig
    time: TimeConfig
    initial_condition: InitialConditionConfig
    output: OutputConfig = field(default_factory=OutputConfig)

    @property
    def output_dir(self) -> str:
        """出力ディレクトリを取得"""
        return self.output.directory

    @classmethod
    def from_yaml(cls, filepath: str) -> "SimulationConfig":
        """YAMLファイルから設定を読み込む

        Args:
            filepath: 設定ファイルのパス

        Returns:
            読み込まれた設定
        """
        with open(filepath, "r", encoding="utf-8") as f:
            config_dict = yaml.safe_load(f)

        return cls(
            domain=DomainConfig(**config_dict.get("domain", {})),
            physics=PhysicsConfig(**config_dict.get("physics", {})),
            phases={
                name: PhaseConfig(**props)
                for name, props in config_dict.get("phases", {}).items()
            },
            solver=SolverConfig(**config_dict.get("solver", {})),
            time=TimeConfig(
                max_time=config_dict.get("time", {}).get("max_time", 1.0),
                save_interval=config_dict.get("time", {}).get("save_interval", 0.1),
            ),
            initial_condition=InitialConditionConfig(
                background_layer=config_dict.get("initial_conditions", {})
                .get("background", {})
                .get("height_fraction"),
                objects=[
                    ObjectConfig(**obj)
                    for obj in config_dict.get("initial_conditions", {}).get(
                        "objects", []
                    )
                ],
                velocity=config_dict.get("initial_conditions", {}).get(
                    "velocity", {"type": "zero"}
                ),
            ),
            output=OutputConfig(**config_dict.get("output", {})),
        )

    def save(self, filepath: str):
        """設定をYAMLファイルに保存

        Args:
            filepath: 保存先のパス
        """
        config_dict = {
            "domain": self.domain.__dict__,
            "physics": self.physics.__dict__,
            "phases": {name: phase.__dict__ for name, phase in self.phases.items()},
            "solver": self.solver.__dict__,
            "time": self.time.__dict__,
            "initial_condition": {
                "background_layer": self.initial_condition.background_layer,
                "objects": [obj.__dict__ for obj in self.initial_condition.objects],
                "velocity": self.initial_condition.velocity,
            },
            "output": self.output.__dict__,
        }

        with open(filepath, "w", encoding="utf-8") as f:
            yaml.dump(config_dict, f, default_flow_style=False)

```

### simulations/simulation.py

```
"""二相流シミュレーションの主要クラスを提供するモジュール

リファクタリングされたphysics/パッケージに対応した更新版
"""

from typing import Dict, Any, Tuple, Optional
from pathlib import Path
import numpy as np

from physics.levelset import LevelSetPropertiesManager, LevelSetSolver
from physics.navier_stokes import solvers, terms
from physics.time_evolution import TimeEvolutionSolver


from .config import SimulationConfig
from .state import SimulationState
from .initializer import SimulationInitializer


class TwoPhaseFlowSimulator:
    """二相流シミュレーションクラス

    リファクタリングされたphysics/パッケージを活用した
    高度な二相流シミュレーションを実現
    """

    def __init__(self, config: SimulationConfig, logger=None):
        """シミュレーションを初期化

        Args:
            config: シミュレーション設定
            logger: ロガー（オプション）
        """
        self.config = config
        self.logger = logger

        # 物性値マネージャーの初期化
        self._properties = LevelSetPropertiesManager(
            phase1=config.phases["water"].to_properties(),
            phase2=config.phases["nitrogen"].to_properties(),
        )

        # ソルバーコンポーネントの初期化
        self._initialize_solvers()

    def _initialize_solvers(self):
        """ソルバーコンポーネントを初期化"""
        # 移流項
        advection_term = terms.AdvectionTerm(
            use_weno=self.config.solver.use_weno,
            weno_order=self.config.solver.weno_order,
        )

        # 粘性項
        diffusion_term = terms.DiffusionTerm(use_conservative=True)

        # 外力項（重力など）
        gravity_force = terms.GravityForce(gravity=self.config.physics.gravity)
        force_term = terms.ForceTerm(forces=[gravity_force])

        # 圧力項
        pressure_term = terms.PressureTerm()

        # Navier-Stokesソルバーの設定
        self._ns_solver = solvers.ProjectionSolver(
            terms=[advection_term, diffusion_term, force_term, pressure_term],
            properties=self._properties,
            use_rotational=True,
        )

        # Level Setソルバーの設定
        self._ls_solver = LevelSetSolver(
            use_weno=self.config.solver.use_weno,
            weno_order=self.config.solver.weno_order,
        )

        # 時間発展ソルバー
        self._time_solver = TimeEvolutionSolver(
            terms=[self._ns_solver, self._ls_solver],
            integrator_type=self.config.solver.time_integrator,
        )

    def initialize(self, state: Optional[SimulationState] = None):
        """シミュレーションを初期化

        Args:
            state: 初期状態（オプション）
        """
        if state is None:
            initializer = SimulationInitializer(self.config)
            state = initializer.create_initial_state()

        self._time_solver.initialize(state)
        self._current_state = state  # 現在の状態を保持

    def get_state(self) -> Tuple[SimulationState, Dict[str, Any]]:
        """現在のシミュレーション状態を取得

        Returns:
            現在の状態と診断情報のタプル
        """
        return self._current_state, {
            "time": self._time_solver.time,
            "dt": self._time_solver.dt,
            "iteration": self._time_solver.iteration_count,
        }

    def step_forward(self) -> Tuple[SimulationState, Dict[str, Any]]:
        """1時間ステップを進める

        Returns:
            更新された状態と診断情報
        """
        return self._time_solver.step_forward()

    def save_checkpoint(self, filepath: str):
        """シミュレーション状態をチェックポイントとして保存

        Args:
            filepath: 保存先のファイルパス
        """
        # チェックポイントディレクトリを作成
        output_dir = Path(filepath).parent
        output_dir.mkdir(parents=True, exist_ok=True)

        # 現在の状態を取得
        state, diagnostics = self.get_state()

        # NumPyを使用してチェックポイントを保存
        np.savez(
            filepath,
            velocity_components=[v.data for v in state.velocity.components],
            velocity_shape=state.velocity.shape,
            velocity_dx=state.velocity.dx,
            levelset_data=state.levelset.data,
            levelset_shape=state.levelset.shape,
            levelset_dx=state.levelset.dx,
            pressure_data=state.pressure.data,
            pressure_shape=state.pressure.shape,
            pressure_dx=state.pressure.dx,
            simulation_time=state.time,
            # 追加のメタデータ
            diagnostics=diagnostics,
        )

        # ロギング
        if self.logger:
            self.logger.info(f"チェックポイントを保存: {filepath}")

    def load_checkpoint(self, filepath: str):
        """チェックポイントから状態を復元

        Args:
            filepath: 読み込むチェックポイントファイルのパス

        Returns:
            復元された状態
        """
        try:
            # チェックポイントファイルを読み込み
            with np.load(filepath, allow_pickle=True) as checkpoint:
                # 速度場の復元
                from core.field import VectorField

                velocity = VectorField(
                    tuple(checkpoint["velocity_shape"]), checkpoint["velocity_dx"]
                )
                for i, comp in enumerate(velocity.components):
                    comp.data = checkpoint["velocity_components"][i]

                # レベルセット場の復元
                from physics.levelset import LevelSetField

                levelset = LevelSetField(
                    tuple(checkpoint["levelset_shape"]), checkpoint["levelset_dx"]
                )
                levelset.data = checkpoint["levelset_data"]

                # 圧力場の復元
                from core.field import ScalarField

                pressure = ScalarField(
                    tuple(checkpoint["pressure_shape"]), checkpoint["pressure_dx"]
                )
                pressure.data = checkpoint["pressure_data"]

                # シミュレーション状態の復元
                from .state import SimulationState

                state = SimulationState(
                    velocity=velocity,
                    levelset=levelset,
                    pressure=pressure,
                    time=float(checkpoint["simulation_time"]),
                    properties=self._properties,
                )

                # ロギング
                if self.logger:
                    self.logger.info(f"チェックポイントから復元: {filepath}")

                return state

        except Exception as e:
            if self.logger:
                self.logger.error(f"チェックポイントの読み込み中にエラー: {e}")
            raise

```

### simulations/__init__.py

```
"""二相流シミュレーションパッケージ

リファクタリングされたphysics/パッケージに対応した更新版
"""

from .simulation import TwoPhaseFlowSimulator
from .state import SimulationState
from .initializer import SimulationInitializer
from .config import (
    SimulationConfig,
    DomainConfig,
    PhysicsConfig,
    PhaseConfig,
    SolverConfig,
    TimeConfig,
    ObjectConfig,
    InitialConditionConfig,
    OutputConfig,
)

__all__ = [
    # メインクラス
    "TwoPhaseFlowSimulator",
    "SimulationState",
    "SimulationInitializer",
    # 設定関連クラス
    "SimulationConfig",
    "DomainConfig",
    "PhysicsConfig",
    "PhaseConfig",
    "SolverConfig",
    "TimeConfig",
    "ObjectConfig",
    "InitialConditionConfig",
    "OutputConfig",
]

```

### visualization/core/base.py

```
"""可視化システムの基本クラスとインターフェースを提供するモジュール

このモジュールは可視化システムの設定とインターフェースを定義します。すべての
可視化コンポーネントの基盤となります。
"""

from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Union, Tuple
from pathlib import Path


@dataclass
class ViewConfig:
    """可視化の表示設定

    3D表示やスライス表示の視点・断面を制御します。

    Attributes:
        elevation: 仰角（度）
        azimuth: 方位角（度）
        distance: 視点距離
        focal_point: 注視点座標 (x, y, z)
        slice_positions: 各軸でのスライス位置 [0-1]
        slice_axes: 表示する断面の軸 (例: ["xy", "yz", "xz"])
    """

    elevation: float = 30.0
    azimuth: float = 45.0
    distance: float = 10.0
    focal_point: Tuple[float, float, float] = (0.5, 0.5, 0.5)
    slice_positions: List[float] = field(default_factory=lambda: [0.5, 0.5, 0.5])
    slice_axes: List[str] = field(default_factory=lambda: ["xy", "yz", "xz"])

    def validate(self):
        """設定値の検証"""
        if len(self.slice_positions) != 3:
            raise ValueError("slice_positionsは3つの要素を持つ必要があります")
        if any(not 0 <= pos <= 1 for pos in self.slice_positions):
            raise ValueError("slice_positionsは0から1の間である必要があります")
        valid_axes = {"xy", "yz", "xz", "yx", "zy", "zx"}
        if any(axis not in valid_axes for axis in self.slice_axes):
            raise ValueError(f"無効なslice_axes: {valid_axes}から選択してください")


@dataclass
class VisualizationConfig:
    """可視化の基本設定

    出力形式や表示オプションを制御します。

    Attributes:
        output_dir: 出力ディレクトリ
        format: 出力フォーマット
        dpi: 解像度
        colormap: デフォルトのカラーマップ
        show_colorbar: カラーバーの表示
        show_axes: 軸の表示
        show_grid: グリッドの表示
        fields: フィールドごとの可視化設定
    """

    output_dir: Union[str, Path] = "results/visualization"
    format: str = "png"
    dpi: int = 300
    colormap: str = "viridis"
    show_colorbar: bool = True
    show_axes: bool = True
    show_grid: bool = False

    # フィールドごとの可視化設定
    fields: Dict[str, Dict[str, Any]] = field(
        default_factory=lambda: {
            "velocity": {
                "enabled": True,
                "plot_types": ["vector", "magnitude"],
                "scale": 1.0,
                "density": 20,
                "color": "black",
                "alpha": 0.7,
            },
            "pressure": {
                "enabled": True,
                "plot_types": ["scalar", "contour"],
                "levels": 20,
                "alpha": 0.5,
            },
            "levelset": {
                "enabled": True,
                "plot_types": ["interface", "contour"],
                "levels": [0],
                "colors": ["black"],
                "linewidth": 2.0,
            },
        }
    )

    def __post_init__(self):
        """設定の後処理と検証"""
        if isinstance(self.output_dir, str):
            self.output_dir = Path(self.output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def get_output_path(self, name: str, timestamp: Optional[float] = None) -> Path:
        """出力ファイルパスを生成

        Args:
            name: ベース名
            timestamp: タイムスタンプ（オプション）

        Returns:
            生成されたパス
        """
        if timestamp is not None:
            filename = f"{name}_{timestamp:.6f}.{self.format}"
        else:
            filename = f"{name}.{self.format}"
        return self.output_dir / filename

    def get_field_config(
        self, section: str, default: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """指定されたセクションの設定を取得

        Args:
            section: 設定セクション名
            default: デフォルト値（オプション）

        Returns:
            設定辞書（存在しない場合はデフォルト設定）
        """
        import yaml
        import os

        # コンフィグファイルの読み込み
        config_path = os.path.join(os.getcwd(), "config.yaml")

        try:
            with open(config_path, "r") as f:
                full_config = yaml.safe_load(f)

            # 指定されたセクションの設定を取得
            section_config = full_config.get(section, {})
            return section_config
        except Exception as e:
            print(f"設定ファイルの読み込み中にエラー: {e}")
            return default or {}

    @classmethod
    def from_dict(cls, config: Dict[str, Any]) -> "VisualizationConfig":
        """辞書から設定を作成

        Args:
            config: 設定辞書

        Returns:
            設定インスタンス
        """
        # 基本設定の取得
        base_config = {
            "output_dir": config.get("output_dir", "results/visualization"),
            "format": config.get("format", "png"),
            "dpi": config.get("dpi", 300),
            "colormap": config.get("colormap", "viridis"),
            "show_colorbar": config.get("show_colorbar", True),
            "show_axes": config.get("show_axes", True),
            "show_grid": config.get("show_grid", False),
        }

        # フィールド設定の取得とマージ
        fields = {}
        for field_name, field_config in config.get("fields", {}).items():
            fields[field_name] = {
                "enabled": field_config.get("enabled", True),
                "plot_types": field_config.get("plot_types", ["scalar"]),
                **field_config,
            }

        return cls(**base_config, fields=fields)


class Exporter:
    """エクスポーターの基底クラス

    描画結果をファイルとして出力する基底クラス
    """

    def __init__(self, config: VisualizationConfig):
        """エクスポーターを初期化

        Args:
            config: 可視化設定
        """
        self.config = config

    def export(
        self, figure: Any, filepath: Path, metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """描画結果を出力

        Args:
            figure: 描画結果
            filepath: 出力パス
            metadata: メタデータ（オプション）
        """
        raise NotImplementedError("サブクラスで実装する必要があります")

```

### visualization/core/exporter.py

```
"""可視化結果のエクスポートを提供するモジュール

このモジュールは、Matplotlibの描画結果を画像ファイルとして
出力する機能を実装します。
"""

import json
from pathlib import Path
from typing import Dict, Any, Optional
import matplotlib.pyplot as plt

from .base import Exporter, VisualizationConfig


class ImageExporter(Exporter):
    """画像エクスポーター

    Matplotlibの描画結果を画像ファイルとして出力します。
    メタデータもJSONファイルとして保存できます。
    """

    def __init__(self, config: VisualizationConfig):
        """画像エクスポーターを初期化"""
        super().__init__(config)

    def export(
        self,
        figure: plt.Figure,
        filepath: Path,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> None:
        """描画結果を画像として出力

        Args:
            figure: Matplotlibの図
            filepath: 出力ファイルパス
            metadata: メタデータ（オプション）
        """
        # 出力ディレクトリの作成
        filepath.parent.mkdir(parents=True, exist_ok=True)

        # 画像として保存
        figure.savefig(
            filepath,
            dpi=self.config.dpi,
            format=self.config.format,
            bbox_inches="tight",
        )

        # メタデータの保存
        if metadata is not None:
            metadata_path = filepath.with_suffix(".json")
            with open(metadata_path, "w", encoding="utf-8") as f:
                json.dump(metadata, f, indent=2, ensure_ascii=False)

        # 図のクリーンアップ
        plt.close(figure)

```

### visualization/core/renderer.py

```
"""レンダリングエンジンの基底クラスを提供するモジュール

このモジュールは、2D/3Dレンダリングの基本機能を提供します。
matplotlibを使用した描画処理の共通部分を実装します。
"""

from abc import ABC, abstractmethod
from typing import Tuple, Dict, Any, Optional, List, Union, TYPE_CHECKING
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.axes import Axes
from matplotlib import colormaps
from matplotlib.colors import Normalize, LinearSegmentedColormap
from matplotlib.collections import QuadMesh

if TYPE_CHECKING:
    from .base import VisualizationConfig, ViewConfig


class BaseRenderer(ABC):
    """レンダラーの基底クラス

    全てのレンダラーに共通の機能を提供します。
    """

    def __init__(self, config: "VisualizationConfig"):
        """レンダラーを初期化

        Args:
            config: 可視化設定
        """
        self.config = config

    def create_figure(
        self, projection: Optional[str] = None, figsize: Tuple[float, float] = (10, 8)
    ) -> Tuple[Figure, Axes]:
        """図とAxesを作成

        Args:
            projection: プロジェクションの種類
            figsize: 図のサイズ

        Returns:
            (図, Axes)のタプル
        """
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection=projection)

        # 軸の設定
        if not self.config.show_axes:
            ax.set_axis_off()

        # グリッドの設定
        if self.config.show_grid:
            ax.grid(True)

        return fig, ax

    def setup_colorbar(
        self,
        mappable: Union[QuadMesh, plt.cm.ScalarMappable],
        ax: Axes,
        label: str = "",
        orientation: str = "vertical",
    ) -> Optional[Any]:
        """カラーバーを設定

        Args:
            mappable: カラーマップを持つオブジェクト
            ax: 対象のAxes
            label: カラーバーのラベル
            orientation: カラーバーの向き

        Returns:
            作成されたカラーバー
        """
        if self.config.show_colorbar:
            return plt.colorbar(mappable, ax=ax, label=label, orientation=orientation)
        return None

    def compute_data_range(
        self,
        data: np.ndarray,
        symmetric: bool = False,
        robust: bool = True,
        percentile: float = 2.0,
    ) -> Tuple[float, float]:
        """データの範囲を計算

        Args:
            data: 入力データ
            symmetric: 対称な範囲にするかどうか
            robust: 外れ値に対してロバストな範囲を使用するか
            percentile: ロバスト範囲計算時のパーセンタイル

        Returns:
            (最小値, 最大値)のタプル
        """
        valid_data = data[np.isfinite(data)]
        if len(valid_data) == 0:
            return 0.0, 1.0

        if robust:
            vmin = np.percentile(valid_data, percentile)
            vmax = np.percentile(valid_data, 100 - percentile)
        else:
            vmin = np.min(valid_data)
            vmax = np.max(valid_data)

        if symmetric:
            abs_max = max(abs(vmin), abs(vmax))
            return -abs_max, abs_max

        return vmin, vmax

    def create_normalizer(
        self, data: np.ndarray, symmetric: bool = False, robust: bool = True
    ) -> Normalize:
        """データの正規化オブジェクトを作成

        Args:
            data: 入力データ
            symmetric: 対称な範囲にするかどうか
            robust: 外れ値に対してロバストな範囲を使用するか

        Returns:
            正規化オブジェクト
        """
        vmin, vmax = self.compute_data_range(data, symmetric, robust)
        return Normalize(vmin=vmin, vmax=vmax)

    def create_colormap(
        self,
        name: Optional[str] = None,
        colors: Optional[List[str]] = None,
        reverse: bool = False,
    ) -> LinearSegmentedColormap:
        """カラーマップを作成

        Args:
            name: カラーマップ名（Noneの場合はcolorsを使用）
            colors: カラーのリスト
            reverse: カラーマップを反転するかどうか

        Returns:
            作成されたカラーマップ
        """
        if colors is not None:
            cmap = LinearSegmentedColormap.from_list("custom", colors)
        else:
            cmap = colormaps[name or self.config.colormap]

        if reverse:
            return LinearSegmentedColormap.from_list(
                f"{cmap.name}_r", cmap(np.linspace(1, 0, cmap.N))
            )
        return cmap

    @abstractmethod
    def render(self, *args, **kwargs) -> Tuple[Figure, Dict[str, Any]]:
        """描画を実行

        Args:
            *args: 位置引数
            **kwargs: キーワード引数

        Returns:
            (図, メタデータの辞書)のタプル
        """
        pass


class Renderer2D(BaseRenderer):
    """2Dレンダラーの基底クラス"""

    def setup_2d_axes(
        self,
        ax: Axes,
        extent: Optional[Tuple[float, float, float, float]] = None,
        aspect: str = "equal",
    ) -> None:
        """2D軸を設定

        Args:
            ax: 対象のAxes
            extent: データの表示範囲 [xmin, xmax, ymin, ymax]
            aspect: アスペクト比の設定
        """
        if extent is not None:
            ax.set_xlim(extent[0], extent[1])
            ax.set_ylim(extent[2], extent[3])

        ax.set_aspect(aspect)

        if self.config.show_axes:
            ax.set_xlabel("X")
            ax.set_ylabel("Y")

    def create_slice(self, data: np.ndarray, axis: int, position: float) -> np.ndarray:
        """3Dデータから2Dスライスを抽出

        Args:
            data: 3Dデータ
            axis: スライスする軸
            position: スライス位置（0-1）

        Returns:
            抽出された2Dスライス
        """
        if data.ndim != 3:
            raise ValueError("3Dデータが必要です")

        # スライスインデックスを計算
        idx = int(position * (data.shape[axis] - 1))

        # データのスライスを取得
        slices = [slice(None)] * 3
        slices[axis] = slice(idx, idx + 1)
        slice_data = data[tuple(slices)]

        # 余分な次元を削除
        return np.squeeze(slice_data)


class Renderer3D(BaseRenderer):
    """3Dレンダラーの基底クラス"""

    def setup_3d_axes(
        self,
        ax: Axes,
        view: Optional["ViewConfig"] = None,
        bounds: Optional[Tuple[np.ndarray, np.ndarray]] = None,
    ) -> None:
        """3D軸を設定

        Args:
            ax: 対象のAxes
            view: 視点設定
            bounds: データの境界 [(xmin, ymin, zmin), (xmax, ymax, zmax)]
        """
        if view is not None:
            ax.view_init(elev=view.elevation, azim=view.azimuth)
            ax.dist = view.distance

        if bounds is not None:
            min_point, max_point = bounds
            ax.set_xlim(min_point[0], max_point[0])
            ax.set_ylim(min_point[1], max_point[1])
            ax.set_zlim(min_point[2], max_point[2])

        if self.config.show_axes:
            ax.set_xlabel("X")
            ax.set_ylabel("Y")
            ax.set_zlabel("Z")

```

### visualization/core/__init__.py

```
"""可視化システムのコアモジュール

このパッケージは、可視化システムの中核となる基底クラスとインターフェースを提供します。
"""

# 基本的な設定とインターフェースを先にインポート
from .base import VisualizationConfig, ViewConfig

# その後でレンダラーをインポート
from .renderer import BaseRenderer, Renderer2D, Renderer3D
from .exporter import ImageExporter

__all__ = [
    "VisualizationConfig",
    "ViewConfig",
    "BaseRenderer",
    "Renderer2D",
    "Renderer3D",
    "ImageExporter",
]

```

### visualization/interfaces.py

```
"""可視化のためのインターフェースと抽象クラス"""

from abc import ABC, abstractmethod
from typing import Any, Optional, Dict
from .core.base import ViewConfig


class VisualizationStrategy(ABC):
    """可視化戦略の抽象基底クラス"""

    @abstractmethod
    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """データを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        pass


class MultiFieldVisualizationStrategy(VisualizationStrategy):
    """複数のフィールドを同時に可視化する戦略"""

    @abstractmethod
    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        pass


class VisualizationContext:
    """可視化のコンテキストを管理するクラス"""

    def __init__(self, strategy: VisualizationStrategy):
        """可視化戦略を設定

        Args:
            strategy: 使用する可視化戦略
        """
        self._strategy = strategy

    def set_strategy(self, strategy: VisualizationStrategy):
        """可視化戦略を動的に変更

        Args:
            strategy: 新しい可視化戦略
        """
        self._strategy = strategy

    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """データを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        return self._strategy.visualize(data, name, timestamp, view, **kwargs)

    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        if isinstance(self._strategy, MultiFieldVisualizationStrategy):
            return self._strategy.visualize_combined(
                fields, name, timestamp, view, **kwargs
            )
        raise NotImplementedError(
            "現在の可視化戦略は複数フィールドの可視化をサポートしていません"
        )


class VisualizationFactory:
    """可視化戦略を生成するファクトリクラス"""

    @staticmethod
    def create_strategy(
        strategy_type: str, config: Dict[str, Any]
    ) -> VisualizationStrategy:
        """指定された型の可視化戦略を生成

        Args:
            strategy_type: 可視化戦略の種類
            config: 設定辞書

        Returns:
            生成された可視化戦略
        """
        from .renderer_strategy import (
            Renderer2DVisualizationStrategy,
            Renderer3DVisualizationStrategy,
        )

        strategies = {
            "2d": Renderer2DVisualizationStrategy,
            "3d": Renderer3DVisualizationStrategy,
        }

        if strategy_type.lower() not in strategies:
            raise ValueError(f"未知の可視化戦略: {strategy_type}")

        return strategies[strategy_type.lower()](config)

```

### visualization/utils/colormap.py

```
"""カラーマップ操作のユーティリティを提供するモジュール

このモジュールは、データの可視化に使用するカラーマップの
生成と操作に関する機能を提供します。
"""

from typing import List, Optional
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap, Normalize


def create_custom_colormap(
    colors: List[str], name: str = "custom", n_bins: int = 256
) -> LinearSegmentedColormap:
    """カスタムカラーマップを作成

    Args:
        colors: カラーのリスト
        name: カラーマップの名前
        n_bins: 色の分割数

    Returns:
        作成されたカラーマップ
    """
    return LinearSegmentedColormap.from_list(name, colors, N=n_bins)


def create_diverging_colormap(
    neutral_point: float = 0.0,
    vmin: float = -1.0,
    vmax: float = 1.0,
    colors: Optional[List[str]] = None,
) -> LinearSegmentedColormap:
    """発散型カラーマップを作成

    Args:
        neutral_point: 中立点の値
        vmin: 最小値
        vmax: 最大値
        colors: カラーのリスト（省略時は blue-white-red）

    Returns:
        作成されたカラーマップ
    """
    if colors is None:
        colors = ["blue", "white", "red"]

    # 中立点の相対位置を計算
    total_range = vmax - vmin
    if total_range <= 0:
        raise ValueError("無効なデータ範囲です")

    neutral_pos = (neutral_point - vmin) / total_range
    neutral_pos = np.clip(neutral_pos, 0, 1)

    # カラーマップの作成
    if neutral_pos == 0.5:
        # 対称なカラーマップ
        return create_custom_colormap(colors)
    else:
        # 非対称なカラーマップ
        positions = [0, neutral_pos, 1]
        return LinearSegmentedColormap.from_list(
            "diverging", list(zip(positions, colors))
        )


def apply_colormap(
    data: np.ndarray,
    vmin: Optional[float] = None,
    vmax: Optional[float] = None,
    cmap: str = "viridis",
    symmetric: bool = False,
    alpha: Optional[float] = None,
) -> np.ndarray:
    """データにカラーマップを適用

    Args:
        data: 入力データ
        vmin: 最小値（省略時は自動計算）
        vmax: 最大値（省略時は自動計算）
        cmap: カラーマップ名
        symmetric: 対称な範囲にするかどうか
        alpha: 透明度

    Returns:
        RGBA形式のカラー配列
    """
    # データ範囲の計算
    if vmin is None:
        vmin = np.nanmin(data)
    if vmax is None:
        vmax = np.nanmax(data)

    if symmetric:
        abs_max = max(abs(vmin), abs(vmax))
        vmin, vmax = -abs_max, abs_max

    # 正規化とカラーマップの適用
    norm = Normalize(vmin=vmin, vmax=vmax)
    mapper = plt.get_cmap(cmap)
    colors = mapper(norm(data))

    # 透明度の設定
    if alpha is not None:
        colors[..., 3] = alpha

    return colors

```

### visualization/utils/camera.py

```
"""カメラ設定を管理するモジュール

このモジュールは、3D可視化におけるカメラパラメータの
管理と変換を担当します。
"""

from dataclasses import dataclass, field
import numpy as np
from typing import Tuple, Optional

from ..core.base import ViewConfig


@dataclass
class CameraState:
    """カメラの状態を表すクラス

    位置、方向、上方向ベクトルなどを保持します。
    """

    position: np.ndarray = field(default_factory=lambda: np.zeros(3))
    target: np.ndarray = field(default_factory=lambda: np.zeros(3))
    up: np.ndarray = field(default_factory=lambda: np.array([0, 0, 1]))

    @property
    def direction(self) -> np.ndarray:
        """視線方向を取得"""
        d = self.target - self.position
        return d / np.linalg.norm(d)

    @property
    def right(self) -> np.ndarray:
        """右方向を取得"""
        r = np.cross(self.direction, self.up)
        return r / np.linalg.norm(r)


class CameraController:
    """カメラ制御クラス

    ビュー設定とカメラ状態の変換や、
    カメラの移動・回転などの操作を提供します。
    """

    @staticmethod
    def view_to_camera(
        view: ViewConfig, bounds: Optional[Tuple[np.ndarray, np.ndarray]] = None
    ) -> CameraState:
        """ビュー設定からカメラ状態を計算

        Args:
            view: ビュー設定
            bounds: データの境界ボックス (最小点, 最大点)

        Returns:
            カメラ状態
        """
        # 注視点の設定
        if bounds is not None:
            min_point, max_point = bounds
            center = (min_point + max_point) / 2
            target = center
        else:
            target = np.array(view.focal_point)

        # 球面座標からカメラ位置を計算
        theta = np.radians(view.azimuth)  # 方位角
        phi = np.radians(90 - view.elevation)  # 極角（天頂角）

        # 単位球面上の位置
        x = np.sin(phi) * np.cos(theta)
        y = np.sin(phi) * np.sin(theta)
        z = np.cos(phi)

        # スケーリングと平行移動
        position = target + view.distance * np.array([x, y, z])

        return CameraState(position=position, target=target)

    @staticmethod
    def camera_to_view(camera: CameraState) -> ViewConfig:
        """カメラ状態からビュー設定を計算

        Args:
            camera: カメラ状態

        Returns:
            ビュー設定
        """
        # カメラから注視点へのベクトル
        direction = camera.target - camera.position
        distance = np.linalg.norm(direction)

        # 方位角と仰角を計算
        x, y, z = direction / distance

        azimuth = np.degrees(np.arctan2(y, x))
        elevation = 90 - np.degrees(np.arccos(z))

        return ViewConfig(
            elevation=elevation,
            azimuth=azimuth,
            distance=distance,
            focal_point=tuple(camera.target),
        )

    @staticmethod
    def orbit_camera(
        camera: CameraState, delta_azimuth: float, delta_elevation: float
    ) -> CameraState:
        """カメラを軌道運動させる

        Args:
            camera: 現在のカメラ状態
            delta_azimuth: 方位角の変化量（度）
            delta_elevation: 仰角の変化量（度）

        Returns:
            新しいカメラ状態
        """
        # 現在のビュー設定を取得
        view = CameraController.camera_to_view(camera)

        # 角度を更新
        view.azimuth += delta_azimuth
        view.elevation = np.clip(view.elevation + delta_elevation, -89, 89)

        # 新しいカメラ状態を計算
        return CameraController.view_to_camera(view)

    @staticmethod
    def zoom_camera(camera: CameraState, zoom_factor: float) -> CameraState:
        """カメラをズームする

        Args:
            camera: 現在のカメラ状態
            zoom_factor: ズーム倍率（1より大きい場合はズームイン）

        Returns:
            新しいカメラ状態
        """
        # 現在の距離を取得
        view = CameraController.camera_to_view(camera)

        # 距離を更新
        view.distance /= zoom_factor

        # 新しいカメラ状態を計算
        return CameraController.view_to_camera(view)

    @staticmethod
    def pan_camera(camera: CameraState, delta_x: float, delta_y: float) -> CameraState:
        """カメラをパンする

        Args:
            camera: 現在のカメラ状態
            delta_x: 水平方向の移動量
            delta_y: 垂直方向の移動量

        Returns:
            新しいカメラ状態
        """
        # 移動ベクトルを計算
        right = camera.right
        up = camera.up
        offset = delta_x * right + delta_y * up

        # カメラと注視点を移動
        new_position = camera.position + offset
        new_target = camera.target + offset

        return CameraState(position=new_position, target=new_target, up=camera.up)

```

### visualization/renderer_strategy.py

```
"""可視化戦略の実装"""

from typing import Any, Optional, Dict
from .core.base import ViewConfig
from .interfaces import MultiFieldVisualizationStrategy
from .visualizer import Visualizer


class Renderer2DVisualizationStrategy(MultiFieldVisualizationStrategy):
    """2Dレンダラーを使用した可視化戦略"""

    def __init__(self, config: Dict[str, Any]):
        """戦略を初期化

        Args:
            config: 可視化設定
        """
        self.visualizer = Visualizer(config)

    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """2Dデータを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        if isinstance(data, list):  # ベクトル場
            return self.visualizer.visualize_vector(
                data, name, timestamp, view, **kwargs
            )
        else:  # スカラー場
            return self.visualizer.visualize_scalar(
                data, name, timestamp, view, **kwargs
            )

    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        # マップされたフィールドを準備
        scalar_data = fields.get("scalar") or fields.get("pressure")
        vector_data = fields.get("vector")

        return self.visualizer.visualize_combined(
            scalar_data=scalar_data,
            vector_components=vector_data,
            name=name,
            timestamp=timestamp,
            view=view,
            **kwargs,
        )


class Renderer3DVisualizationStrategy(MultiFieldVisualizationStrategy):
    """3Dレンダラーを使用した可視化戦略"""

    def __init__(self, config: Dict[str, Any]):
        """戦略を初期化

        Args:
            config: 可視化設定
        """
        self.visualizer = Visualizer(config)

    def visualize(
        self,
        data: Any,
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """3Dデータを可視化

        Args:
            data: 可視化するデータ
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        if isinstance(data, list):  # ベクトル場
            return self.visualizer.visualize_vector(
                data, name, timestamp, view, **kwargs
            )
        else:  # スカラー場
            return self.visualizer.visualize_scalar(
                data, name, timestamp, view, **kwargs
            )

    def visualize_combined(
        self,
        fields: Dict[str, Any],
        name: str,
        timestamp: float = 0.0,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """複数のフィールドを組み合わせて可視化

        Args:
            fields: 可視化するフィールドの辞書
            name: 出力ファイル名のベース
            timestamp: 現在の時刻
            view: 視点設定
            **kwargs: 追加の可視化オプション

        Returns:
            生成された可視化ファイルのパス
        """
        # マップされたフィールドを準備
        scalar_data = fields.get("scalar") or fields.get("pressure")
        vector_data = fields.get("vector")
        levelset_data = fields.get("levelset")

        # レベルセットを追加の可視化オプションに含める
        if levelset_data is not None:
            if "scalar_options" not in kwargs:
                kwargs["scalar_options"] = {}
            kwargs["scalar_options"]["levelset"] = levelset_data

        return self.visualizer.visualize_combined(
            scalar_data=scalar_data,
            vector_components=vector_data,
            name=name,
            timestamp=timestamp,
            view=view,
            **kwargs,
        )

```

### visualization/renderers/vector2d.py

```
"""2Dベクトル場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any, List
from matplotlib.axes import Axes
from matplotlib.figure import Figure


class Vector2DRenderer:
    """2Dベクトル場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def render(
        self, vector_components: List[np.ndarray], ax: Optional[Axes] = None, **kwargs
    ) -> Tuple[Figure, Dict[str, Any]]:
        """2Dベクトル場を描画

        Args:
            vector_components: ベクトル場の各成分 [u, v]
            ax: 既存のAxes（Noneの場合は新規作成）
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力バリデーション
        if len(vector_components) != 2:
            raise ValueError("2次元ベクトル場には2つの成分が必要です")

        u, v = vector_components

        # 図とAxesの準備
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.figure

        # ベクトルの大きさを計算
        magnitude = np.sqrt(u**2 + v**2)

        # デフォルトのパラメータ設定
        density = kwargs.get("density", 20)
        scale = kwargs.get("scale", 1.0)
        skip = max(1, min(u.shape) // density)

        # メタデータの準備
        metadata = {
            "data_range": {
                "min_magnitude": float(np.min(magnitude)),
                "max_magnitude": float(np.max(magnitude)),
            },
            "display_type": ["vector"],
        }

        # グリッドの生成
        nx, ny = u.shape
        x = np.arange(nx)
        y = np.arange(ny)
        X, Y = np.meshgrid(x, y, indexing="ij")

        # ベクトル場の描画
        ax.quiver(
            X[::skip, ::skip],
            Y[::skip, ::skip],
            u[::skip, ::skip],
            v[::skip, ::skip],
            color="blue",  # 単純な静的な色
            scale=scale,
            alpha=kwargs.get("alpha", 0.7),
        )

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # アスペクト比と軸ラベル
        ax.set_aspect("equal")
        ax.set_xlabel("X")
        ax.set_ylabel("Y")

        return fig, metadata

```

### visualization/renderers/vector3d.py

```
"""3Dベクトル場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any, List
from matplotlib.axes import Axes


class Vector3DRenderer:
    """3Dベクトル場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def _get_slice(
        self, data: np.ndarray, slice_axis: str, slice_pos: float
    ) -> Tuple[np.ndarray, ...]:
        """指定された軸とスライス位置でデータをスライス

        Args:
            data: 入力データ配列
            slice_axis: スライス軸 ('xy', 'xz', 'yz')
            slice_pos: スライス位置 (0-1)

        Returns:
            スライスされたデータと座標
        """
        # データの形状を取得
        nx, ny, nz = data.shape

        # スライス位置のインデックスを計算
        if slice_axis == "xy":
            slice_idx = int(slice_pos * (nz - 1))
            slice_data = data[:, :, slice_idx]
            x, y = np.meshgrid(np.arange(nx), np.arange(ny), indexing="ij")
            z = np.full_like(x, slice_idx)
        elif slice_axis == "xz":
            slice_idx = int(slice_pos * (ny - 1))
            slice_data = data[:, slice_idx, :]
            x, z = np.meshgrid(np.arange(nx), np.arange(nz), indexing="ij")
            y = np.full_like(x, slice_idx)
        elif slice_axis == "yz":
            slice_idx = int(slice_pos * (nx - 1))
            slice_data = data[slice_idx, :, :]
            y, z = np.meshgrid(np.arange(ny), np.arange(nz), indexing="ij")
            x = np.full_like(y, slice_idx)
        else:
            raise ValueError(f"無効なスライス軸: {slice_axis}")

        return slice_data, x, y, z

    def render(
        self,
        vector_components: List[np.ndarray],
        ax: Optional[Axes] = None,
        view: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> Tuple[plt.Figure, Dict[str, Any]]:
        """3Dベクトル場を描画

        Args:
            vector_components: ベクトル場の各成分 [u, v, w]
            ax: 既存のAxes（Noneの場合は新規作成）
            view: スライス情報
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力バリデーション
        if len(vector_components) != 3:
            raise ValueError("3次元ベクトル場には3つの成分が必要です")

        u, v, w = vector_components

        # スライス情報の取得
        slice_axis = view.get("slice_axes", ["xy"])[0] if view else "xy"
        slice_pos = view.get("slice_positions", [0.5])[0] if view else 0.5

        # 図とAxesの準備
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="3d")
        else:
            fig = ax.figure

        # スライスの取得
        slice_data_list = []
        for component in [u, v, w]:
            slice_data, x, y, z = self._get_slice(component, slice_axis, slice_pos)
            slice_data_list.append(slice_data)

        # メタデータの準備
        metadata = {
            "data_range": {
                "min_magnitude": float(np.min(slice_data_list[0])),
                "max_magnitude": float(np.max(slice_data_list[0])),
            },
            "display_type": ["vector", "slice"],
            "slice_info": {"axis": slice_axis, "position": slice_pos},
        }

        # ベクトル場の描画
        ax.quiver(
            x,
            y,
            z,
            slice_data_list[0],
            slice_data_list[1],
            slice_data_list[2],
            color="blue",
            alpha=kwargs.get("alpha", 0.7),
        )

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # 軸ラベルの設定
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")

        return fig, metadata

```

### visualization/renderers/__init__.py

```
"""可視化レンダラーパッケージの初期化"""

from .scalar2d import Scalar2DRenderer
from .scalar3d import Scalar3DRenderer
from .vector2d import Vector2DRenderer
from .vector3d import Vector3DRenderer

__all__ = [
    "Scalar2DRenderer",
    "Scalar3DRenderer",
    "Vector2DRenderer",
    "Vector3DRenderer",
]

```

### visualization/renderers/scalar2d.py

```
"""2Dスカラー場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any
from matplotlib.axes import Axes
from matplotlib.figure import Figure


class Scalar2DRenderer:
    """2Dスカラー場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def render(
        self, data: np.ndarray, ax: Optional[Axes] = None, **kwargs
    ) -> Tuple[Figure, Dict[str, Any]]:
        """2Dスカラー場を描画

        Args:
            data: スカラー場データ
            ax: 既存のAxes（Noneの場合は新規作成）
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力バリデーション
        if data.ndim != 2:
            raise ValueError("2次元データが必要です")

        # 図とAxesの準備
        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig = ax.figure

        # デフォルトのパラメータ設定
        cmap = kwargs.get("cmap", "viridis")
        interpolation = kwargs.get("interpolation", "nearest")

        # メタデータの準備
        metadata = {
            "data_range": {
                "min": float(np.nanmin(data)),
                "max": float(np.nanmax(data)),
            },
            "display_type": ["scalar"],
        }

        # スカラー場の描画
        im = ax.imshow(
            data.T,
            origin="lower",
            cmap=cmap,
            interpolation=interpolation,
            alpha=kwargs.get("alpha", 1.0),
        )

        # カラーバーの追加
        if kwargs.get("colorbar", True):
            plt.colorbar(im, ax=ax)

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # 軸ラベルの追加
        ax.set_xlabel(kwargs.get("xlabel", "X"))
        ax.set_ylabel(kwargs.get("ylabel", "Y"))

        return fig, metadata

```

### visualization/renderers/scalar3d.py

```
"""3Dスカラー場の可視化を提供するモジュール"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Optional, Tuple, Dict, Any, Union
from matplotlib.axes import Axes


class Scalar3DRenderer:
    """3Dスカラー場のシンプルなレンダラー"""

    def __init__(self, config: Dict[str, Any] = None):
        """レンダラーを初期化

        Args:
            config: 可視化設定（オプション）
        """
        self.config = config or {}

    def render(
        self,
        data: Union[np.ndarray, int],
        ax: Optional[Axes] = None,
        view: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> Tuple[plt.Figure, Dict[str, Any]]:
        """3Dスカラー場を描画

        Args:
            data: スカラー場データ
            ax: 既存のAxes（Noneの場合は新規作成）
            **kwargs: 追加の描画オプション

        Returns:
            (図, メタデータの辞書)のタプル
        """
        # 入力データのチェック
        if isinstance(data, int):
            raise ValueError("データは数値ではなく、numpy配列である必要があります")

        # 入力バリデーション
        if data.ndim != 3:
            raise ValueError("3次元データが必要です")

        # 図とAxesの準備
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="3d")
        else:
            fig = ax.figure

        # スライス位置の決定
        _ = {"yz": 0, "xz": 1, "xy": 2}
        if view is None:
            slice_axis = 2
            slice_pos = data.shape[0] // 2
        else:
            slice_axis = _[view.slice_axes[0]]
            slice_pos = int(view.slice_positions[0] * data.shape[0])

        # スライスの抽出
        slices = [slice(None)] * 3
        slices[slice_axis] = slice_pos
        slice_data = data[tuple(slices)].T

        # メタデータの準備
        metadata = {
            "data_range": {
                "min": float(np.nanmin(data)),
                "max": float(np.nanmax(data)),
            },
            "display_type": ["scalar", "slice"],
        }

        # グリッドの生成
        nx, ny = slice_data.shape
        x = np.arange(nx)
        y = np.arange(ny)
        X, Y = np.meshgrid(x, y)

        # 座標の調整
        if slice_axis == 0:
            X, Y, Z = slice_pos * np.ones_like(X), X, Y
        elif slice_axis == 1:
            X, Y, Z = X, slice_pos * np.ones_like(X), Y
        else:
            X, Y, Z = X, Y, slice_pos * np.ones_like(X)

        # カラーマップと色の設定
        cmap = kwargs.get("cmap", "viridis")

        # データの正規化
        normalized_data = (slice_data - slice_data.min()) / (
            slice_data.max() - slice_data.min()
        )

        im = ax.plot_surface(
            X,
            Y,
            Z,
            facecolors=plt.cm.get_cmap(cmap)(normalized_data),
            alpha=kwargs.get("alpha", 0.7),
        )

        # タイトルの追加
        if "title" in kwargs:
            ax.set_title(kwargs["title"])

        # 軸ラベルの設定
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")

        return fig, metadata

```

### visualization/visualizer.py

```
"""可視化システムのメインクラスを提供するモジュール

このモジュールは、2次元・3次元の物理場の可視化機能を統合的に提供します。
"""

from typing import Optional, Dict, Any, Union, List

import numpy as np
from matplotlib import pyplot as plt

from .core.base import VisualizationConfig, ViewConfig
from .core.exporter import ImageExporter
from .renderers.scalar2d import Scalar2DRenderer
from .renderers.vector2d import Vector2DRenderer
from .renderers.scalar3d import Scalar3DRenderer
from .renderers.vector3d import Vector3DRenderer


class Visualizer:
    """可視化システムのメインクラス

    2次元・3次元の物理場の可視化を統合的に管理します。
    """

    def __init__(self, config: Union[VisualizationConfig, Dict[str, Any]]):
        """可視化システムを初期化

        Args:
            config: 設定（VisualizationConfigまたは辞書）
        """
        if isinstance(config, dict):
            self.config = VisualizationConfig.from_dict(config)
        else:
            self.config = config

        self.exporter = ImageExporter(self.config)

        # レンダラーの初期化
        self._renderers = {
            "2D": {
                "scalar": Scalar2DRenderer(self.config),
                "vector": Vector2DRenderer(self.config),
            },
            "3D": {
                "scalar": Scalar3DRenderer(self.config),
                "vector": Vector3DRenderer(self.config),
            },
        }

    def visualize_scalar(
        self,
        data: np.ndarray,
        name: str,
        timestamp: Optional[float] = None,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """スカラー場を可視化"""
        # データの次元に応じてレンダラーを選択
        renderer = self._renderers["3D" if data.ndim == 3 else "2D"]["scalar"]

        # 描画を実行
        fig, metadata = renderer.render(data, view=view, **kwargs)

        # 出力パスの生成
        filepath = self.config.get_output_path(name, timestamp)

        # 描画結果の出力
        self.exporter.export(fig, filepath, metadata)

        return str(filepath)

    def visualize_vector(
        self,
        vector_components: List[np.ndarray],
        name: str,
        timestamp: Optional[float] = None,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """ベクトル場を可視化"""
        # データの次元に応じてレンダラーを選択
        ndim = len(vector_components)
        renderer = self._renderers["3D" if ndim == 3 else "2D"]["vector"]

        # 描画を実行
        fig, metadata = renderer.render(vector_components, **kwargs)

        # 出力パスの生成
        filepath = self.config.get_output_path(name, timestamp)

        # 描画結果の出力
        self.exporter.export(fig, filepath, metadata)

        return str(filepath)

    def visualize_combined(
        self,
        scalar_data: Optional[np.ndarray] = None,
        vector_components: Optional[List[np.ndarray]] = None,
        name: str = "combined",
        timestamp: Optional[float] = None,
        view: Optional[ViewConfig] = None,
        **kwargs,
    ) -> str:
        """スカラー場とベクトル場を重ねて可視化"""
        if scalar_data is not None:
            ndim = scalar_data.ndim
        elif vector_components is not None:
            ndim = len(vector_components)
        else:
            raise ValueError("スカラー場またはベクトル場が必要です")

        # 図の作成
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection="3d" if ndim == 3 else None)

        metadata = {}

        # スカラー場の描画
        if scalar_data is not None:
            renderer = self._renderers["3D" if ndim == 3 else "2D"]["scalar"]
            _, scalar_metadata = renderer.render(
                scalar_data, ax=ax, **kwargs.get("scalar_options", {})
            )
            metadata["scalar"] = scalar_metadata

        # ベクトル場の描画
        if vector_components is not None:
            renderer = self._renderers["3D" if ndim == 3 else "2D"]["vector"]
            _, vector_metadata = renderer.render(
                vector_components, ax=ax, **kwargs.get("vector_options", {})
            )
            metadata["vector"] = vector_metadata

        # 出力パスの生成
        filepath = self.config.get_output_path(name, timestamp)

        # 描画結果の出力
        self.exporter.export(fig, filepath, metadata)

        return str(filepath)

```

### visualization/__init__.py

```
"""可視化システムのメインモジュール

このパッケージは、2次元・3次元の物理場の可視化機能を統合的に提供します。
"""

from .core.base import VisualizationConfig, ViewConfig
from .visualizer import Visualizer
from .interfaces import VisualizationFactory, VisualizationContext
from .renderer_strategy import (
    Renderer2DVisualizationStrategy,
    Renderer3DVisualizationStrategy,
)

# レンダラー
from .renderers import (
    Scalar2DRenderer,
    Scalar3DRenderer,
    Vector2DRenderer,
    Vector3DRenderer,
)

# エクスポーター
from .core.exporter import ImageExporter

# 可視化関数
from .multiview import visualize_simulation_state, create_multiview_visualization

__all__ = [
    # 設定関連
    "VisualizationConfig",
    "ViewConfig",
    # メインクラス
    "Visualizer",
    # インターフェースと戦略
    "VisualizationFactory",
    "VisualizationContext",
    "Renderer2DVisualizationStrategy",
    "Renderer3DVisualizationStrategy",
    # レンダラー
    "Scalar2DRenderer",
    "Scalar3DRenderer",
    "Vector2DRenderer",
    "Vector3DRenderer",
    # エクスポーター
    "ImageExporter",
    # 可視化関数
    "visualize_simulation_state",
    "create_multiview_visualization",
]

```

### visualization/multiview.py

```
"""可視化システムの多視点可視化モジュール

このモジュールは、シミュレーション状態の多視点可視化を提供します。
"""

from pathlib import Path
from typing import List

from .core.base import VisualizationConfig, ViewConfig
from .interfaces import VisualizationContext, VisualizationFactory


def create_multiview_visualization(
    state,
    config: VisualizationConfig,
    timestamp: float = 0.0,
    base_name: str = "simulation_state",
) -> List[str]:
    """シミュレーション状態の多視点可視化を生成

    Args:
        state: シミュレーション状態
        config: 可視化設定
        timestamp: 現在の時刻
        base_name: 出力ファイル名のベース

    Returns:
        生成された可視化ファイルのパス一覧
    """
    # 出力ディレクトリの作成
    # configがSimulationConfigの場合
    if hasattr(config, "output_dir"):
        output_dir = Path(config.output_dir)
    # configが辞書の場合
    elif isinstance(config, dict):
        output_dir = Path(config.get("output_dir", "results/visualization"))
    else:
        output_dir = Path("results/visualization")

    output_dir.mkdir(parents=True, exist_ok=True)

    # 出力ファイルのパスを格納するリスト
    output_files = []

    # 可視化戦略の選択（次元数に基づく）
    ndim = len(state.velocity.components[0].data.shape)
    strategy_type = "3d" if ndim == 3 else "2d"
    viz_context = VisualizationContext(
        VisualizationFactory.create_strategy(strategy_type, config)
    )

    # 可視化設定の取得
    if isinstance(config, dict):
        viz_config = config.get("visualization", {})
    elif hasattr(config, "output"):
        viz_config = getattr(config.output, "fields", {})
    else:
        viz_config = {}

    # スライス設定の取得
    slice_axes = viz_config.get("slices", {}).get("axes", ["xy"])
    slice_positions = viz_config.get("slices", {}).get("positions", [0.5])

    # 可視化する物理量の設定
    fields_config = viz_config.get("fields", {})
    physics_fields = []

    # 速度場の設定
    if fields_config.get("velocity", {}).get("enabled", False):
        physics_fields.append(
            {
                "name": "velocity",
                "data": [comp.data for comp in state.velocity.components],
                "plot_type": "vector",
            }
        )

    # 圧力場の設定
    if fields_config.get("pressure", {}).get("enabled", False):
        physics_fields.append(
            {"name": "pressure", "data": state.pressure.data, "plot_type": "scalar"}
        )

    # レベルセット場の設定
    if fields_config.get("levelset", {}).get("enabled", False):
        physics_fields.append(
            {"name": "levelset", "data": state.levelset.data, "plot_type": "scalar"}
        )

    # 可視化の実行
    for field in physics_fields:
        for slice_axis in slice_axes:
            for slice_pos in slice_positions:
                try:
                    # ViewConfigの作成
                    view_config = ViewConfig(
                        slice_axes=[slice_axis], slice_positions=[slice_pos]
                    )

                    # ファイル名の生成
                    filename = (
                        f"{base_name}_{field['name']}"
                        f"_{slice_axis}_slice_{slice_pos:.2f}_{timestamp:.3f}"
                    )

                    # 可視化の実行
                    filepath = viz_context.visualize(
                        field["data"],
                        name=filename,
                        timestamp=timestamp,
                        view=view_config,
                    )

                    output_files.append(filepath)

                except Exception as e:
                    print(f"可視化中にエラー発生: {e}")
                    import traceback

                    traceback.print_exc()

    return output_files


def visualize_simulation_state(state, config, timestamp: float = 0.0) -> List[str]:
    """シミュレーション状態を可視化

    Args:
        state: シミュレーション状態
        config: 可視化設定
        timestamp: 現在の時刻

    Returns:
        生成された可視化ファイルのパス一覧
    """
    # 設定が辞書の場合、VisualizationConfigに変換
    if isinstance(config, dict):
        config = VisualizationConfig.from_dict(config)

    return create_multiview_visualization(state, config, timestamp=timestamp)

```

### core/boundary/dirichlet.py

```
"""ディリクレ境界条件を提供するモジュール

このモジュールは、流体シミュレーションで使用されるディリクレ境界条件を実装します。
ディリクレ境界条件では、境界上で物理量の値を指定します。
"""

import numpy as np
from .base import BoundaryCondition, StencilInfo


class DirichletBoundary(BoundaryCondition):
    """ディリクレ境界条件クラス

    ディリクレ境界条件は、境界上で物理量の値を指定します。
    壁面での速度や温度などを指定する場合に使用されます。
    """

    def __init__(self, value: float = 0.0, order: int = 2):
        """ディリクレ境界条件を初期化

        Args:
            value: 境界での値
            order: 差分近似の次数
        """
        super().__init__(order)
        self.value = value

    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """ディリクレ境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()

        # 境界面のスライスを取得
        boundary_slice = self.get_boundary_slice(field, axis, side, 1)

        # 境界値を設定
        result[boundary_slice] = self.value

        return result

    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        # 2次精度の場合
        if self.order == 2:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1, 2]),
                    coefficients=np.array([-3 / 2, 2, -1 / 2]),
                )
            else:
                return StencilInfo(
                    points=np.array([-2, -1, 0]),
                    coefficients=np.array([1 / 2, -2, 3 / 2]),
                )
        # 4次精度の場合
        elif self.order == 4:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1, 2, 3, 4]),
                    coefficients=np.array([-25 / 12, 4, -3, 4 / 3, -1 / 4]),
                )
            else:
                return StencilInfo(
                    points=np.array([-4, -3, -2, -1, 0]),
                    coefficients=np.array([1 / 4, -4 / 3, 3, -4, 25 / 12]),
                )
        else:
            raise ValueError(f"未対応の次数です: {self.order}")

```

### core/boundary/base.py

```
"""境界条件の基底クラスを提供するモジュール

このモジュールは、流体シミュレーションで使用される境界条件の基底クラスを定義します。
すべての具体的な境界条件（周期境界、ディリクレ境界など）は、この基底クラスを継承します。
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Tuple
import numpy as np


@dataclass
class StencilInfo:
    """差分ステンシルの情報を保持するクラス

    Attributes:
        points: ステンシルの位置（中心からの相対位置）
        coefficients: 各点での係数
    """

    points: np.ndarray  # 形状: (N,)
    coefficients: np.ndarray  # 形状: (N,)


class BoundaryCondition(ABC):
    """境界条件の基底クラス

    この抽象基底クラスは、すべての境界条件に共通のインターフェースを定義します。
    """

    def __init__(self, order: int = 2):
        """境界条件を初期化

        Args:
            order: 差分近似の次数（デフォルトは2次精度）
        """
        self.order = order

    @abstractmethod
    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        pass

    @abstractmethod
    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        pass

    def validate_field(self, field: np.ndarray, axis: int) -> None:
        """場の妥当性をチェック

        Args:
            field: チェックする場
            axis: チェックする軸

        Raises:
            ValueError: 無効な場や軸が指定された場合
        """
        if not isinstance(field, np.ndarray):
            raise ValueError("fieldはnumpy配列である必要があります")
        if not 0 <= axis < field.ndim:
            raise ValueError(f"無効な軸です: {axis}")

    def apply_all(self, field: np.ndarray, axis: int) -> np.ndarray:
        """両側の境界に境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()

        # 負側の境界に適用
        result = self.apply(result, axis, 0)

        # 正側の境界に適用
        result = self.apply(result, axis, 1)

        return result

    def get_boundary_slice(
        self, field: np.ndarray, axis: int, side: int, width: int
    ) -> Tuple[slice, ...]:
        """境界領域のスライスを取得

        Args:
            field: 対象の場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）
            width: 境界領域の幅

        Returns:
            境界領域を選択するスライスのタプル
        """
        slices = [slice(None)] * field.ndim
        if side == 0:
            slices[axis] = slice(0, width)
        else:
            slices[axis] = slice(-width, None)
        return tuple(slices)

    def get_ghost_points(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """ゴースト点の座標を取得

        Args:
            field: 対象の場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ゴースト点の座標配列
        """
        # ステンシル情報から必要なゴースト点の数を決定
        stencil = self.get_stencil(side)
        n_ghost = len(stencil.points)

        # 境界に沿った座標グリッドを生成
        shape = list(field.shape)
        shape[axis] = n_ghost
        coordinates = np.empty(shape + [field.ndim])

        # 各次元の座標を設定
        for dim in range(field.ndim):
            if dim == axis:
                if side == 0:
                    coords = np.arange(-n_ghost, 0)
                else:
                    coords = np.arange(field.shape[axis], field.shape[axis] + n_ghost)
            else:
                coords = np.arange(field.shape[dim])
            coordinates[..., dim] = coords

        return coordinates

```

### core/boundary/periodic.py

```
"""周期境界条件を提供するモジュール

このモジュールは、流体シミュレーションで使用される周期境界条件を実装します。
周期境界条件では、計算領域の両端が接続されているとして扱います。
"""

import numpy as np
from .base import BoundaryCondition, StencilInfo


class PeriodicBoundary(BoundaryCondition):
    """周期境界条件クラス

    周期境界条件は、計算領域の両端が接続されているとして扱います。
    物理量は領域の境界で連続的に繰り返されます。
    """

    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """周期境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()

        # ステンシル情報から必要なゴースト点の数を決定
        stencil = self.get_stencil(side)
        n_ghost = len(stencil.points)

        # 境界領域のスライスを取得
        ghost_slice = self.get_boundary_slice(field, axis, side, n_ghost)

        # 反対側の内部領域から値をコピー
        if side == 0:  # 負側の境界
            source_slice = self.get_boundary_slice(field, axis, 1, n_ghost)
            result[ghost_slice] = field[source_slice]
        else:  # 正側の境界
            source_slice = self.get_boundary_slice(field, axis, 0, n_ghost)
            result[ghost_slice] = field[source_slice]

        return result

    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        # 2次精度中心差分の場合
        if self.order == 2:
            return StencilInfo(
                points=np.array([-1, 0, 1]), coefficients=np.array([-0.5, 0.0, 0.5])
            )
        # 4次精度中心差分の場合
        elif self.order == 4:
            return StencilInfo(
                points=np.array([-2, -1, 0, 1, 2]),
                coefficients=np.array([1 / 12, -2 / 3, 0, 2 / 3, -1 / 12]),
            )
        else:
            raise ValueError(f"未対応の次数です: {self.order}")

```

### core/boundary/neumann.py

```
"""ノイマン境界条件を提供するモジュール

このモジュールは、流体シミュレーションで使用されるノイマン境界条件を実装します。
ノイマン境界条件では、境界上で物理量の勾配を指定します。
"""

import numpy as np
from .base import BoundaryCondition, StencilInfo


class NeumannBoundary(BoundaryCondition):
    """ノイマン境界条件クラス

    ノイマン境界条件は、境界上で物理量の勾配を指定します。
    断熱壁や流出境界などで使用されます。
    """

    def __init__(self, gradient: float = 0.0, order: int = 2):
        """ノイマン境界条件を初期化

        Args:
            gradient: 境界での勾配
            order: 差分近似の次数
        """
        super().__init__(order)
        self.gradient = gradient

    def apply(self, field: np.ndarray, axis: int, side: int) -> np.ndarray:
        """ノイマン境界条件を適用

        Args:
            field: 境界条件を適用する場
            axis: 境界条件を適用する軸
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            境界条件が適用された場
        """
        self.validate_field(field, axis)
        result = field.copy()
        dx = 1.0  # 正規化された格子間隔

        # 境界近傍の値を取得
        if side == 0:  # 負側の境界
            interior_slice = self.get_boundary_slice(field, axis, 1, 1)
            interior_value = field[interior_slice]
            # 勾配条件に基づいて境界値を設定
            boundary_slice = self.get_boundary_slice(field, axis, 0, 1)
            result[boundary_slice] = interior_value - self.gradient * dx
        else:  # 正側の境界
            interior_slice = self.get_boundary_slice(field, axis, 0, 1)
            interior_value = field[interior_slice]
            # 勾配条件に基づいて境界値を設定
            boundary_slice = self.get_boundary_slice(field, axis, 1, 1)
            result[boundary_slice] = interior_value + self.gradient * dx

        return result

    def get_stencil(self, side: int) -> StencilInfo:
        """差分ステンシルの情報を取得

        Args:
            side: 境界の側（0: 負側、1: 正側）

        Returns:
            ステンシルの情報
        """
        # 2次精度の場合
        if self.order == 2:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1]), coefficients=np.array([-1.0, 1.0])
                )
            else:
                return StencilInfo(
                    points=np.array([-1, 0]), coefficients=np.array([-1.0, 1.0])
                )
        # 4次精度の場合
        elif self.order == 4:
            if side == 0:
                return StencilInfo(
                    points=np.array([0, 1, 2, 3]),
                    coefficients=np.array([-11 / 6, 3, -3 / 2, 1 / 3]),
                )
            else:
                return StencilInfo(
                    points=np.array([-3, -2, -1, 0]),
                    coefficients=np.array([-1 / 3, 3 / 2, -3, 11 / 6]),
                )
        else:
            raise ValueError(f"未対応の次数です: {self.order}")

```

### core/boundary/__init__.py

```
"""境界条件パッケージ

このパッケージは、流体シミュレーションで使用される各種境界条件を提供します。
"""

from .base import BoundaryCondition, StencilInfo
from .periodic import PeriodicBoundary
from .dirichlet import DirichletBoundary
from .neumann import NeumannBoundary

__all__ = [
    "BoundaryCondition",
    "StencilInfo",
    "PeriodicBoundary",
    "DirichletBoundary",
    "NeumannBoundary",
]

```

### core/solver/base.py

```
"""ソルバーの基底クラスを提供するモジュール

このモジュールは、数値解法の基底となる抽象クラスを定義します。
全ての具体的なソルバーはこの基底クラスを継承します。
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from datetime import datetime


class Solver(ABC):
    """ソルバーの基底クラス

    この抽象基底クラスは、全てのソルバーに共通のインターフェースと
    基本機能を提供します。
    """

    def __init__(
        self,
        name: str,
        tolerance: float = 1e-6,
        max_iterations: int = 1000,
        logger=None,
        **extra_kwargs,  # 追加のキーワード引数を許可
    ):
        """ソルバーを初期化

        Args:
            name: ソルバーの名前
            tolerance: 収束判定の許容誤差
            max_iterations: 最大反復回数
            logger: ロガー（オプション）
            **extra_kwargs: 追加のキーワード引数（柔軟性のため）
        """
        self.name = name
        self._tolerance = tolerance
        self._max_iterations = max_iterations
        self._iteration_count = 0
        self._residual_history = []
        self._start_time = None
        self._end_time = None
        self._logger = logger

        # 追加のキーワード引数を属性として保存（必要に応じて）
        for key, value in extra_kwargs.items():
            setattr(self, f"_{key}", value)

    @property
    def tolerance(self) -> float:
        """収束判定の許容誤差を取得"""
        return self._tolerance

    @tolerance.setter
    def tolerance(self, value: float):
        """収束判定の許容誤差を設定"""
        if value <= 0:
            raise ValueError("許容誤差は正の値である必要があります")
        self._tolerance = value

    @property
    def max_iterations(self) -> int:
        """最大反復回数を取得"""
        return self._max_iterations

    @max_iterations.setter
    def max_iterations(self, value: int):
        """最大反復回数を設定"""
        if value <= 0:
            raise ValueError("最大反復回数は正の整数である必要があります")
        self._max_iterations = value

    @property
    def iteration_count(self) -> int:
        """現在の反復回数を取得"""
        return self._iteration_count

    @property
    def residual_history(self) -> list:
        """残差の履歴を取得"""
        return self._residual_history.copy()

    @property
    def elapsed_time(self) -> Optional[float]:
        """計算経過時間を取得（秒）"""
        if self._start_time is None:
            return None
        end_time = self._end_time or datetime.now()
        return (end_time - self._start_time).total_seconds()

    @abstractmethod
    def initialize(self, **kwargs) -> None:
        """ソルバーの初期化"""
        pass

    @abstractmethod
    def solve(self, **kwargs) -> Dict[str, Any]:
        """ソルバーを実行"""
        pass

    def reset(self):
        """ソルバーの状態をリセット"""
        self._iteration_count = 0
        self._residual_history = []
        self._start_time = None
        self._end_time = None

    def _start_solving(self):
        """計算開始時の処理"""
        self.reset()
        self._start_time = datetime.now()
        if self._logger:
            self._logger.info(f"{self.name}ソルバーの計算を開始")

    def _end_solving(self):
        """計算終了時の処理"""
        self._end_time = datetime.now()
        if self._logger:
            self._logger.info(
                f"{self.name}ソルバーの計算を終了 (経過時間: {self.elapsed_time:.2f}秒)"
            )

    def get_status(self) -> Dict[str, Any]:
        """ソルバーの現在の状態を取得"""
        return {
            "name": self.name,
            "iteration_count": self.iteration_count,
            "residual": self._residual_history[-1] if self._residual_history else None,
            "elapsed_time": self.elapsed_time,
        }

    def __str__(self) -> str:
        """ソルバーの文字列表現を取得"""
        status = self.get_status()
        return (
            f"Solver: {status['name']}\n"
            f"Iterations: {status['iteration_count']}\n"
            f"Current Residual: {status['residual']}\n"
            f"Elapsed Time: {status['elapsed_time']:.2f}s"
        )

```

### core/solver/temporal.py

```
"""時間発展ソルバーの基底クラスを提供するモジュール

このモジュールは、時間発展問題を解くためのソルバーの基底クラスを定義します。
"""

from abc import abstractmethod
from typing import Dict, Any, Optional
from .base import Solver


class TemporalSolver(Solver):
    """時間発展ソルバーの基底クラス"""

    def __init__(
        self,
        name: str,
        cfl: float = 0.5,
        min_dt: float = 1e-6,
        max_dt: float = 1.0,
        tolerance: float = 1e-6,
        max_iterations: int = 1000,
        logger=None,
    ):
        """時間発展ソルバーを初期化"""
        super().__init__(
            name=name, tolerance=tolerance, max_iterations=max_iterations, logger=logger
        )
        self._time = 0.0
        self._dt = None
        self._cfl = cfl
        self._min_dt = min_dt
        self._max_dt = max_dt
        self._time_history = []

    @property
    def time(self) -> float:
        """現在の時刻を取得"""
        return self._time

    @property
    def dt(self) -> Optional[float]:
        """時間刻み幅を取得"""
        return self._dt

    @property
    def cfl(self) -> float:
        """CFL数を取得"""
        return self._cfl

    @cfl.setter
    def cfl(self, value: float):
        """CFL数を設定"""
        if value <= 0:
            raise ValueError("CFL数は正の値である必要があります")
        self._cfl = value

    @abstractmethod
    def compute_timestep(self, **kwargs) -> float:
        """時間刻み幅を計算"""
        pass

    @abstractmethod
    def advance(self, dt: float, **kwargs) -> Dict[str, Any]:
        """1時間ステップ進める"""
        pass

```

### core/solver/iterative.py

```
"""反復法ソルバーの基底クラスを提供するモジュール

このモジュールは、反復法による方程式求解のための基底クラスを定義します。
"""

from abc import abstractmethod
from typing import Dict, Any
import numpy as np
from .base import Solver


class IterativeSolver(Solver):
    """反復法ソルバーの基底クラス

    この抽象基底クラスは、反復法による求解を行うソルバーに共通の
    機能を提供します。
    """

    def __init__(self, name: str, omega: float = 1.0, **kwargs):
        """反復法ソルバーを初期化

        Args:
            name: ソルバーの名前
            omega: 緩和係数
            **kwargs: 基底クラスに渡すパラメータ
        """
        super().__init__(name, **kwargs)
        self._omega = omega
        self._initial_residual = None
        self._convergence_history = []

    @property
    def omega(self) -> float:
        """緩和係数を取得"""
        return self._omega

    @omega.setter
    def omega(self, value: float):
        """緩和係数を設定

        Args:
            value: 設定する緩和係数

        Raises:
            ValueError: 不適切な値が指定された場合
        """
        if value <= 0 or value > 2:
            raise ValueError("緩和係数は0から2の間である必要があります")
        self._omega = value

    @abstractmethod
    def compute_residual(self, solution: np.ndarray, **kwargs) -> float:
        """残差を計算

        Args:
            solution: 現在の解
            **kwargs: 計算に必要なパラメータ

        Returns:
            計算された残差
        """
        pass

    @abstractmethod
    def iterate(self, solution: np.ndarray, **kwargs) -> np.ndarray:
        """1回の反復を実行

        Args:
            solution: 現在の解
            **kwargs: 計算に必要なパラメータ

        Returns:
            更新された解
        """
        pass

    def check_convergence(self, residual: float) -> bool:
        """収束判定

        Args:
            residual: 現在の残差

        Returns:
            収束したかどうか
        """
        # 初回の残差を記録
        if self._initial_residual is None:
            self._initial_residual = residual
            return False

        # 初期残差が非常に小さい場合の特別な処理
        if self._initial_residual < 1e-15:
            return residual < 1e-10

        # 相対残差による収束判定
        relative_residual = residual / self._initial_residual
        self._convergence_history.append(relative_residual)

        # 相対残差と絶対残差の両方でチェック
        return (relative_residual < self.tolerance) and (residual < 1e-10)

    def solve(self, initial_solution: np.ndarray, **kwargs) -> Dict[str, Any]:
        """反復法で方程式を解く

        Args:
            initial_solution: 初期推定解
            **kwargs: 計算に必要なパラメータ

        Returns:
            計算結果と統計情報を含む辞書

        Raises:
            RuntimeError: 最大反復回数に達しても収束しない場合
        """
        self._start_solving()

        # 初期解のコピー
        solution = initial_solution.copy()

        # 初期残差の計算
        self._initial_residual = self.compute_residual(solution, **kwargs)
        self._residual_history.append(self._initial_residual)

        while self._iteration_count < self.max_iterations:
            # 1回の反復
            solution = self.iterate(solution, **kwargs)

            # 残差の計算
            residual = self.compute_residual(solution, **kwargs)
            self._residual_history.append(residual)

            # 反復回数の更新
            self._iteration_count += 1

            # 収束判定
            if self.check_convergence(residual):
                self._end_solving()
                return {
                    "solution": solution,
                    "converged": True,
                    "iterations": self._iteration_count,
                    "residual": residual,
                    "convergence_history": self._convergence_history,
                    "elapsed_time": self.elapsed_time,
                }

        self._end_solving()
        raise RuntimeError(
            f"ソルバーが収束しませんでした: 残差 = {residual}, "
            f"相対残差 = {residual / self._initial_residual}"
        )

    def get_status(self) -> Dict[str, Any]:
        """ソルバーの現在の状態を取得"""
        status = super().get_status()
        status.update(
            {
                "omega": self._omega,
                "initial_residual": self._initial_residual,
                "current_convergence": self._convergence_history[-1]
                if self._convergence_history
                else None,
            }
        )
        return status

```

### core/solver/__init__.py

```
"""ソルバーパッケージ

このパッケージは、数値計算のための様々なソルバーの基底クラスを提供します。
"""

from .base import Solver
from .temporal import TemporalSolver
from .iterative import IterativeSolver

__all__ = ["Solver", "TemporalSolver", "IterativeSolver"]

```

### core/field/scalar.py

```
"""スカラー場クラスを提供するモジュール

このモジュールは、スカラー量（圧力、温度など）を表現するための場のクラスを定義します。
"""

from typing import Tuple, Optional
import numpy as np
from .field import Field
from typing import Dict, Any


class ScalarField(Field):
    """スカラー場クラス

    温度、圧力などのスカラー量を表現するためのクラスです。
    基本的な微分演算や補間機能を提供します。
    """

    def __init__(
        self, shape: Tuple[int, ...], dx: float = 1.0, initial_value: float = 0.0
    ):
        """スカラー場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔
            initial_value: 初期値
        """
        super().__init__(shape, dx)
        if initial_value != 0.0:
            self._data.fill(initial_value)

    def interpolate(self, points: np.ndarray) -> np.ndarray:
        """任意の点での値を線形補間

        Args:
            points: 補間点の座標 (N, ndim)

        Returns:
            補間された値 (N,)
        """
        # 各次元のインデックスと重みを計算
        indices = []
        weights = []

        for dim in range(self.ndim):
            # 座標をインデックスに変換
            idx = points[:, dim] / self._dx
            idx0 = np.floor(idx).astype(int)
            idx1 = idx0 + 1
            w1 = idx - idx0
            w0 = 1.0 - w1

            # 境界条件の適用
            idx0 = np.clip(idx0, 0, self.shape[dim] - 1)
            idx1 = np.clip(idx1, 0, self.shape[dim] - 1)

            indices.append((idx0, idx1))
            weights.append((w0, w1))

        # 全ての隣接点での重み付き和を計算
        result = np.zeros(len(points))
        for i in range(2**self.ndim):
            # i のビット表現から各次元でのインデックスを決定
            idx = []
            w = 1.0
            for d in range(self.ndim):
                bit = (i >> d) & 1
                idx.append(indices[d][bit])
                w *= weights[d][bit]

            # インデックスでの値を重み付きで加算
            result += w * self._data[tuple(idx)]

        return result

    def integrate(self) -> float:
        """場の積分値を計算"""
        return np.sum(self._data) * self._dx**self.ndim

    def mean(self) -> float:
        """場の平均値を計算"""
        return np.mean(self._data)

    def min(self) -> float:
        """場の最小値を取得"""
        return np.min(self._data)

    def max(self) -> float:
        """場の最大値を取得"""
        return np.max(self._data)

    def normalize(self):
        """場を正規化

        場の値を[0, 1]の範囲に正規化します。
        """
        min_val = self.min()
        max_val = self.max()
        if max_val > min_val:
            self._data = (self._data - min_val) / (max_val - min_val)

    def clip(self, min_val: Optional[float] = None, max_val: Optional[float] = None):
        """場の値を指定範囲に制限

        Args:
            min_val: 最小値（Noneの場合は制限なし）
            max_val: 最大値（Noneの場合は制限なし）
        """
        self._data = np.clip(self._data, min_val, max_val)

    def smooth(self, sigma: float = 1.0):
        """場をガウシアンフィルタで平滑化

        Args:
            sigma: ガウシアンフィルタの標準偏差
        """
        from scipy.ndimage import gaussian_filter

        self._data = gaussian_filter(self._data, sigma)

    def __add__(self, other):
        """加算演算子の実装"""
        result = self.__class__(self.shape, self.dx)
        if isinstance(other, (int, float)):
            result.data = self.data + other
        elif isinstance(other, ScalarField):
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result.data = self.data + other.data
        else:
            raise TypeError("無効な型との演算です")
        return result

    def __mul__(self, other):
        """乗算演算子の実装"""
        result = self.__class__(self.shape, self.dx)
        if isinstance(other, (int, float)):
            result.data = self.data * other
        elif isinstance(other, ScalarField):
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result.data = self.data * other.data
        else:
            raise TypeError("無効な型との演算です")
        return result

    def __rmul__(self, other):
        """右乗算演算子の実装"""
        return self.__mul__(other)

    def __truediv__(self, other):
        """除算演算子の実装"""
        result = self.__class__(self.shape, self.dx)
        if isinstance(other, (int, float)):
            result.data = self.data / other
        elif isinstance(other, ScalarField):
            if self.shape != other.shape:
                raise ValueError("場の形状が一致しません")
            result.data = self.data / other.data
        else:
            raise TypeError("無効な型との演算です")
        return result

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        return {
            "data": self.data.copy(),
            "shape": self.shape,
            "dx": self.dx,
            "time": self.time,
        }

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        # データの復元
        if tuple(state["shape"]) != self.shape:
            raise ValueError("形状が一致しません")

        self.data = state["data"].copy()

        # 時刻の復元
        self.time = state.get("time", 0.0)

        # グリッド間隔の確認（必要に応じて）
        if abs(state["dx"] - self.dx) > 1e-10:
            raise ValueError("グリッド間隔が一致しません")

```

### core/field/vector.py

```
"""ベクトル場クラスを提供するモジュール

このモジュールは、ベクトル量（速度、運動量など）を表現するためのベクトル場クラスを定義します。
"""

from typing import List, Tuple, Optional
import numpy as np
from .scalar import ScalarField
from typing import Dict, Any


class VectorField:
    """ベクトル場クラス

    速度、運動量などのベクトル量を表現するためのクラスです。
    各成分をスカラー場として保持し、ベクトル演算のメソッドを提供します。
    """

    def __init__(self, shape: Tuple[int, ...], dx: float = 1.0):
        """ベクトル場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔
        """
        self._components = [ScalarField(shape, dx) for _ in range(len(shape))]
        self._shape = shape
        self._dx = dx

    @property
    def components(self) -> List[ScalarField]:
        """ベクトル場の各成分を取得"""
        return self._components

    @property
    def shape(self) -> Tuple[int, ...]:
        """場の形状を取得"""
        return self._shape

    @property
    def dx(self) -> float:
        """グリッド間隔を取得"""
        return self._dx

    @property
    def ndim(self) -> int:
        """次元数を取得"""
        return len(self._shape)

    def magnitude(self) -> ScalarField:
        """ベクトル場の大きさを計算

        Returns:
            計算されたベクトルの大きさを表すスカラー場
        """
        result = ScalarField(self.shape, self.dx)
        result.data = np.sqrt(sum(c.data**2 for c in self._components))
        return result

    def divergence(self) -> ScalarField:
        """発散を計算

        Returns:
            計算された発散を表すスカラー場
        """
        result = ScalarField(self.shape, self.dx)
        result.data = sum(c.gradient(i) for i, c in enumerate(self._components))
        return result

    def curl(self) -> Optional["VectorField"]:
        """回転を計算

        Returns:
            3次元の場合は計算された回転を表すベクトル場
            2次元の場合はNone
        """
        if self.ndim != 3:
            return None

        result = VectorField(self.shape, self.dx)
        u, v, w = [c.data for c in self._components]

        # ∂w/∂y - ∂v/∂z
        result.components[0].data = np.gradient(w, self.dx, axis=1) - np.gradient(
            v, self.dx, axis=2
        )
        # ∂u/∂z - ∂w/∂x
        result.components[1].data = np.gradient(u, self.dx, axis=2) - np.gradient(
            w, self.dx, axis=0
        )
        # ∂v/∂x - ∂u/∂y
        result.components[2].data = np.gradient(v, self.dx, axis=0) - np.gradient(
            u, self.dx, axis=1
        )

        return result

    def integrate(self) -> float:
        """場の積分値を計算

        Returns:
            各成分の積分値の二乗和の平方根
        """
        return np.sqrt(sum(c.integrate() ** 2 for c in self._components))

    def copy(self) -> "VectorField":
        """場の深いコピーを作成

        Returns:
            コピーされた場
        """
        result = VectorField(self.shape, self.dx)
        for i, component in enumerate(self._components):
            result.components[i] = component.copy()
        return result

    def __add__(self, other: "VectorField") -> "VectorField":
        """加算演算子の実装"""
        if not isinstance(other, VectorField):
            raise TypeError("ベクトル場同士の演算のみ可能です")
        if self.shape != other.shape:
            raise ValueError("場の形状が一致しません")

        result = VectorField(self.shape, self.dx)
        for i, (c1, c2) in enumerate(zip(self.components, other.components)):
            result.components[i] = c1 + c2
        return result

    def __mul__(self, other) -> "VectorField":
        """スカラー倍の実装"""
        if not isinstance(other, (int, float)):
            raise TypeError("スカラー倍のみ可能です")

        result = VectorField(self.shape, self.dx)
        for i, component in enumerate(self.components):
            result.components[i] = component * other
        return result

    def __rmul__(self, other) -> "VectorField":
        """右スカラー倍の実装"""
        return self.__mul__(other)

    def dot(self, other: "VectorField") -> ScalarField:
        """内積を計算

        Args:
            other: 内積を取るベクトル場

        Returns:
            計算された内積を表すスカラー場
        """
        if not isinstance(other, VectorField):
            raise TypeError("ベクトル場同士の演算のみ可能です")
        if self.shape != other.shape:
            raise ValueError("場の形状が一致しません")

        result = ScalarField(self.shape, self.dx)
        result.data = sum(
            c1.data * c2.data for c1, c2 in zip(self.components, other.components)
        )
        return result

    def cross(self, other: "VectorField") -> Optional["VectorField"]:
        """外積を計算（3次元のみ）

        Args:
            other: 外積を取るベクトル場

        Returns:
            3次元の場合は計算された外積を表すベクトル場
            2次元の場合はNone
        """
        if self.ndim != 3:
            return None
        if not isinstance(other, VectorField):
            raise TypeError("ベクトル場同士の演算のみ可能です")
        if self.shape != other.shape:
            raise ValueError("場の形状が一致しません")

        result = VectorField(self.shape, self.dx)
        u1, v1, w1 = [c.data for c in self.components]
        u2, v2, w2 = [c.data for c in other.components]

        result.components[0].data = v1 * w2 - w1 * v2
        result.components[1].data = w1 * u2 - u1 * w2
        result.components[2].data = u1 * v2 - v1 * u2

        return result

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        return {
            "components": [comp.save_state() for comp in self.components],
            "shape": self.shape,
            "dx": self.dx,
        }

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        # コンポーネントの復元
        if len(state["components"]) != len(self.components):
            raise ValueError("コンポーネントの数が一致しません")

        for i, comp_state in enumerate(state["components"]):
            self.components[i].load_state(comp_state)

        # その他の属性の確認（必要に応じて）
        if tuple(state["shape"]) != self.shape:
            raise ValueError("形状が一致しません")

        # dx値の確認は省略可（必要に応じて追加）

```

### core/field/conserved.py

```
"""保存則を持つ場のクラスを提供するモジュール

このモジュールは、保存則を持つ場（質量、運動量など）の基底クラスを定義します。
"""

from typing import Dict, Any
import numpy as np
from .field import Field


class ConservedField(Field):
    """保存則を持つ場の基底クラス

    この基底クラスは、保存則を持つ物理量（質量、運動量など）の場に共通の
    機能を提供します。初期状態の積分値を保持し、保存則の検証を可能にします。

    Attributes:
        initial_integral (float): 初期状態での積分値
    """

    def __init__(self, *args, **kwargs):
        """保存則を持つ場を初期化

        Args:
            *args: Field.__init__に渡される位置引数
            **kwargs: Field.__init__に渡されるキーワード引数
        """
        super().__init__(*args, **kwargs)
        self._initial_integral = self.integrate()

    def integrate(self) -> float:
        """場の積分値を計算

        空間全体にわたる場の積分値を計算します。

        Returns:
            計算された積分値
        """
        return np.sum(self._data) * self._dx**self.ndim

    def check_conservation(self) -> float:
        """保存則の確認

        現在の積分値と初期積分値を比較し、相対誤差を計算します。

        Returns:
            保存則の相対誤差
        """
        current_integral = self.integrate()
        if abs(self._initial_integral) < 1e-10:  # ゼロ除算を防ぐ
            return 0.0 if abs(current_integral) < 1e-10 else float("inf")
        return abs(current_integral - self._initial_integral) / abs(
            self._initial_integral
        )

    def reset_reference(self):
        """参照積分値をリセット

        現在の状態を新しい参照状態として設定します。
        """
        self._initial_integral = self.integrate()

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        state = super().save_state()
        state["initial_integral"] = self._initial_integral
        return state

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        super().load_state(state)
        self._initial_integral = state["initial_integral"]

    @property
    def conservation_error(self) -> float:
        """保存則の誤差を取得"""
        return self.check_conservation()

    @property
    def initial_integral(self) -> float:
        """初期積分値を取得"""
        return self._initial_integral

```

### core/field/field.py

```
"""場の基底クラスを提供するモジュール

このモジュールは流体シミュレーションで使用される場の基底クラスを定義します。
すべての具体的な場の実装（スカラー場、ベクトル場など）は、この基底クラスを継承します。
"""

from abc import ABC, abstractmethod
from typing import Tuple, Dict, Any
import numpy as np


class Field(ABC):
    """場の基底クラス

    この抽象基底クラスは、流体シミュレーションで使用される全ての場に共通の
    インターフェースと基本機能を提供します。

    Attributes:
        shape (Tuple[int, ...]): グリッドの形状
        dx (float): グリッド間隔
        time (float): 現在の時刻
    """

    def __init__(self, shape: Tuple[int, ...], dx: float = 1.0):
        """場を初期化

        Args:
            shape: グリッドの形状
            dx: グリッド間隔
        """
        self._data = np.zeros(shape)
        self._dx = dx
        self._time = 0.0

    @property
    def data(self) -> np.ndarray:
        """場のデータを取得"""
        return self._data

    @data.setter
    def data(self, value: np.ndarray):
        """場のデータを設定

        Args:
            value: 設定するデータ配列

        Raises:
            ValueError: データの形状が不一致の場合
        """
        if value.shape != self._data.shape:
            raise ValueError(f"形状が一致しません: {value.shape} != {self._data.shape}")
        self._data = value.copy()  # 防御的コピー

    @property
    def shape(self) -> Tuple[int, ...]:
        """場の形状を取得"""
        return self._data.shape

    @property
    def ndim(self) -> int:
        """次元数を取得"""
        return self._data.ndim

    @property
    def dx(self) -> float:
        """グリッド間隔を取得"""
        return self._dx

    @property
    def time(self) -> float:
        """現在の時刻を取得"""
        return self._time

    @time.setter
    def time(self, value: float):
        """時刻を設定

        Args:
            value: 設定する時刻

        Raises:
            ValueError: 負の時刻が指定された場合
        """
        if value < 0:
            raise ValueError("時刻は非負である必要があります")
        self._time = value

    def gradient(self, axis: int) -> np.ndarray:
        """指定軸方向の勾配を計算

        中心差分による2次精度の勾配計算を行います。

        Args:
            axis: 勾配を計算する軸のインデックス

        Returns:
            計算された勾配
        """
        return np.gradient(self._data, self._dx, axis=axis)

    def laplacian(self) -> np.ndarray:
        """ラプラシアンを計算

        中心差分による2次精度のラプラシアン計算を行います。

        Returns:
            計算されたラプラシアン
        """
        return sum(
            np.gradient(np.gradient(self._data, self._dx, axis=i), self._dx, axis=i)
            for i in range(self.ndim)
        )

    def copy(self) -> "Field":
        """場の深いコピーを作成

        Returns:
            コピーされた場
        """
        new_field = self.__class__(self.shape, self.dx)
        new_field.data = self.data.copy()
        new_field.time = self.time
        return new_field

    def save_state(self) -> Dict[str, Any]:
        """現在の状態を保存

        Returns:
            現在の状態を表す辞書
        """
        return {"data": self._data.copy(), "time": self._time, "dx": self._dx}

    def load_state(self, state: Dict[str, Any]):
        """状態を読み込み

        Args:
            state: 読み込む状態の辞書
        """
        self._data = state["data"].copy()
        self._time = state["time"]
        self._dx = state["dx"]

    @abstractmethod
    def integrate(self) -> float:
        """場の積分値を計算

        Returns:
            計算された積分値
        """
        pass

```

### core/field/__init__.py

```
# core/__init__.py
from .field import Field
from .scalar import ScalarField
from .vector import VectorField
from .conserved import ConservedField

__all__ = ["Field", "ScalarField", "VectorField", "ConservedField"]

# プロジェクトのディレクトリ構造:
"""
project_root/
├── core/
│   ├── __init__.py
│   ├── field.py      # 基底Field クラス
│   ├── scalar.py     # ScalarField クラス
│   ├── vector.py     # VectorField クラス
│   └── conserved.py  # ConservedField クラス
├── simulations/
│   ├── __init__.py
│   ├── state.py
│   └── ...
└── main.py
"""

```

### up.py

```
import os
import fnmatch
import chardet

def is_binary(file_path):
    with open(file_path, 'rb') as file:
        return b'\0' in file.read(1024)

def read_file_contents(file_path):
    encodings = ['utf-8', 'shift_jis']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as file:
                print(f'Reading file: {file_path}')
                return file.read()
        except UnicodeDecodeError:
            pass
    return ''

def is_ignored(path, project_dir, gitignore_patterns, summaryignore_patterns, additional_ignore_patterns):
    relative_path = os.path.relpath(path, project_dir)
    for pattern in gitignore_patterns + summaryignore_patterns + additional_ignore_patterns:
        pattern = f"*{pattern}*"
        if fnmatch.fnmatch(relative_path, pattern) or fnmatch.fnmatch(f'{os.sep}{relative_path}', pattern):
            return True
    return False

def generate_project_summary(project_dir):
    project_name = os.path.basename(project_dir)
    summary = f'# {project_name}\n\n## Directory Structure\n\n'

    gitignore_patterns = read_gitignore(project_dir)
    print(f"gitignore_patterns: {gitignore_patterns}")
    summaryignore_patterns = read_summaryignore(project_dir)
    print(f"summaryignore_patterns: {summaryignore_patterns}")
    additional_ignore_patterns = ['generate_project_summary.py','.summaryignore', f'{project_name}_project_summary.txt', '.git']

    file_contents_section = "\n## File Contents\n\n"

    def traverse_directory(root, level):
        nonlocal summary, file_contents_section
        indent = '  ' * level
        relative_path = os.path.relpath(root, project_dir)
        if not is_ignored(relative_path, project_dir, gitignore_patterns, summaryignore_patterns, additional_ignore_patterns):
            summary += f'{indent}- {os.path.basename(root)}/\n'

            subindent = '  ' * (level + 1)
            for item in os.listdir(root):
                item_path = os.path.join(root, item)
                if os.path.isdir(item_path):
                    if not is_ignored(item_path, project_dir, gitignore_patterns, summaryignore_patterns, additional_ignore_patterns):
                        traverse_directory(item_path, level + 1)
                else:
                    if not is_ignored(item_path, project_dir, gitignore_patterns, summaryignore_patterns, additional_ignore_patterns):
                        if not is_binary(item_path):
                            summary += f'{subindent}- {item}\n'
                            content = read_file_contents(item_path)
                            if content.strip():
                                # ファイル名をプロジェクト名からの相対パスで表示
                                relative_file_path = os.path.relpath(item_path, project_dir)
                                file_contents_section += f'### {relative_file_path}\n\n```\n{content}\n```\n\n'
                        else:
                            summary += f'{subindent}- {item} (binary file)\n'

    traverse_directory(project_dir, 0)

    with open(f'{project_name}_project_summary.txt', 'w', encoding='utf-8') as file:
        file.write(summary + file_contents_section)

def read_gitignore(project_dir):
    gitignore_path = os.path.join(project_dir, '.gitignore')
    if os.path.exists(gitignore_path):
        with open(gitignore_path, 'r') as file:
            patterns = [line.strip() for line in file if line.strip() and not line.startswith('#')]
            expanded_patterns = []
            for pattern in patterns:
                expanded_patterns.append(pattern)
                if '/' in pattern:
                    expanded_patterns.append(pattern.replace('/', '\\'))
                if '\\' in pattern:
                    expanded_patterns.append(pattern.replace('\\', '/'))
            return expanded_patterns
    return []

def read_summaryignore(project_dir):
    summaryignore_path = os.path.join(project_dir, '.summaryignore')
    if os.path.exists(summaryignore_path):
        with open(summaryignore_path, 'r') as file:
            patterns = [line.strip() for line in file if line.strip() and not line.startswith('#')]
            expanded_patterns = []
            for pattern in patterns:
                expanded_patterns.append(pattern)
                if '/' in pattern:
                    expanded_patterns.append(pattern.replace('/', '\\'))
                if '\\' in pattern:
                    expanded_patterns.append(pattern.replace('\\', '/'))
            return expanded_patterns
    return []

if __name__ == '__main__':
    project_directory = input('Enter the project directory path (leave blank for current directory): ')
    if not project_directory:
        project_directory = os.getcwd()
    generate_project_summary(project_directory)
```

### main.py

```
import sys
import argparse
import yaml
from pathlib import Path
from logger import SimulationLogger, LogConfig
from simulations import SimulationManager, SimulationInitializer
from visualization import visualize_simulation_state


def parse_args():
    """コマンドライン引数をパース"""
    parser = argparse.ArgumentParser(description="二相流シミュレーション")
    parser.add_argument("--config", type=str, required=True, help="設定ファイルのパス")
    parser.add_argument("--checkpoint", type=str, help="チェックポイントファイルのパス")
    parser.add_argument("--debug", action="store_true", help="デバッグモードを有効化")
    return parser.parse_args()


def load_config(config_path: str) -> dict:
    """設定ファイルを読み込み"""
    with open(config_path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def setup_logging(config: dict, debug: bool) -> SimulationLogger:
    """ロギングを設定"""
    # デバッグモードでない場合は、情報レベルのログを抑制
    log_level = "debug" if debug else "warning"
    log_dir = Path(config.get("visualization", {}).get("output_dir", "results"))
    log_dir.mkdir(parents=True, exist_ok=True)
    return SimulationLogger("TwoPhaseFlow", LogConfig(level=log_level, log_dir=log_dir))


def initialize_simulation(
    config: dict, logger: SimulationLogger, checkpoint: Path = None
):
    """シミュレーションを初期化"""
    output_dir = Path(config["visualization"]["output_dir"])
    output_dir.mkdir(parents=True, exist_ok=True)

    if checkpoint:
        logger.info(f"チェックポイントから再開: {checkpoint}")
        initializer = SimulationInitializer(config, logger)
        runner, state = initializer.load_checkpoint(checkpoint)
    else:
        logger.info("新規シミュレーションを開始")
        initializer = SimulationInitializer(config, logger)
        state = initializer.create_initial_state()
        manager = SimulationManager(config, logger)
        runner = manager.runner
        runner.initialize(state)

    # 初期状態の可視化
    visualize_simulation_state(state, config, timestamp=0.0)

    return runner, state


def run_simulation(runner, initial_state, config, logger):
    """シミュレーションを実行"""
    # シミュレーションパラメータの取得
    save_interval = config["numerical"].get("save_interval", 0.1)
    max_time = config["numerical"].get("max_time", 1.0)
    output_dir = Path(config["visualization"]["output_dir"])

    current_time = 0.0
    next_save_time = save_interval

    logger.info(
        f"シミュレーションを開始: max_time = {max_time}, save_interval = {save_interval}"
    )

    while current_time < max_time:
        try:
            # 時間発展の実行
            state, step_info = runner.step_forward()
            current_time = step_info["time"]

            # 結果の可視化と保存
            if current_time >= next_save_time:
                visualize_simulation_state(state, config, timestamp=current_time)
                checkpoint_path = output_dir / f"checkpoint_{current_time:.3f}.npz"
                runner.save_checkpoint(checkpoint_path)
                next_save_time += save_interval

            # ログに進捗を出力
            logger.info(
                f"Time: {current_time:.3f}/{max_time:.1f} "
                f"(dt={step_info['dt']:.3e}), "
                f"Diagnostics: {step_info['diagnostics']}"
            )

        except Exception as e:
            logger.error(f"シミュレーションステップ中にエラー: {e}")
            break

    # シミュレーション終了処理
    runner.finalize(output_dir)
    logger.info("シミュレーション正常終了")


def main():
    """メイン関数"""
    # コマンドライン引数の解析
    args = parse_args()

    # 設定ファイルの読み込み
    config = load_config(args.config)

    # ロガーの設定
    logger = setup_logging(config, args.debug)

    # チェックポイントファイルのパス
    checkpoint = Path(args.checkpoint) if args.checkpoint else None

    try:
        # シミュレーションの初期化
        runner, initial_state = initialize_simulation(config, logger, checkpoint)

        # シミュレーションの実行
        run_simulation(runner, initial_state, config, logger)

        return 0

    except Exception as e:
        logger.error(f"シミュレーション中にエラーが発生: {e}")
        import traceback

        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())

```

### config.yaml

```
# Two-phase flow simulation configuration

# 物理パラメータ
physics:
  gravity: 9.81  # 重力加速度 [m/s²]
  surface_tension: 0.072  # 表面張力係数 [N/m]

# 相の物性値
phases:
  water:
    density: 1000.0  # 密度 [kg/m³]
    viscosity: 1.0e-3  # 動粘性係数 [Pa·s]
    surface_tension: 0.07  # 表面張力係数 [N/m]
  nitrogen:
    density: 1.25  # 密度 [kg/m³]
    viscosity: 1.81e-5  # 動粘性係数 [Pa·s]
    surface_tension: 0.0  # 表面張力係数 [N/m]

# 計算領域の設定
domain:
  dimensions: [32, 32, 32]  # X, Y, Z方向のグリッドポイント数
  size: [1.0, 1.0, 1.0]  # X, Y, Z方向の物理的サイズ [m]

# 境界条件
boundary_conditions:
  x: 
    left: periodic
    right: periodic
  y: 
    front: periodic
    back: periodic
  z: 
    bottom: neumann
    top: neumann

# 初期条件
initial_conditions:
  background:
    phase: water
    height_fraction: 0.80

  objects:
    - type: sphere
      phase: nitrogen
      center: [0.5, 0.5, 0.4]
      radius: 0.2

  velocity:
    type: zero

# 数値スキーム
numerical:
  time_integrator: "euler"  # または "rk4"
  max_time: 2.0
  initial_dt: 0.001
  save_interval: 0.01

  level_set:
    epsilon: 1.0e-2
    reinit_interval: 5
    reinit_steps: 2

# 可視化設定
output:
  output_dir: "results/visualization"
  format: "png"  # 出力フォーマット
  dpi: 300       # 解像度
  colormap: "viridis"  # デフォルトのカラーマップ
  show_colorbar: true  # カラーバーの表示
  show_axes: true      # 軸の表示
  show_grid: false     # グリッドの表示

  # スライス位置と軸を明示的に指定
  slices:
    axes: 
      - "xy"   # XY面
      - "xz"   # XZ面
      - "yz"   # YZ面
    positions: 
      - 0.5    # 中央

  # 可視化する物理量を選択
  fields:
    velocity:
      enabled: false   # 速度場を可視化
    pressure:
      enabled: true   # 圧力場を可視化
    levelset:
      enabled: true

# デバッグ設定
debug:
  level: "info"
  save_fields: true
  check_divergence: true
  plot_residuals: true
  profiling: false
```

### tree.txt

```
.
├── config.yaml
├── core
│   ├── boundary
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── dirichlet.py
│   │   ├── neumann.py
│   │   └── periodic.py
│   ├── field
│   │   ├── __init__.py
│   │   ├── conserved.py
│   │   ├── field.py
│   │   ├── scalar.py
│   │   └── vector.py
│   └── solver
│       ├── __init__.py
│       ├── base.py
│       ├── iterative.py
│       └── temporal.py
├── logger
│   ├── __init__.py
│   ├── config.py
│   ├── formatters.py
│   ├── handlers.py
│   └── logger.py
├── main.py
├── main2.py
├── physics
│   ├── levelset
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── config.py
│   │   ├── field.py
│   │   ├── properties.py
│   │   ├── reinitialize.py
│   │   ├── solver.py
│   │   └── utils.py
│   ├── navier_stokes
│   │   ├── __init__.py
│   │   ├── core
│   │   │   ├── base_solver.py
│   │   │   ├── interfaces.py
│   │   │   └── state.py
│   │   ├── solvers
│   │   │   ├── __init__.py
│   │   │   ├── basic_solver.py
│   │   │   └── projection_solver.py
│   │   ├── terms
│   │   │   ├── __init__.py
│   │   │   ├── advection.py
│   │   │   ├── base.py
│   │   │   ├── diffusion.py
│   │   │   ├── force.py
│   │   │   └── pressure.py
│   │   └── utils
│   │       ├── __init__.py
│   │       ├── projection.py
│   │       └── time_integration.py
│   ├── poisson
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── config.py
│   │   ├── methods
│   │   │   └── sor.py
│   │   └── solver.py
│   ├── time_evolution
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── integrator.py
│   │   ├── methods
│   │   │   ├── __init__.py
│   │   │   ├── euler.py
│   │   │   └── runge_kutta.py
│   │   └── solver.py
│   └── utils
├── results
│   └── visualization
│       └── logs
│           └── simulation.log
├── simulations
│   ├── __init__.py
│   ├── config
│   │   ├── __init__.py
│   │   └── simulation_config.py
│   ├── initializer.py
│   ├── simulation.py
│   └── state.py
├── tree.txt
└── visualization
    ├── __init__.py
    ├── core
    │   ├── __init__.py
    │   ├── base.py
    │   ├── exporter.py
    │   └── renderer.py
    ├── interfaces.py
    ├── renderer_strategy.py
    ├── renderers
    │   ├── __init__.py
    │   ├── scalar2d.py
    │   ├── scalar3d.py
    │   ├── vector2d.py
    │   └── vector3d.py
    ├── utils
    │   ├── camera.py
    │   └── colormap.py
    └── visualizer.py

27 directories, 81 files

```

### physics/levelset/solver.py

```
"""Level Set法のソルバーを提供するモジュール

このモジュールは、Level Set方程式の時間発展を計算するためのソルバーを提供します。
"""

from typing import Dict, Any, Optional, List
import numpy as np

from .base import LevelSetSolverBase, LevelSetTerm
from .field import LevelSetField
from .utils import extend_velocity
from .reinitialize import reinitialize_levelset


class LevelSetSolver(LevelSetSolverBase):
    """Level Set法のソルバークラス"""

    def __init__(
        self,
        config: Optional[Dict[str, Any]] = None,
        terms: Optional[List[LevelSetTerm]] = None,
        logger=None,
        **kwargs,  # 追加のキーワード引数を許可
    ):
        """ソルバーを初期化

        Args:
            config: ソルバー設定
            terms: Level Set方程式の各項
            logger: ロガー
            **kwargs: 追加のキーワード引数
        """
        # デフォルト設定
        config = config or {}

        # キーワード引数から空間離散化パラメータを抽出
        use_weno = kwargs.get(
            "use_weno", config.get("discretization", {}).get("scheme", "weno") == "weno"
        )
        weno_order = kwargs.get(
            "weno_order", config.get("discretization", {}).get("order", 5)
        )

        # 基底クラスの初期化
        super().__init__(use_weno=use_weno, weno_order=weno_order, logger=logger)

        # 項の設定
        self.terms = terms or []

    def compute_derivative(self, state: Any, **kwargs) -> LevelSetField:
        """Level Set関数の時間微分を計算

        Args:
            state: 現在の状態
            **kwargs: 追加のパラメータ

        Returns:
            計算された時間微分
        """
        velocity = kwargs.get("velocity")
        if velocity is None:
            raise ValueError("速度場が指定されていません")

        # 結果を格納するLevel Set場
        result = LevelSetField(
            data=np.zeros_like(state.data), dx=state.dx, params=state.params
        )

        if self.use_weno:
            # WENOスキームによる空間離散化
            flux = np.zeros_like(state.data)
            for i, v in enumerate(velocity.components):
                # 風上差分の方向を決定
                upwind = v.data < 0

                # 正の速度に対する flux
                phi_plus = self._compute_weno_reconstruction(state.data, i)
                # 負の速度に対する flux
                phi_minus = self._compute_weno_reconstruction(np.flip(state.data, i), i)
                phi_minus = np.flip(phi_minus, i)

                # 風上方向に応じてfluxを選択
                flux += v.data * np.where(upwind, phi_minus, phi_plus)

            result.data = -flux

        else:
            # 標準的な中心差分
            flux = sum(
                v.data * state.gradient(i) for i, v in enumerate(velocity.components)
            )
            result.data = -flux

        # 追加の項の寄与を計算
        for term in self.terms:
            if term.enabled:
                result.data += term.compute(state.data, velocity.data)

        return result

    def compute_timestep(self, **kwargs) -> float:
        """CFL条件に基づく時間刻み幅を計算

        Args:
            **kwargs: 必要なパラメータ
                - state: 現在のシミュレーション状態

        Returns:
            計算された時間刻み幅
        """
        state = kwargs.get("state")
        if state is None:
            raise ValueError("stateが指定されていません")

        # 速度の最大値を計算
        velocity = state.velocity
        max_velocity = max(np.max(np.abs(comp.data)) for comp in velocity.components)

        # CFL条件に基づく時間刻み幅
        dx = state.dx
        return 0.5 * dx / (max_velocity + 1e-10)

    def step_forward(self, dt: float, **kwargs) -> Dict[str, Any]:
        """1時間ステップを進める

        Args:
            dt: 時間刻み幅
            **kwargs: 追加のパラメータ
                - state: 現在のシミュレーション状態

        Returns:
            計算結果と診断情報を含む辞書
        """
        try:
            state = kwargs.get("state")
            if state is None:
                raise ValueError("stateが指定されていません")

            # 速度場の拡張
            velocity = kwargs.get("velocity")
            if velocity is not None:
                velocity_extended = extend_velocity(velocity.data, state.data, state.dx)
            else:
                velocity_extended = None

            # 時間発展の実行
            derivative = self.compute_derivative(
                state, velocity=velocity, velocity_data=velocity_extended
            )

            # 新しいLevel Set場の計算
            levelset_new = LevelSetField(
                data=state.data + dt * derivative.data, dx=state.dx, params=state.params
            )

            # 再初期化の検討
            if levelset_new.need_reinit():
                levelset_new = reinitialize_levelset(
                    levelset_new,
                    dt=levelset_new.params.reinit_dt,
                    n_steps=levelset_new.params.reinit_steps,
                )

            # 体積保存の補正
            initial_volume = state.compute_volume()
            current_volume = levelset_new.compute_volume()
            if abs(current_volume) > 1e-10:
                levelset_new.data *= (initial_volume / current_volume) ** (
                    1.0 / levelset_new.ndim
                )

            # 診断情報の収集
            diagnostics = {
                "time": self._time + dt,
                "dt": dt,
                "reinitialized": levelset_new.need_reinit(),
                "volume": float(levelset_new.compute_volume()),
                "volume_error": float(
                    abs(levelset_new.compute_volume() / initial_volume - 1.0)
                ),
                "interface_area": float(levelset_new.compute_area()),
            }

            return {
                "levelset": levelset_new,
                "time": self._time + dt,
                "diagnostics": diagnostics,
            }

        except Exception as e:
            if self.logger:
                self.logger.error(f"Level Setソルバーの時間発展中にエラー: {e}")
            raise

    def get_diagnostics(self) -> Dict[str, Any]:
        """ソルバーの診断情報を取得

        Returns:
            診断情報の辞書
        """
        diag = {
            "weno_order": self.weno_order,
            "discretization_scheme": "WENO" if self.use_weno else "Central",
            "active_terms": len(self.terms),
        }

        # 各項の診断情報を追加
        term_diagnostics = {}
        for term in self.terms:
            if term.enabled:
                term_diagnostics[term.name] = term.get_diagnostics()

        if term_diagnostics:
            diag["terms"] = term_diagnostics

        return diag

```

### physics/levelset/base.py

```
"""Level Set法の基底クラスとプロトコルを定義"""

from abc import ABC, abstractmethod
from typing import Protocol, Dict, Any, Optional
import numpy as np


class LevelSetTerm(Protocol):
    """Level Set方程式の項のプロトコル"""

    @property
    def name(self) -> str:
        """項の名前"""
        ...

    def compute(
        self,
        levelset: np.ndarray,
        velocity: Optional[np.ndarray] = None,
        dt: float = 0.0,
        **kwargs,
    ) -> np.ndarray:
        """Level Set場への寄与を計算"""
        ...

    def get_diagnostics(
        self, levelset: np.ndarray, velocity: Optional[np.ndarray] = None, **kwargs
    ) -> Dict[str, Any]:
        """診断情報を取得"""
        ...


class LevelSetTermBase:
    """Level Set項の基底実装"""

    def __init__(self, name: str, enabled: bool = True):
        """基底クラスを初期化

        Args:
            name: 項の名前
            enabled: 項が有効かどうか
        """
        self._name = name
        self._enabled = enabled
        self._diagnostics: Dict[str, Any] = {}

    @property
    def name(self) -> str:
        """項の名前を取得"""
        return self._name

    @property
    def enabled(self) -> bool:
        """項が有効かどうかを取得"""
        return self._enabled

    @enabled.setter
    def enabled(self, value: bool):
        """項の有効/無効を設定"""
        self._enabled = value

    def get_diagnostics(
        self, levelset: np.ndarray, velocity: Optional[np.ndarray] = None, **kwargs
    ) -> Dict[str, Any]:
        """診断情報を取得"""
        return {"name": self.name, "enabled": self.enabled, **self._diagnostics}

    def update_diagnostics(self, **kwargs):
        """診断情報を更新"""
        self._diagnostics.update(kwargs)


class LevelSetSolverBase(ABC):
    """Level Set ソルバーの基底抽象クラス"""

    def __init__(self, use_weno: bool = True, weno_order: int = 5, logger=None):
        """基底ソルバーを初期化

        Args:
            use_weno: WENOスキームを使用するかどうか
            weno_order: WENOスキームの次数
            logger: ロガー
        """
        self.use_weno = use_weno
        self.weno_order = weno_order
        self.logger = logger

        # 計算状態の追跡
        self._time = 0.0
        self._dt = None
        self._iteration_count = 0

    @abstractmethod
    def compute_derivative(self, state: Any, **kwargs) -> np.ndarray:
        """Level Set関数の時間微分を計算"""
        pass

    @abstractmethod
    def compute_timestep(self, **kwargs) -> float:
        """CFL条件に基づく時間刻み幅を計算"""
        pass

    def _compute_weno_reconstruction(self, values: np.ndarray, axis: int) -> np.ndarray:
        """WENOスキームによる再構築の共通実装

        Args:
            values: 再構築する値の配列
            axis: 再構築を行う軸

        Returns:
            再構築された値
        """
        # WENO5の実装
        if self.weno_order == 5:
            v1 = np.roll(values, 2, axis=axis)
            v2 = np.roll(values, 1, axis=axis)
            v3 = values
            v4 = np.roll(values, -1, axis=axis)
            v5 = np.roll(values, -2, axis=axis)

            # 各ステンシルでの滑らかさ指標を計算
            eps = 1e-6  # ゼロ除算防止用
            beta0 = (
                13 / 12 * (v1 - 2 * v2 + v3) ** 2 + 1 / 4 * (v1 - 4 * v2 + 3 * v3) ** 2
            )
            beta1 = 13 / 12 * (v2 - 2 * v3 + v4) ** 2 + 1 / 4 * (v2 - v4) ** 2
            beta2 = (
                13 / 12 * (v3 - 2 * v4 + v5) ** 2 + 1 / 4 * (3 * v3 - 4 * v4 + v5) ** 2
            )

            # 非線形重みを計算
            weights = np.array([0.1, 0.6, 0.3])
            alpha0 = weights[0] / (eps + beta0) ** 2
            alpha1 = weights[1] / (eps + beta1) ** 2
            alpha2 = weights[2] / (eps + beta2) ** 2
            alpha_sum = alpha0 + alpha1 + alpha2

            omega0 = alpha0 / alpha_sum
            omega1 = alpha1 / alpha_sum
            omega2 = alpha2 / alpha_sum

            # 各ステンシルでの補間値を計算
            weno_coeffs = [
                [1 / 3, -7 / 6, 11 / 6],  # 左側ステンシル
                [-1 / 6, 5 / 6, 1 / 3],  # 中央ステンシル
                [1 / 3, 5 / 6, -1 / 6],  # 右側ステンシル
            ]

            p0 = (
                weno_coeffs[0][0] * v1 + weno_coeffs[0][1] * v2 + weno_coeffs[0][2] * v3
            )
            p1 = (
                weno_coeffs[1][0] * v2 + weno_coeffs[1][1] * v3 + weno_coeffs[1][2] * v4
            )
            p2 = (
                weno_coeffs[2][0] * v3 + weno_coeffs[2][1] * v4 + weno_coeffs[2][2] * v5
            )

            return omega0 * p0 + omega1 * p1 + omega2 * p2

        # WENO3の実装
        elif self.weno_order == 3:
            v1 = np.roll(values, 1, axis=axis)
            v2 = values
            v3 = np.roll(values, -1, axis=axis)

            # 各ステンシルでの滑らかさ指標を計算
            beta0 = (v2 - v1) ** 2
            beta1 = (v3 - v2) ** 2

            eps = 1e-6
            weights = np.array([1 / 3, 2 / 3])
            alpha0 = weights[0] / (eps + beta0) ** 2
            alpha1 = weights[1] / (eps + beta1) ** 2
            alpha_sum = alpha0 + alpha1

            omega0 = alpha0 / alpha_sum
            omega1 = alpha1 / alpha_sum

            weno_coeffs = [
                [-1 / 2, 3 / 2],  # 左側ステンシル
                [1 / 2, 1 / 2],  # 右側ステンシル
            ]

            p0 = weno_coeffs[0][0] * v1 + weno_coeffs[0][1] * v2
            p1 = weno_coeffs[1][0] * v2 + weno_coeffs[1][1] * v3

            return omega0 * p0 + omega1 * p1

        else:
            raise ValueError(f"未対応のWENO次数です: {self.weno_order}")

```

### physics/levelset/properties.py

```
"""Level Set法における物性値と界面特性の管理モジュール

このモジュールは、二相流体シミュレーションにおける物性値の計算と
界面特性の追跡を統合的に管理します。
"""

from dataclasses import dataclass
from typing import Optional, Protocol
import numpy as np

from .utils import heaviside


class PhaseProperties(Protocol):
    """相の物性値プロトコル"""

    @property
    def density(self) -> float:
        """密度"""
        ...

    @property
    def viscosity(self) -> float:
        """粘性係数"""
        ...

    @property
    def surface_tension(self) -> Optional[float]:
        """表面張力係数"""
        ...


@dataclass
class FluidPhaseProperties:
    """具体的な流体相の物性値"""

    density: float
    viscosity: float
    surface_tension: Optional[float] = None

    def __post_init__(self):
        """物性値の妥当性検証"""
        if self.density <= 0:
            raise ValueError("密度は正の値である必要があります")
        if self.viscosity <= 0:
            raise ValueError("粘性係数は正の値である必要があります")
        if self.surface_tension is not None and self.surface_tension < 0:
            raise ValueError("表面張力係数は非負である必要があります")


class LevelSetPropertiesManager:
    """Level Set法における物性値管理クラス"""

    def __init__(
        self, phase1: PhaseProperties, phase2: PhaseProperties, epsilon: float = 1.0e-2
    ):
        """物性値マネージャーを初期化

        Args:
            phase1: 第1相の物性値
            phase2: 第2相の物性値
            epsilon: 界面厚さ
        """
        self._phase1 = phase1
        self._phase2 = phase2
        self._epsilon = epsilon

    def compute_density(self, levelset: np.ndarray) -> np.ndarray:
        """密度場を計算

        Args:
            levelset: Level Set場

        Returns:
            密度場
        """
        # Heaviside関数による補間
        H = heaviside(levelset, self._epsilon)
        return self._phase1.density * H + self._phase2.density * (1 - H)

    def compute_viscosity(
        self, levelset: np.ndarray, method: str = "arithmetic"
    ) -> np.ndarray:
        """粘性係数場を計算

        Args:
            levelset: Level Set場
            method: 補間方法（'arithmetic' または 'harmonic'）

        Returns:
            粘性係数場
        """
        # Heaviside関数による補間
        H = heaviside(levelset, self._epsilon)

        # 補間方法の選択
        if method == "harmonic":
            return 1.0 / (H / self._phase1.viscosity + (1 - H) / self._phase2.viscosity)
        else:  # デフォルトは算術平均
            return self._phase1.viscosity * H + self._phase2.viscosity * (1 - H)

    def compute_surface_tension(self, levelset: np.ndarray) -> Optional[np.ndarray]:
        """表面張力係数場を計算

        Args:
            levelset: Level Set場

        Returns:
            表面張力係数場（表面張力が定義されていない場合はNone）
        """
        # 両相の表面張力係数が定義されている場合のみ計算
        if self._phase1.surface_tension is None or self._phase2.surface_tension is None:
            return None

        # 平均表面張力係数
        surface_tension_coeff = 0.5 * (
            self._phase1.surface_tension + self._phase2.surface_tension
        )

        return surface_tension_coeff

```

### physics/levelset/field.py

```
"""Level Set場を定義するモジュール

このモジュールは、Level Set法で使用される場のクラスを提供します。
"""

from dataclasses import dataclass
from typing import Optional, Tuple, Union
import numpy as np

from .utils import (
    compute_volume,
    compute_area,
    heaviside,
    delta,
    compute_curvature,
    compute_interface_gradient,
)


@dataclass
class LevelSetParameters:
    """Level Set法のパラメータ"""

    epsilon: float = 1.0e-2  # 界面の厚さ
    min_value: float = 1.0e-10  # 最小値
    reinit_interval: int = 5  # 再初期化の間隔
    reinit_steps: int = 2  # 再初期化のステップ数
    reinit_dt: float = 0.1  # 再初期化の時間刻み


class LevelSetField:
    """Level Set場クラス

    Level Set関数を表現し、界面追跡のための基本的な操作を提供します。
    """

    def __init__(
        self,
        shape: Union[Tuple[int, ...], np.ndarray],
        dx: float = 1.0,
        params: Optional[LevelSetParameters] = None,
    ):
        """Level Set場を初期化

        Args:
            shape: グリッドの形状またはデータ配列
            dx: グリッド間隔
            params: Level Setパラメータ
        """
        # shapeがタプルの場合は新しい配列を作成
        if isinstance(shape, tuple):
            self._data = np.zeros(shape)
        # ndarrayの場合はコピーを作成
        else:
            self._data = shape.copy()

        self._dx = dx
        self.params = params or LevelSetParameters()

        # ステップ管理
        self._steps_since_reinit = 0
        self._initial_volume = self.compute_volume()

    @property
    def data(self) -> np.ndarray:
        """Level Set関数のデータを取得"""
        return self._data

    @data.setter
    def data(self, value: np.ndarray):
        """Level Set関数のデータを設定

        Args:
            value: 設定するデータ配列

        Raises:
            ValueError: データの形状が不一致の場合
        """
        if isinstance(value, np.ndarray):
            if value.shape != self._data.shape:
                raise ValueError(
                    f"形状が一致しません: {value.shape} != {self._data.shape}"
                )
            self._data = value.copy()
        else:
            self._data = np.asarray(value)

    @property
    def shape(self) -> Tuple[int, ...]:
        """グリッドの形状を取得"""
        return self._data.shape

    @property
    def dx(self) -> float:
        """グリッド間隔を取得"""
        return self._dx

    @property
    def ndim(self) -> int:
        """次元数を取得"""
        return self._data.ndim

    def heaviside(self) -> np.ndarray:
        """Heaviside関数の値を計算

        Returns:
            Heaviside関数の値
        """
        return heaviside(self._data, self.params.epsilon)

    def delta(self) -> np.ndarray:
        """Delta関数の値を計算

        Returns:
            Delta関数の値
        """
        return delta(self._data, self.params.epsilon)

    def curvature(self) -> np.ndarray:
        """界面の曲率を計算

        Returns:
            界面の曲率
        """
        return compute_curvature(self._data, self._dx)

    def compute_volume(self) -> float:
        """体積を計算

        Returns:
            計算された体積
        """
        return compute_volume(self._data, self._dx)

    def compute_area(self) -> float:
        """界面の面積を計算

        Returns:
            計算された面積
        """
        return compute_area(self._data, self._dx)

    def compute_interface_gradient(self) -> np.ndarray:
        """界面の法線ベクトルを計算

        Returns:
            界面の法線ベクトル
        """
        return compute_interface_gradient(self._data, self._dx)

    def gradient(self, axis: int) -> np.ndarray:
        """指定軸方向の勾配を計算

        Args:
            axis: 勾配を計算する軸のインデックス

        Returns:
            計算された勾配
        """
        return np.gradient(self._data, self._dx, axis=axis)

    def need_reinit(self) -> bool:
        """再初期化が必要かどうかを判定

        Returns:
            再初期化が必要かどうか
        """
        return (
            self._steps_since_reinit >= self.params.reinit_interval
            or not self._is_signed_distance_function()
        )

    def _is_signed_distance_function(self, tolerance: float = 1e-2) -> bool:
        """符号付き距離関数としての性質を検証

        Args:
            tolerance: 許容誤差

        Returns:
            符号付き距離関数の条件を満たすかどうか
        """
        # 勾配の大きさが1に近いかチェック
        grad = np.gradient(self._data, self._dx)
        grad_norm = np.sqrt(sum(g**2 for g in grad))

        # 勾配の大きさが1にどれだけ近いか
        is_unit_gradient = np.abs(grad_norm - 1.0)

        # 界面の幅をチェック
        interface_width = np.sum(self.delta() > 0) * self._dx**self.ndim

        # 両条件を確認
        return np.mean(is_unit_gradient) < tolerance and interface_width < tolerance

    def advance_step(self):
        """時間ステップを進める"""
        self._steps_since_reinit += 1

    def get_interface_points(self) -> np.ndarray:
        """界面上の点を取得

        Returns:
            界面上の点の座標
        """
        # Delta関数を使用して界面上の点を抽出
        interface_mask = self.delta() > 0
        return np.argwhere(interface_mask)

    def copy(self) -> "LevelSetField":
        """フィールドの深いコピーを作成

        Returns:
            コピーされたLevel Set場
        """
        return LevelSetField(data=self._data.copy(), dx=self._dx, params=self.params)

```

### physics/levelset/__init__.py

```
"""Level Set法パッケージ

このパッケージは、Level Set法による界面追跡のための機能を提供します。
"""

from .base import LevelSetTerm, LevelSetTermBase, LevelSetSolverBase
from .properties import PhaseProperties, FluidPhaseProperties, LevelSetPropertiesManager
from .field import LevelSetField, LevelSetParameters
from .solver import LevelSetSolver
from .utils import (
    heaviside,
    delta,
    compute_curvature,
    compute_volume,
    compute_area,
    extend_velocity,
)
from .reinitialize import reinitialize_levelset

__all__ = [
    # 基底クラスとインターフェース
    "LevelSetTerm",
    "LevelSetTermBase",
    "LevelSetSolverBase",
    # プロパティ関連
    "PhaseProperties",
    "FluidPhaseProperties",
    "LevelSetPropertiesManager",
    # フィールドクラス
    "LevelSetField",
    "LevelSetParameters",
    # ソルバー
    "LevelSetSolver",
    # ユーティリティ関数
    "heaviside",
    "delta",
    "compute_curvature",
    "compute_volume",
    "compute_area",
    "extend_velocity",
    "reinitialize_levelset",
]

```

### physics/levelset/utils.py

```
"""Level Set法のユーティリティ関数を提供するモジュール"""

import numpy as np


def heaviside(phi: np.ndarray, epsilon: float = 1.0e-2) -> np.ndarray:
    """正則化されたHeaviside関数

    Args:
        phi: Level Set関数
        epsilon: 界面の厚さ

    Returns:
        正則化されたHeaviside関数の値
    """
    return 0.5 * (1.0 + np.tanh(phi / epsilon))


def delta(phi: np.ndarray, epsilon: float = 1.0e-2) -> np.ndarray:
    """正則化されたDelta関数

    Args:
        phi: Level Set関数
        epsilon: 界面の厚さ

    Returns:
        正則化されたDelta関数の値
    """
    return 0.5 / epsilon * (1.0 - np.tanh(phi / epsilon) ** 2)


def compute_curvature(phi: np.ndarray, dx: float) -> np.ndarray:
    """界面の曲率を計算

    Args:
        phi: Level Set関数
        dx: グリッド間隔

    Returns:
        界面の曲率
    """
    # 勾配を計算
    grad = np.array(np.gradient(phi, dx))
    grad_norm = np.sqrt(np.sum(grad**2, axis=0))
    grad_norm = np.maximum(grad_norm, 1e-10)  # ゼロ除算を防ぐ

    # 正規化された勾配
    grad_normalized = grad / grad_norm

    # 発散を計算して曲率を得る
    return sum(np.gradient(grad_normalized[i], dx, axis=i) for i in range(phi.ndim))


def compute_volume(phi: np.ndarray, dx: float) -> float:
    """Level Set関数から体積を計算

    Args:
        phi: Level Set関数
        dx: グリッド間隔

    Returns:
        計算された体積
    """
    return float(np.sum(heaviside(phi)) * dx**phi.ndim)


def compute_area(phi: np.ndarray, dx: float) -> float:
    """Level Set関数から界面の面積を計算

    Args:
        phi: Level Set関数
        dx: グリッド間隔

    Returns:
        計算された界面の面積
    """
    return float(np.sum(delta(phi)) * dx**phi.ndim)


def compute_interface_gradient(phi: np.ndarray, dx: float) -> np.ndarray:
    """界面の法線ベクトルを計算

    Args:
        phi: Level Set関数
        dx: グリッド間隔

    Returns:
        界面の法線ベクトル
    """
    # 勾配を計算
    grad = np.array(np.gradient(phi, dx))

    # 勾配の大きさを計算
    grad_norm = np.sqrt(np.sum(grad**2, axis=0))
    grad_norm = np.maximum(grad_norm, 1e-10)  # ゼロ除算を防ぐ

    # 正規化された勾配（法線ベクトル）
    return grad / grad_norm


def extend_velocity(
    velocity: np.ndarray, phi: np.ndarray, dx: float, n_steps: int = 5
) -> np.ndarray:
    """界面の法線方向に速度場を拡張

    Args:
        velocity: 速度場
        phi: Level Set関数
        dx: グリッド間隔
        n_steps: 拡張のステップ数

    Returns:
        拡張された速度場
    """
    result = velocity.copy()
    dt = 0.5 * dx  # 仮想時間の時間刻み幅

    for _ in range(n_steps):
        # 法線ベクトルを計算
        grad = np.array(np.gradient(phi, dx))
        grad_norm = np.sqrt(np.sum(grad**2, axis=0))
        grad_norm = np.maximum(grad_norm, 1e-10)
        normal = grad / grad_norm

        # 速度勾配を計算
        vel_grad = np.array(np.gradient(result, dx))

        # 法線方向の速度勾配を解消
        result -= dt * sum(normal[i] * vel_grad[i] for i in range(phi.ndim))

    return result

```

### physics/levelset/reinitialize.py

```
"""Level Set関数の再初期化を提供するモジュール

このモジュールは、Level Set関数を符号付き距離関数として再初期化する
ための高精度な数値計算手法を実装します。
"""

from typing import Optional
import numpy as np
from scipy.ndimage import gaussian_filter

from .field import LevelSetField
from .utils import delta


def reinitialize_levelset(
    levelset: LevelSetField,
    dt: Optional[float] = None,
    n_steps: Optional[int] = None,
    method: str = "fast_marching",
) -> LevelSetField:
    """Level Set関数を再初期化

    Args:
        levelset: 再初期化するLevel Set場
        dt: 仮想時間の時間刻み幅（Noneの場合は設定から取得）
        n_steps: 反復回数（Noneの場合は設定から取得）
        method: 再初期化手法

    Returns:
        再初期化されたLevel Set場
    """
    # パラメータの決定
    dt = dt or levelset.params.reinit_dt
    n_steps = n_steps or levelset.params.reinit_steps

    # 初期の符号を保存
    original_sign = np.sign(levelset.data)

    # 再初期化手法の選択
    if method == "fast_marching":
        new_data = _fast_marching_reinit(
            levelset.data,
            levelset.dx,
            dt=dt,
            n_steps=n_steps,
            epsilon=levelset.params.epsilon,
        )
    elif method == "pde":
        new_data = _pde_reinit(
            levelset.data,
            levelset.dx,
            dt=dt,
            n_steps=n_steps,
            epsilon=levelset.params.epsilon,
        )
    else:
        raise ValueError(f"未対応の再初期化手法: {method}")

    # 初期の符号を維持
    new_data = np.copysign(new_data, original_sign)

    # 新しいLevel Set場を作成して返す
    return LevelSetField(data=new_data, dx=levelset.dx, params=levelset.params)


def _pde_reinit(
    phi: np.ndarray,
    dx: float,
    dt: float = 0.1,
    n_steps: int = 5,
    epsilon: float = 1.0e-2,
) -> np.ndarray:
    """偏微分方程式に基づく再初期化

    Args:
        phi: Level Set関数
        dx: グリッド間隔
        dt: 仮想時間の時間刻み幅
        n_steps: 再初期化の反復回数
        epsilon: 正則化パラメータ

    Returns:
        再初期化されたLevel Set関数
    """
    result = phi.copy()
    sign = np.sign(result)

    for _ in range(n_steps):
        # 勾配を計算
        grad = np.array(np.gradient(result, dx))
        grad_norm = np.sqrt(np.sum(grad**2, axis=0))

        # 時間発展方程式を解く
        result = result - dt * sign * (grad_norm - 1.0)

        # 数値的な安定化のためにぼかす
        result = gaussian_filter(result, sigma=0.5 * dx)

    return result


def _fast_marching_reinit(
    phi: np.ndarray,
    dx: float,
    dt: float = 0.1,
    n_steps: int = 5,
    epsilon: float = 1.0e-2,
) -> np.ndarray:
    """高速行進法に基づく再初期化

    Args:
        phi: Level Set関数
        dx: グリッド間隔
        dt: 仮想時間の時間刻み幅
        n_steps: 再初期化の反復回数
        epsilon: 正則化パラメータ

    Returns:
        再初期化されたLevel Set関数
    """
    result = phi.copy()
    sign = np.sign(result)

    # アクティブな点のマスクを作成
    delta_vals = delta(result, epsilon)
    active_mask = delta_vals > 0

    # 各点の符号付き距離を計算
    for _ in range(n_steps):
        # アクティブな点周辺の勾配を計算
        active_points = np.argwhere(active_mask)
        for point in active_points:
            # 最近傍点からの距離を計算
            distances = _compute_signed_distance(point, result, sign, dx)
            # 最小の距離を選択
            result[tuple(point)] = sign[tuple(point)] * np.min(np.abs(distances))

        # 数値的な安定化のためにぼかす
        result = gaussian_filter(result, sigma=0.5 * dx)

    return result


def _compute_signed_distance(
    point: np.ndarray, phi: np.ndarray, sign: np.ndarray, dx: float
) -> np.ndarray:
    """指定された点の符号付き距離を計算

    Args:
        point: 距離を計算する点の座標
        phi: Level Set関数
        sign: 符号
        dx: グリッド間隔

    Returns:
        近傍点からの符号付き距離
    """
    distances = []
    ndim = phi.ndim

    # 各近傍点について
    for offsets in np.ndindex(tuple([3] * ndim)):
        # オフセット補正（中心点を除外）
        if all(o == 1 for o in offsets):
            continue

        # 近傍点の座標を計算
        neighbor = point + np.array(offsets) - 1

        # 境界チェック
        if all(0 <= n < phi.shape[i] for i, n in enumerate(neighbor)):
            # 近傍点からの距離を計算
            distance = np.linalg.norm((neighbor - point) * dx)
            signed_dist = sign[tuple(point)] * distance
            distances.append(signed_dist)

    return np.array(distances) if distances else np.array([0.0])

```

### physics/navier_stokes/core/base_solver.py

```
"""Navier-Stokes方程式のソルバーの基底クラスを提供

このモジュールは、Navier-Stokesソルバーの基本機能を実装する
抽象基底クラスを提供します。
"""

from typing import Dict, Any, List, Optional
from abc import abstractmethod

from core.field import VectorField
from physics.levelset import LevelSetField, LevelSetPropertiesManager
from .interfaces import NavierStokesSolver, NavierStokesTerm, TimeIntegrator


class NavierStokesBase(NavierStokesSolver):
    """Navier-Stokesソルバーの基底クラス"""

    def __init__(
        self,
        time_integrator: TimeIntegrator,
        terms: List[NavierStokesTerm],
        properties: Optional[LevelSetPropertiesManager] = None,
        logger=None,
    ):
        """基底クラスを初期化

        Args:
            time_integrator: 時間積分スキーム
            terms: NS方程式の各項
            properties: 物性値マネージャー
            logger: ロガー
        """
        self.time_integrator = time_integrator
        self.terms = terms
        self.properties = properties
        self.logger = logger

        # 内部状態の初期化
        self._time = 0.0
        self._iteration_count = 0
        self._diagnostics: Dict[str, Any] = {}

    @property
    def name(self) -> str:
        """ソルバーの名前を取得"""
        return "NavierStokesBase"

    @property
    def time(self) -> float:
        """現在の時刻を取得"""
        return self._time

    @property
    def iteration_count(self) -> int:
        """反復回数を取得"""
        return self._iteration_count

    def initialize(self, **kwargs) -> None:
        """ソルバーを初期化"""
        self._time = 0.0
        self._iteration_count = 0
        self._diagnostics.clear()

    @abstractmethod
    def compute_derivative(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> VectorField:
        """速度場の時間微分を計算"""
        pass

    def compute_timestep(self, **kwargs) -> float:
        """時間刻み幅を計算

        各項の制限のうち最も厳しいものを採用
        """
        state = kwargs.get("state")
        if state is None:
            raise ValueError("stateが指定されていません")

        dt_limits = []
        for term in self.terms:
            dt = term.compute_timestep(
                state.velocity, state.levelset, state.properties, **kwargs
            )
            if dt > 0:  # 有効な制限のみ考慮
                dt_limits.append(dt)

        if not dt_limits:
            raise ValueError("有効な時間刻み幅の制限がありません")

        return min(dt_limits)

    def step_forward(self, dt: float, **kwargs) -> Dict[str, Any]:
        """1時間ステップを進める"""
        state = kwargs.get("state")
        if state is None:
            raise ValueError("stateが指定されていません")

        try:
            # 時間発展の実行
            next_state = self.time_integrator.step(
                state=state,
                dt=dt,
                compute_derivative=self.compute_derivative,
                **kwargs,
            )

            # 内部状態の更新
            self._time += dt
            self._iteration_count += 1

            # 診断情報の収集
            diagnostics = self._collect_diagnostics(next_state, dt)

            return {
                "state": next_state,
                "diagnostics": diagnostics,
                "time": self._time,
                "dt": dt,
            }

        except Exception as e:
            if self.logger:
                self.logger.error(f"時間発展計算中にエラー: {e}")
            raise

    def finalize(self, **kwargs) -> None:
        """ソルバーの終了処理"""
        pass

    def get_diagnostics(self) -> Dict[str, Any]:
        """ソルバーの診断情報を取得"""
        return {
            "time": self._time,
            "iterations": self._iteration_count,
            "terms": [term.name for term in self.terms],
            **self._diagnostics,
        }

    def _collect_diagnostics(self, state: Any, dt: float) -> Dict[str, Any]:
        """診断情報を収集"""
        diag = {
            "time": self._time,
            "dt": dt,
            "iteration": self._iteration_count,
        }

        # 各項の診断情報を収集
        for term in self.terms:
            diag[term.name] = term.get_diagnostics()

        return diag

    def log(self, level: str, msg: str):
        """ログを出力"""
        if self.logger:
            log_method = getattr(self.logger, level, None)
            if log_method:
                log_method(msg)

```

### physics/navier_stokes/core/interfaces.py

```
"""Navier-Stokes方程式に関する基本インターフェースを定義

このモジュールは、Navier-Stokes方程式のソルバー、項、状態などの
基本的なインターフェースを定義します。
"""

from abc import abstractmethod
from typing import Protocol, Dict, Any, List, Optional
import numpy as np

from core.field import VectorField, ScalarField
from physics.levelset import LevelSetField, LevelSetPropertiesManager


class NSComponent(Protocol):
    """Navier-Stokes方程式の構成要素の基本インターフェース"""

    @property
    def name(self) -> str:
        """コンポーネントの名前"""
        ...

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        ...


class NavierStokesTerm(NSComponent, Protocol):
    """Navier-Stokes方程式の項のインターフェース"""

    @abstractmethod
    def compute(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> List[np.ndarray]:
        """項の寄与を計算"""
        ...

    @abstractmethod
    def compute_timestep(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> float:
        """項に基づく時間刻み幅の制限を計算"""
        ...


class TimeIntegrator(Protocol):
    """時間積分スキームのインターフェース"""

    @abstractmethod
    def step(
        self,
        state: Any,
        dt: float,
        compute_derivative: Any,
        **kwargs,
    ) -> Any:
        """1時間ステップを実行"""
        ...


class PressureProjection(Protocol):
    """圧力投影法のインターフェース"""

    @abstractmethod
    def project(
        self,
        velocity: VectorField,
        pressure: ScalarField,
        dt: float,
        levelset: Optional[LevelSetField] = None,
        properties: Optional[LevelSetPropertiesManager] = None,
    ) -> tuple[VectorField, ScalarField]:
        """速度場を非圧縮に投影し、圧力を更新"""
        ...


class NavierStokesSolver(NSComponent, Protocol):
    """Navier-Stokesソルバーのインターフェース"""

    @abstractmethod
    def initialize(self, **kwargs) -> None:
        """ソルバーを初期化"""
        ...

    @abstractmethod
    def step_forward(self, dt: float, **kwargs) -> Dict[str, Any]:
        """1時間ステップを進める"""
        ...

    @abstractmethod
    def compute_timestep(self, **kwargs) -> float:
        """時間刻み幅を計算"""
        ...

    @abstractmethod
    def finalize(self, **kwargs) -> None:
        """ソルバーの終了処理"""
        ...

```

### physics/navier_stokes/core/state.py

```
"""Navier-Stokes方程式の状態を管理するモジュール

このモジュールは、Navier-Stokes方程式の状態（速度場、圧力場など）を
管理するためのクラスを提供します。
"""

from dataclasses import dataclass
from typing import Optional, Dict, Any
import numpy as np

from core.field import VectorField, ScalarField
from physics.levelset import LevelSetField, LevelSetPropertiesManager


@dataclass
class NavierStokesState:
    """Navier-Stokes方程式の状態を表すクラス

    速度場、圧力場、レベルセット場などの物理量を保持します。
    """

    velocity: VectorField
    pressure: ScalarField
    levelset: Optional[LevelSetField] = None
    properties: Optional[LevelSetPropertiesManager] = None
    time: float = 0.0

    def copy(self) -> "NavierStokesState":
        """状態の深いコピーを作成"""
        return NavierStokesState(
            velocity=self.velocity.copy(),
            pressure=self.pressure.copy(),
            levelset=self.levelset.copy() if self.levelset is not None else None,
            properties=self.properties,  # PropertiesManagerは共有して問題ない
            time=self.time,
        )

    def get_diagnostics(self) -> Dict[str, Any]:
        """状態の診断情報を取得"""
        diag = {
            "time": self.time,
            "velocity": {
                "max": float(
                    max(np.max(np.abs(c.data)) for c in self.velocity.components)
                ),
                "energy": float(
                    sum(np.sum(c.data**2) for c in self.velocity.components)
                    * 0.5
                    * self.velocity.dx**3
                ),
            },
            "pressure": {
                "min": float(np.min(self.pressure.data)),
                "max": float(np.max(self.pressure.data)),
            },
        }

        if self.levelset is not None:
            diag["levelset"] = self.levelset.get_diagnostics()

        return diag

    def save_state(self) -> Dict[str, Any]:
        """状態を保存用の辞書として取得"""
        state_dict = {
            "velocity": self.velocity.save_state(),
            "pressure": self.pressure.save_state(),
            "time": self.time,
        }

        if self.levelset is not None:
            state_dict["levelset"] = self.levelset.save_state()

        return state_dict

    @classmethod
    def load_state(
        cls,
        state_dict: Dict[str, Any],
        shape: tuple,
        dx: float,
        properties: Optional[LevelSetPropertiesManager] = None,
    ) -> "NavierStokesState":
        """保存された状態から復元

        Args:
            state_dict: 保存された状態の辞書
            shape: グリッドの形状
            dx: グリッド間隔
            properties: 物性値マネージャー（オプション）

        Returns:
            復元された状態
        """
        # 速度場の復元
        velocity = VectorField(shape, dx)
        velocity.load_state(state_dict["velocity"])

        # 圧力場の復元
        pressure = ScalarField(shape, dx)
        pressure.load_state(state_dict["pressure"])

        # レベルセット場の復元（存在する場合）
        levelset = None
        if "levelset" in state_dict:
            levelset = LevelSetField(shape, dx)
            levelset.load_state(state_dict["levelset"])

        return cls(
            velocity=velocity,
            pressure=pressure,
            levelset=levelset,
            properties=properties,
            time=float(state_dict["time"]),
        )

    def validate(self) -> bool:
        """状態の妥当性を検証

        Returns:
            状態が有効であればTrue
        """
        # 基本的な形状の一貫性チェック
        shape = self.velocity.shape
        if self.pressure.shape != shape:
            return False
        if self.levelset is not None and self.levelset.shape != shape:
            return False

        # グリッド間隔の一貫性チェック
        dx = self.velocity.dx
        if abs(self.pressure.dx - dx) > 1e-10:
            return False
        if self.levelset is not None and abs(self.levelset.dx - dx) > 1e-10:
            return False

        # 物理的な妥当性チェック
        if np.any(np.isnan(self.pressure.data)) or np.any(np.isinf(self.pressure.data)):
            return False
        for comp in self.velocity.components:
            if np.any(np.isnan(comp.data)) or np.any(np.isinf(comp.data)):
                return False

        return True

    def __str__(self) -> str:
        """文字列表現"""
        diag = self.get_diagnostics()
        return (
            f"NavierStokesState at t={self.time:.3f}:\n"
            f"  Velocity: max={diag['velocity']['max']:.3e}, "
            f"energy={diag['velocity']['energy']:.3e}\n"
            f"  Pressure: [{diag['pressure']['min']:.3e}, "
            f"{diag['pressure']['max']:.3e}]"
        )

```

### physics/navier_stokes/terms/force.py

```
"""Navier-Stokes方程式の外力項を実装するモジュール

このモジュールは、重力、浮力、表面張力などの外力の効果を実装します。
"""

from typing import List, Dict, Any, Optional, Protocol
import numpy as np

from core.field import VectorField
from physics.levelset import LevelSetField, LevelSetPropertiesManager
from .base import TermBase


class ForceComponent(Protocol):
    """外力成分のインターフェース"""

    @property
    def name(self) -> str:
        """外力の名前"""
        ...

    @property
    def enabled(self) -> bool:
        """外力が有効かどうか"""
        ...

    def compute(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> List[np.ndarray]:
        """外力の寄与を計算"""
        ...

    def get_diagnostics(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> Dict[str, Any]:
        """診断情報を取得"""
        ...


class GravityForce:
    """重力項クラス"""

    def __init__(self, gravity: float = 9.81, direction: int = -1):
        """重力項を初期化

        Args:
            gravity: 重力加速度
            direction: 重力方向の軸インデックス（負値は逆方向）
        """
        self._name = "Gravity"
        self._enabled = True
        self.gravity = gravity
        self.direction = direction

    @property
    def name(self) -> str:
        """外力の名前を取得"""
        return self._name

    @property
    def enabled(self) -> bool:
        """外力が有効かどうかを取得"""
        return self._enabled

    @enabled.setter
    def enabled(self, value: bool):
        """外力の有効/無効を設定"""
        self._enabled = value

    def compute(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> List[np.ndarray]:
        """重力項の寄与を計算"""
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        result = [np.zeros_like(v.data) for v in velocity.components]
        axis = abs(self.direction) % velocity.ndim
        sign = -1 if self.direction < 0 else 1

        # 浮力効果の計算
        if levelset is not None and properties is not None:
            # 密度場とリファレンス密度を取得
            density = np.array(properties.get_density(levelset))
            rho_ref = properties.get_reference_density()

            if rho_ref is not None and rho_ref > 0:
                # 浮力の計算 (ρ/ρref - 1) * g
                result[axis] = sign * self.gravity * (density / rho_ref - 1.0)
        else:
            # 単純な重力加速度
            result[axis] = sign * self.gravity

        return result

    def get_diagnostics(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "type": "gravity",
            "gravity": self.gravity,
            "direction": self.direction,
            "reference_density": (
                properties.get_reference_density() if properties else None
            ),
        }


class SurfaceTensionForce:
    """表面張力項クラス"""

    def __init__(self, surface_tension: float = 0.07):
        """表面張力項を初期化

        Args:
            surface_tension: 表面張力係数（N/m）
        """
        self._name = "SurfaceTension"
        self._enabled = True
        self.surface_tension = surface_tension

    @property
    def name(self) -> str:
        """外力の名前を取得"""
        return self._name

    @property
    def enabled(self) -> bool:
        """外力が有効かどうかを取得"""
        return self._enabled

    @enabled.setter
    def enabled(self, value: bool):
        """外力の有効/無効を設定"""
        self._enabled = value

    def compute(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> List[np.ndarray]:
        """表面張力項の寄与を計算"""
        if not self.enabled or levelset is None:
            return [np.zeros_like(v.data) for v in velocity.components]

        # 表面張力係数の取得
        sigma = (
            properties.get_surface_tension_coefficient()
            if properties is not None
            else self.surface_tension
        )

        if sigma == 0:
            return [np.zeros_like(v.data) for v in velocity.components]

        # 界面の法線と曲率を計算
        kappa = levelset.curvature()
        delta = levelset.delta()

        # 表面力の計算（符号付き距離関数の勾配方向）
        result = [np.zeros_like(v.data) for v in velocity.components]

        # 界面の法線方向ベクトルを計算
        grad_norm = 1e-10  # 分母ゼロ防止
        for i in range(velocity.ndim):
            grad_phi = levelset.gradient(i)
            grad_norm += grad_phi**2
        grad_norm = np.sqrt(grad_norm)

        # 表面力を法線方向に分配
        force = sigma * kappa * delta
        for i in range(velocity.ndim):
            grad_phi = levelset.gradient(i)
            result[i] = force * grad_phi / grad_norm

        return result

    def get_diagnostics(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> Dict[str, Any]:
        """診断情報を取得"""
        diag = {
            "type": "surface_tension",
            "coefficient": self.surface_tension,
        }

        if levelset is not None:
            kappa = levelset.curvature()
            diag.update(
                {
                    "max_curvature": float(np.max(np.abs(kappa))),
                    "interface_length": float(np.sum(levelset.delta()))
                    * velocity.dx**velocity.ndim,
                }
            )

        return diag


class ForceTerm(TermBase):
    """外力項クラス"""

    def __init__(
        self,
        forces: Optional[List[ForceComponent]] = None,
        name: str = "Force",
        enabled: bool = True,
        logger=None,
    ):
        """外力項を初期化"""
        super().__init__(name=name, enabled=enabled, logger=logger)
        self.forces = forces or []

    def compute(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> List[np.ndarray]:
        """外力項の寄与を計算"""
        if not self.enabled or not self.forces:
            return [np.zeros_like(v.data) for v in velocity.components]

        # 各外力の寄与を合計
        result = [np.zeros_like(v.data) for v in velocity.components]
        self._forces_contributions = []  # 診断用に各力の寄与を保存

        for force in self.forces:
            if force.enabled:
                force_contribution = force.compute(
                    velocity, levelset, properties, **kwargs
                )
                self._forces_contributions.append(
                    {
                        "name": force.name,
                        "contribution": force_contribution,
                    }
                )
                for i in range(len(result)):
                    result[i] += force_contribution[i]

        # 診断情報の更新
        self._update_force_diagnostics(velocity, levelset, properties)

        return result

    def _update_force_diagnostics(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
    ):
        """外力の診断情報を更新"""
        # 総力の大きさを計算
        total_force = 0.0
        force_ratios = {}

        for force_info in self._forces_contributions:
            force_mag = sum(np.sum(np.abs(f)) for f in force_info["contribution"])
            total_force += force_mag
            force_ratios[force_info["name"]] = force_mag

        # 相対的な寄与を計算
        if total_force > 0:
            for name, mag in force_ratios.items():
                force_ratios[name] = float(mag / total_force)

        # 診断情報を更新
        self._diagnostics.update(
            {
                "total_force": float(total_force),
                "force_ratios": force_ratios,
                "enabled_forces": len([f for f in self.forces if f.enabled]),
            }
        )

    def get_diagnostics(self) -> Dict[str, Any]:
        """項の診断情報を取得"""
        diag = super().get_diagnostics()

        # 各力の個別の診断情報を収集
        forces_diag = {}
        for force in self.forces:
            if force.enabled:
                forces_diag[force.name] = {
                    "ratio": self._diagnostics.get("force_ratios", {}).get(
                        force.name, 0.0
                    ),
                }

        diag.update(
            {
                "forces": forces_diag,
                "total_force": self._diagnostics.get("total_force", 0.0),
                "enabled_forces": self._diagnostics.get("enabled_forces", 0),
            }
        )

        return diag

    def add_force(self, force: ForceComponent):
        """外力を追加"""
        self.forces.append(force)

    def remove_force(self, force_name: str):
        """外力を削除"""
        self.forces = [f for f in self.forces if f.name != force_name]

    def get_force(self, force_name: str) -> Optional[ForceComponent]:
        """指定された名前の外力を取得"""
        for force in self.forces:
            if force.name == force_name:
                return force
        return None

```

### physics/navier_stokes/terms/base.py

```
"""Navier-Stokes方程式の各項の基底クラスを提供

このモジュールは、Navier-Stokes方程式の各項（移流項、粘性項など）の
基底となる抽象クラスを提供します。
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any
import numpy as np

from core.field import VectorField
from physics.levelset import LevelSetField, LevelSetPropertiesManager
from ..core.interfaces import NavierStokesTerm


class TermBase(NavierStokesTerm, ABC):
    """Navier-Stokes方程式の項の基底クラス"""

    def __init__(self, name: str, enabled: bool = True, logger=None):
        """基底クラスを初期化

        Args:
            name: 項の名前
            enabled: 項を有効にするかどうか
            logger: ロガー
        """
        self._name = name
        self._enabled = enabled
        self.logger = logger

        # 診断情報の初期化
        self._diagnostics: Dict[str, Any] = {}

    @property
    def name(self) -> str:
        """項の名前を取得"""
        return self._name

    @property
    def enabled(self) -> bool:
        """項が有効かどうかを取得"""
        return self._enabled

    @enabled.setter
    def enabled(self, value: bool):
        """項の有効/無効を設定"""
        self._enabled = value

    @abstractmethod
    def compute(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> List[np.ndarray]:
        """項の寄与を計算

        Args:
            velocity: 速度場
            levelset: レベルセット場
            properties: 物性値マネージャー
            **kwargs: 追加のパラメータ

        Returns:
            各方向の速度成分への寄与のリスト
        """
        pass

    def compute_timestep(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> float:
        """項に基づく時間刻み幅の制限を計算

        Args:
            velocity: 速度場
            levelset: レベルセット場
            properties: 物性値マネージャー
            **kwargs: 追加のパラメータ

        Returns:
            計算された時間刻み幅の制限（制限なしの場合はfloat('inf')）
        """
        return float("inf")

    def get_diagnostics(self) -> Dict[str, Any]:
        """項の診断情報を取得"""
        return {
            "name": self.name,
            "enabled": self.enabled,
            **self._diagnostics,
        }

    def log(self, level: str, msg: str):
        """ログを出力"""
        if self.logger:
            log_method = getattr(self.logger, level, None)
            if log_method:
                log_method(msg)

    def _update_diagnostics(self, key: str, value: Any):
        """診断情報を更新"""
        self._diagnostics[key] = value


class ViscousTerm(TermBase, ABC):
    """粘性に関連する項の基底クラス"""

    def compute_timestep(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> float:
        """粘性による時間刻み幅の制限を計算

        dx² / (2ν) の形式の制限を実装
        """
        if not self.enabled:
            return float("inf")

        # 動粘性係数の最大値を取得
        nu = properties.get_kinematic_viscosity(levelset)
        nu_max = np.max(nu)

        # 安定性条件に基づく時間刻み幅の制限
        dx = velocity.dx
        return 0.5 * dx**2 / (nu_max + 1e-10)  # ゼロ除算防止


class AdvectiveTerm(TermBase, ABC):
    """移流に関連する項の基底クラス"""

    def compute_timestep(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> float:
        """移流による時間刻み幅の制限を計算

        CFL条件に基づく制限を実装
        """
        if not self.enabled:
            return float("inf")

        # 速度の最大値を計算
        max_velocity = max(np.max(np.abs(comp.data)) for comp in velocity.components)

        # CFL条件に基づく時間刻み幅の制限
        cfl = kwargs.get("cfl", 0.5)  # デフォルトのCFL数
        dx = velocity.dx
        return cfl * dx / (max_velocity + 1e-10)  # ゼロ除算防止

```

### physics/navier_stokes/terms/advection.py

```
"""移流項を実装するモジュール

このモジュールは、Navier-Stokes方程式の移流項 (u・∇)u を実装します。
WENOスキームによる高精度な空間離散化を提供します。
"""

from typing import List, Dict, Any
import numpy as np

from core.field import VectorField
from physics.levelset import LevelSetField, LevelSetPropertiesManager
from .base import AdvectiveTerm


class AdvectionTerm(AdvectiveTerm):
    """移流項クラス

    WENOスキームを用いた高精度な移流項の計算を提供します。
    """

    def __init__(
        self,
        use_weno: bool = True,
        weno_order: int = 5,
        name: str = "Advection",
        enabled: bool = True,
        logger=None,
    ):
        """移流項を初期化

        Args:
            use_weno: WENOスキームを使用するかどうか
            weno_order: WENOスキームの次数（3または5）
            name: 項の名前
            enabled: 項を有効にするかどうか
            logger: ロガー
        """
        super().__init__(name=name, enabled=enabled, logger=logger)
        self.use_weno = use_weno
        self.weno_order = weno_order

        # WENOスキームの係数を初期化
        if use_weno:
            self._init_weno_coefficients()

    def _init_weno_coefficients(self):
        """WENOスキームの係数を初期化"""
        # WENO5の場合の係数
        if self.weno_order == 5:
            # 線形重み
            self.weno_weights = np.array([0.1, 0.6, 0.3])

            # 各ステンシルでの係数
            self.weno_coeffs = [
                np.array([1 / 3, -7 / 6, 11 / 6]),  # 左側ステンシル
                np.array([-1 / 6, 5 / 6, 1 / 3]),  # 中央ステンシル
                np.array([1 / 3, 5 / 6, -1 / 6]),  # 右側ステンシル
            ]

        # WENO3の場合の係数
        elif self.weno_order == 3:
            self.weno_weights = np.array([1 / 3, 2 / 3])
            self.weno_coeffs = [
                np.array([-1 / 2, 3 / 2]),  # 左側ステンシル
                np.array([1 / 2, 1 / 2]),  # 右側ステンシル
            ]
        else:
            raise ValueError(f"未対応のWENO次数です: {self.weno_order}")

    def compute(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> List[np.ndarray]:
        """移流項の寄与を計算

        Args:
            velocity: 速度場
            levelset: レベルセット場
            properties: 物性値マネージャー
            **kwargs: 追加のパラメータ

        Returns:
            各方向の速度成分への寄与のリスト
        """
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        result = []

        if self.use_weno:
            # WENOスキームによる空間離散化
            for i, v_i in enumerate(velocity.components):
                flux = np.zeros_like(v_i.data)
                for j, v_j in enumerate(velocity.components):
                    # 風上差分の方向を決定
                    upwind = v_j.data < 0

                    # 正の速度に対する flux
                    v_plus = self._weno_reconstruction(v_i.data, j)
                    # 負の速度に対する flux
                    v_minus = self._weno_reconstruction(np.flip(v_i.data, j), j)
                    v_minus = np.flip(v_minus, j)

                    # 風上方向に応じてfluxを選択
                    flux += v_j.data * np.where(upwind, v_minus, v_plus)

                result.append(-flux)

        else:
            # 標準的な中心差分
            for i, v_i in enumerate(velocity.components):
                result.append(
                    -sum(
                        v_j.data * v_i.gradient(j)
                        for j, v_j in enumerate(velocity.components)
                    )
                )

        # 診断情報の更新
        self._update_diagnostics(
            "flux_max", float(max(np.max(np.abs(f)) for f in result))
        )
        self._update_diagnostics("scheme", "WENO" if self.use_weno else "central")
        self._update_diagnostics(
            "weno_order", self.weno_order if self.use_weno else None
        )

        return result

    def _weno_reconstruction(self, values: np.ndarray, axis: int) -> np.ndarray:
        """WENOスキームによる再構築

        Args:
            values: 再構築する値の配列
            axis: 再構築を行う軸

        Returns:
            再構築された値
        """
        # シフトしたインデックスでの値を取得
        if self.weno_order == 5:
            v1 = np.roll(values, 2, axis=axis)
            v2 = np.roll(values, 1, axis=axis)
            v3 = values
            v4 = np.roll(values, -1, axis=axis)
            v5 = np.roll(values, -2, axis=axis)

            # 各ステンシルでの滑らかさ指標を計算
            eps = 1e-6  # ゼロ除算防止用
            beta0 = (
                13 / 12 * (v1 - 2 * v2 + v3) ** 2 + 1 / 4 * (v1 - 4 * v2 + 3 * v3) ** 2
            )
            beta1 = 13 / 12 * (v2 - 2 * v3 + v4) ** 2 + 1 / 4 * (v2 - v4) ** 2
            beta2 = (
                13 / 12 * (v3 - 2 * v4 + v5) ** 2 + 1 / 4 * (3 * v3 - 4 * v4 + v5) ** 2
            )

            # 非線形重みを計算（ブロードキャストを考慮）
            weights = self.weno_weights.reshape((-1,) + (1,) * values.ndim)
            alpha0 = weights[0] / (eps + beta0) ** 2
            alpha1 = weights[1] / (eps + beta1) ** 2
            alpha2 = weights[2] / (eps + beta2) ** 2
            alpha_sum = alpha0 + alpha1 + alpha2

            omega0 = alpha0 / alpha_sum
            omega1 = alpha1 / alpha_sum
            omega2 = alpha2 / alpha_sum

            # 各ステンシルでの補間値を計算
            p0 = (
                self.weno_coeffs[0][0] * v1
                + self.weno_coeffs[0][1] * v2
                + self.weno_coeffs[0][2] * v3
            )
            p1 = (
                self.weno_coeffs[1][0] * v2
                + self.weno_coeffs[1][1] * v3
                + self.weno_coeffs[1][2] * v4
            )
            p2 = (
                self.weno_coeffs[2][0] * v3
                + self.weno_coeffs[2][1] * v4
                + self.weno_coeffs[2][2] * v5
            )

            return omega0 * p0 + omega1 * p1 + omega2 * p2

        else:  # WENO3
            v1 = np.roll(values, 1, axis=axis)
            v2 = values
            v3 = np.roll(values, -1, axis=axis)

            beta0 = (v2 - v1) ** 2
            beta1 = (v3 - v2) ** 2

            eps = 1e-6
            weights = self.weno_weights.reshape((-1,) + (1,) * values.ndim)
            alpha0 = weights[0] / (eps + beta0) ** 2
            alpha1 = weights[1] / (eps + beta1) ** 2
            alpha_sum = alpha0 + alpha1

            omega0 = alpha0 / alpha_sum
            omega1 = alpha1 / alpha_sum

            p0 = self.weno_coeffs[0][0] * v1 + self.weno_coeffs[0][1] * v2
            p1 = self.weno_coeffs[1][0] * v2 + self.weno_coeffs[1][1] * v3

            return omega0 * p0 + omega1 * p1

    def get_diagnostics(self) -> Dict[str, Any]:
        """項の診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "flux_norm": float(
                    np.sqrt(
                        sum(np.sum(f**2) for f in self._diagnostics.get("flux", []))
                    )
                ),
                "weno": {
                    "enabled": self.use_weno,
                    "order": self.weno_order if self.use_weno else None,
                },
            }
        )
        return diag

```

### physics/navier_stokes/terms/diffusion.py

```
"""粘性項を実装するモジュール

このモジュールは、Navier-Stokes方程式の粘性項 ∇・(ν∇u) を実装します。
保存形式と非保存形式の両方の離散化を提供します。
"""

from typing import List, Dict, Any
import numpy as np

from core.field import VectorField
from physics.levelset import LevelSetField, LevelSetPropertiesManager
from .base import ViscousTerm


class DiffusionTerm(ViscousTerm):
    """粘性項クラス

    粘性による運動量の拡散を計算します。保存形式と非保存形式の
    両方の離散化をサポートします。
    """

    def __init__(
        self,
        use_conservative: bool = True,
        name: str = "Diffusion",
        enabled: bool = True,
        logger=None,
    ):
        """粘性項を初期化

        Args:
            use_conservative: 保存形式で離散化するかどうか
            name: 項の名前
            enabled: 項を有効にするかどうか
            logger: ロガー
        """
        super().__init__(name=name, enabled=enabled, logger=logger)
        self.use_conservative = use_conservative

    def compute(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> List[np.ndarray]:
        """粘性項の寄与を計算

        Args:
            velocity: 速度場
            levelset: レベルセット場
            properties: 物性値マネージャー
            **kwargs: 追加のパラメータ

        Returns:
            各方向の速度成分への寄与のリスト
        """
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        # 粘性係数と密度の取得
        viscosity = properties.get_viscosity(levelset).data
        density = properties.get_density(levelset).data

        dx = velocity.dx
        result = []

        if self.use_conservative:
            # 保存形式での離散化
            # ∇・(μ∇u)の形式で計算
            for i, v_i in enumerate(velocity.components):
                # 変形速度テンソルの対角成分
                laplacian = np.zeros_like(v_i.data)

                # ∇・(μ∇u)の計算
                for j in range(velocity.ndim):
                    # ∂/∂xj(μ ∂ui/∂xj)
                    dui_dxj = np.gradient(v_i.data, dx, axis=j)
                    flux = viscosity * dui_dxj
                    laplacian += np.gradient(flux, dx, axis=j)

                # 密度で割って加速度に変換
                result.append(laplacian / density)

        else:
            # 非保存形式での離散化
            # ν∇²uの形式で計算
            kinematic_viscosity = viscosity / density

            for i, v_i in enumerate(velocity.components):
                # 速度のラプラシアン
                laplacian = sum(
                    np.gradient(np.gradient(v_i.data, dx, axis=j), dx, axis=j)
                    for j in range(velocity.ndim)
                )

                # 粘性による加速度
                result.append(kinematic_viscosity * laplacian)

        # 診断情報の更新
        total_dissipation = sum(
            np.sum(viscosity * self._compute_strain_rate_squared(velocity))
        )
        max_diffusion = max(np.max(np.abs(r)) for r in result)

        self._update_diagnostics("dissipation_rate", float(total_dissipation))
        self._update_diagnostics("max_diffusion", float(max_diffusion))
        self._update_diagnostics(
            "formulation",
            "conservative" if self.use_conservative else "non-conservative",
        )

        return result

    def _compute_strain_rate_squared(self, velocity: VectorField) -> np.ndarray:
        """変形速度テンソルの二乗ノルムを計算

        Args:
            velocity: 速度場

        Returns:
            変形速度テンソルの二乗ノルム |D|²
        """
        dx = velocity.dx
        result = np.zeros_like(velocity.components[0].data)

        # 対角成分の寄与
        for i, v_i in enumerate(velocity.components):
            dui_dxi = np.gradient(v_i.data, dx, axis=i)
            result += dui_dxi**2

        # 非対角成分の寄与
        for i in range(velocity.ndim):
            for j in range(i + 1, velocity.ndim):
                dui_dxj = np.gradient(velocity.components[i].data, dx, axis=j)
                duj_dxi = np.gradient(velocity.components[j].data, dx, axis=i)
                result += 0.5 * ((dui_dxj + duj_dxi) ** 2)

        return result

    def get_diagnostics(self) -> Dict[str, Any]:
        """項の診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "formulation": "conservative"
                if self.use_conservative
                else "non-conservative",
                "dissipation": {
                    "rate": self._diagnostics.get("dissipation_rate", 0.0),
                    "max": self._diagnostics.get("max_diffusion", 0.0),
                },
            }
        )
        return diag

```

### physics/navier_stokes/terms/__init__.py

```
"""Navier-Stokes方程式の各項を提供するパッケージ

このパッケージは、Navier-Stokes方程式を構成する各項（移流項、粘性項、圧力項、外力項）
を実装したクラスを提供します。
"""

from .base import TermBase, ViscousTerm, AdvectiveTerm
from .advection import AdvectionTerm
from .diffusion import DiffusionTerm
from .pressure import PressureTerm
from .force import (
    ForceComponent,
    GravityForce,
    SurfaceTensionForce,
    ForceTerm,
)

__all__ = [
    # 基底クラス
    "TermBase",
    "ViscousTerm",
    "AdvectiveTerm",
    # 具体的な項の実装
    "AdvectionTerm",
    "DiffusionTerm",
    "PressureTerm",
    # 外力関連
    "ForceComponent",
    "GravityForce",
    "SurfaceTensionForce",
    "ForceTerm",
]

```

### physics/navier_stokes/terms/pressure.py

```
"""圧力項を実装するモジュール

このモジュールは、Navier-Stokes方程式の圧力項を実装します。
圧力勾配項を適切に計算し、密度の不連続性も考慮します。
"""

from typing import List, Dict, Any
import numpy as np

from core.field import VectorField, ScalarField
from physics.levelset import LevelSetField, LevelSetPropertiesManager
from .base import TermBase


class PressureTerm(TermBase):
    """圧力項クラス"""

    def __init__(
        self,
        use_conservative: bool = True,
        name: str = "Pressure",
        enabled: bool = True,
        logger=None,
    ):
        """圧力項を初期化

        Args:
            use_conservative: 保存形式で離散化するかどうか
            name: 項の名前
            enabled: 項を有効にするかどうか
            logger: ロガー
        """
        super().__init__(name=name, enabled=enabled, logger=logger)
        self.use_conservative = use_conservative

    def compute(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> List[np.ndarray]:
        """圧力項の寄与を計算

        Args:
            velocity: 速度場
            levelset: レベルセット場
            properties: 物性値マネージャー
            **kwargs: 追加のパラメータ
                - pressure: 圧力場（必須）

        Returns:
            各方向の速度成分への寄与のリスト
        """
        if not self.enabled:
            return [np.zeros_like(v.data) for v in velocity.components]

        # 圧力場の取得
        pressure = kwargs.get("pressure")
        if pressure is None:
            raise ValueError("圧力場が指定されていません")
        if not isinstance(pressure, ScalarField):
            raise TypeError("pressureはScalarField型である必要があります")

        # 密度場の取得
        density = properties.get_density(levelset).data

        if self.use_conservative:
            # 保存形式での離散化
            # ∇・(p/ρ I)の形式で計算
            result = self._compute_conservative(pressure, density, velocity.dx)
        else:
            # 非保存形式での離散化
            # (1/ρ)∇pの形式で計算
            result = self._compute_non_conservative(pressure, density, velocity.dx)

        # 診断情報の更新
        self._update_diagnostics(pressure, density, result)

        return result

    def _compute_conservative(
        self, pressure: ScalarField, density: np.ndarray, dx: float
    ) -> List[np.ndarray]:
        """保存形式での圧力項の計算"""
        result = []

        for i in range(pressure.ndim):
            # 圧力/密度の勾配を計算
            p_over_rho = pressure.data / density
            grad_p_rho = np.gradient(p_over_rho, dx, axis=i)

            # 負の勾配を取る（運動方程式の右辺項として）
            result.append(-grad_p_rho)

        return result

    def _compute_non_conservative(
        self, pressure: ScalarField, density: np.ndarray, dx: float
    ) -> List[np.ndarray]:
        """非保存形式での圧力項の計算"""
        result = []

        for i in range(pressure.ndim):
            # 圧力勾配を計算
            grad_p = np.gradient(pressure.data, dx, axis=i)

            # 密度で割って加速度に変換
            result.append(-grad_p / density)

        return result

    def _update_diagnostics(
        self,
        pressure: ScalarField,
        density: np.ndarray,
        contributions: List[np.ndarray],
    ):
        """診断情報を更新"""
        # 圧力勾配の大きさを計算
        grad_p_mag = np.sqrt(sum(np.sum(c**2) for c in contributions))

        # 圧力仕事を計算
        pressure_work = np.sum(pressure.data * np.sum(contributions))

        # 診断情報を更新
        self._diagnostics.update(
            {
                "formulation": "conservative"
                if self.use_conservative
                else "non-conservative",
                "pressure": {
                    "min": float(np.min(pressure.data)),
                    "max": float(np.max(pressure.data)),
                    "mean": float(np.mean(pressure.data)),
                    "gradient_magnitude": float(grad_p_mag),
                },
                "work": float(pressure_work),
            }
        )

    def get_diagnostics(self) -> Dict[str, Any]:
        """項の診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "formulation": "conservative"
                if self.use_conservative
                else "non-conservative",
                "pressure": self._diagnostics.get("pressure", {}),
                "work": self._diagnostics.get("work", 0.0),
            }
        )
        return diag

    def compute_timestep(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> float:
        """圧力項に基づく時間刻み幅の制限を計算

        音速に基づくCFL条件を実装。
        ただし、非圧縮性流れでは通常この制限は使用しない。
        """
        if not self.enabled:
            return float("inf")

        # 圧力場の取得
        pressure = kwargs.get("pressure")
        if pressure is None:
            return float("inf")

        # 音速の見積もり（非圧縮性近似のため、大きな値を使用）
        density = properties.get_density(levelset)
        c = np.sqrt(np.max(pressure.data) / np.min(density.data))

        # CFL条件に基づく時間刻み幅の制限
        dx = velocity.dx
        return 0.5 * dx / c

```

### physics/navier_stokes/utils/time_integration.py

```
"""時間積分スキームを提供するモジュール

このモジュールは、Navier-Stokes方程式の時間積分に使用される
様々な時間積分スキームを実装します。
"""

from typing import Any, Callable, List

from ..core.interfaces import TimeIntegrator


class ForwardEuler(TimeIntegrator):
    """前進Euler法による時間積分"""

    def step(
        self,
        state: Any,
        dt: float,
        compute_derivative: Callable[[Any, float], Any],
        **kwargs,
    ) -> Any:
        """1時間ステップを実行

        Args:
            state: 現在の状態
            dt: 時間刻み幅
            compute_derivative: 時間微分を計算する関数
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        derivative = compute_derivative(state, **kwargs)
        return state + dt * derivative


class RungeKutta4(TimeIntegrator):
    """4次のRunge-Kutta法による時間積分"""

    def step(
        self,
        state: Any,
        dt: float,
        compute_derivative: Callable[[Any, float], Any],
        **kwargs,
    ) -> Any:
        """1時間ステップを実行

        Args:
            state: 現在の状態
            dt: 時間刻み幅
            compute_derivative: 時間微分を計算する関数
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        # k1の計算
        k1 = compute_derivative(state, **kwargs)

        # k2の計算
        state_k2 = state + 0.5 * dt * k1
        k2 = compute_derivative(state_k2, **kwargs)

        # k3の計算
        state_k3 = state + 0.5 * dt * k2
        k3 = compute_derivative(state_k3, **kwargs)

        # k4の計算
        state_k4 = state + dt * k3
        k4 = compute_derivative(state_k4, **kwargs)

        # 最終的な更新
        return state + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)


class AdamsBashforth(TimeIntegrator):
    """Adams-Bashforth法による時間積分

    2次または3次のAdams-Bashforth法を実装します。
    過去の時間微分を保存して使用します。
    """

    def __init__(self, order: int = 2):
        """Adams-Bashforth法を初期化

        Args:
            order: スキームの次数（2または3）
        """
        if order not in [2, 3]:
            raise ValueError("次数は2または3である必要があります")

        self.order = order
        self._previous_derivatives: List[Any] = []

    def step(
        self,
        state: Any,
        dt: float,
        compute_derivative: Callable[[Any, float], Any],
        **kwargs,
    ) -> Any:
        """1時間ステップを実行

        Args:
            state: 現在の状態
            dt: 時間刻み幅
            compute_derivative: 時間微分を計算する関数
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        # 現在の時間微分を計算
        current_derivative = compute_derivative(state, **kwargs)

        # 過去の微分が不足している場合は前進Euler法を使用
        if len(self._previous_derivatives) < self.order - 1:
            self._previous_derivatives.append(current_derivative)
            return state + dt * current_derivative

        # Adams-Bashforth法の係数
        if self.order == 2:
            coeffs = [3 / 2, -1 / 2]  # 2次のAB法の係数
        else:  # order == 3
            coeffs = [23 / 12, -16 / 12, 5 / 12]  # 3次のAB法の係数

        # 時間発展の計算
        derivatives = [current_derivative] + self._previous_derivatives
        result = state + dt * sum(
            c * d for c, d in zip(coeffs, derivatives[: self.order])
        )

        # 過去の微分を更新
        self._previous_derivatives = [current_derivative] + self._previous_derivatives[
            :-1
        ]

        return result

    def reset(self):
        """積分器の状態をリセット"""
        self._previous_derivatives = []


def create_integrator(integrator_type: str, **kwargs) -> TimeIntegrator:
    """時間積分器を生成

    Args:
        integrator_type: 積分器の種類（"euler", "rk4", "ab2", "ab3"）
        **kwargs: 積分器固有のパラメータ

    Returns:
        生成された時間積分器

    Raises:
        ValueError: 未対応の積分器が指定された場合
    """
    integrators = {
        "euler": ForwardEuler,
        "rk4": RungeKutta4,
        "ab2": lambda: AdamsBashforth(order=2),
        "ab3": lambda: AdamsBashforth(order=3),
    }

    if integrator_type not in integrators:
        raise ValueError(f"未対応の積分器です: {integrator_type}")

    return integrators[integrator_type](**kwargs)

```

### physics/navier_stokes/utils/__init__.py

```
"""Navier-Stokes方程式の解法に関するユーティリティパッケージ

このパッケージは、Navier-Stokes方程式の数値解法に必要な
時間積分スキームや圧力投影法などのユーティリティを提供します。
"""

from .time_integration import (
    ForwardEuler,
    RungeKutta4,
    AdamsBashforth,
    create_integrator,
)
from .projection import (
    ClassicProjection,
    RotationalProjection,
)

__all__ = [
    # 時間積分スキーム
    "ForwardEuler",
    "RungeKutta4",
    "AdamsBashforth",
    "create_integrator",
    # 圧力投影法
    "ClassicProjection",
    "RotationalProjection",
]

```

### physics/navier_stokes/utils/projection.py

```
"""圧力投影法を提供するモジュール

このモジュールは、非圧縮性Navier-Stokes方程式のための圧力投影法を実装します。
古典的な投影法と回転形式の投影法の両方を提供します。
"""

from typing import Optional, Tuple
import numpy as np

from core.field import VectorField, ScalarField
from physics.levelset import LevelSetField, LevelSetPropertiesManager
from physics.poisson import PoissonSolver
from ..core.interfaces import PressureProjection


class ClassicProjection(PressureProjection):
    """古典的な圧力投影法

    Chorin (1968) による古典的な投影法を実装します。
    投影によって離散的な非圧縮性を厳密に満たします。
    """

    def __init__(self, poisson_solver: PoissonSolver):
        """古典的な投影法を初期化

        Args:
            poisson_solver: 圧力ポアソンソルバー
        """
        self.poisson_solver = poisson_solver

    def project(
        self,
        velocity: VectorField,
        pressure: ScalarField,
        dt: float,
        levelset: Optional[LevelSetField] = None,
        properties: Optional[LevelSetPropertiesManager] = None,
    ) -> Tuple[VectorField, ScalarField]:
        """速度場を非圧縮に投影

        Args:
            velocity: 速度場
            pressure: 圧力場
            dt: 時間刻み幅
            levelset: レベルセット場（オプション）
            properties: 物性値マネージャー（オプション）

        Returns:
            (投影された速度場, 更新された圧力場)のタプル
        """
        # 密度場の取得
        density = (
            properties.get_density(levelset).data
            if properties and levelset
            else np.ones_like(velocity.components[0].data)
        )

        # 発散の計算
        div = velocity.divergence()

        # ポアソン方程式の右辺を設定
        rhs = -div / dt

        # 圧力補正値の計算
        p_corr = ScalarField(velocity.shape, velocity.dx)
        p_corr.data = self.poisson_solver.solve(
            initial_solution=np.zeros_like(pressure.data),
            rhs=rhs,
            dx=velocity.dx,
        )

        # 速度場の補正
        velocity_new = velocity.copy()
        for i, component in enumerate(velocity_new.components):
            grad_p = np.gradient(p_corr.data, velocity.dx, axis=i)
            component.data -= dt * grad_p / density

        # 圧力場の更新
        pressure_new = pressure.copy()
        pressure_new.data += p_corr.data

        return velocity_new, pressure_new


class RotationalProjection(PressureProjection):
    """回転形式の圧力投影法

    Timmermans et al. (1996) による回転形式の投影法を実装します。
    より高精度な圧力場の計算が可能です。
    """

    def __init__(self, poisson_solver: PoissonSolver, include_viscous: bool = True):
        """回転形式の投影法を初期化

        Args:
            poisson_solver: 圧力ポアソンソルバー
            include_viscous: 粘性項を含めるかどうか
        """
        self.poisson_solver = poisson_solver
        self.include_viscous = include_viscous

    def project(
        self,
        velocity: VectorField,
        pressure: ScalarField,
        dt: float,
        levelset: Optional[LevelSetField] = None,
        properties: Optional[LevelSetPropertiesManager] = None,
    ) -> Tuple[VectorField, ScalarField]:
        """速度場を非圧縮に投影

        Args:
            velocity: 速度場
            pressure: 圧力場
            dt: 時間刻み幅
            levelset: レベルセット場（オプション）
            properties: 物性値マネージャー（オプション）

        Returns:
            (投影された速度場, 更新された圧力場)のタプル
        """
        # 密度と粘性係数の取得
        if properties and levelset:
            density = properties.get_density(levelset).data
            viscosity = (
                properties.get_viscosity(levelset).data
                if self.include_viscous
                else None
            )
        else:
            density = np.ones_like(velocity.components[0].data)
            viscosity = None

        # 渦度の計算
        curl = velocity.curl()

        # 圧力を含む運動量の発散を計算
        div_momentum = velocity.divergence()
        if viscosity is not None:
            # 粘性項の寄与を追加
            for i, v_i in enumerate(velocity.components):
                momentum = density * v_i.data
                div_momentum += sum(
                    np.gradient(
                        viscosity * np.gradient(momentum, velocity.dx, axis=j),
                        velocity.dx,
                        axis=j,
                    )
                    for j in range(velocity.ndim)
                )

        # ポアソン方程式の右辺を設定
        rhs = -div_momentum / dt

        # 圧力補正値の計算
        p_corr = ScalarField(velocity.shape, velocity.dx)
        p_corr.data = self.poisson_solver.solve(
            initial_solution=np.zeros_like(pressure.data),
            rhs=rhs,
            dx=velocity.dx,
        )

        # 速度場の補正（渦度を保存）
        velocity_new = velocity.copy()
        for i, component in enumerate(velocity_new.components):
            # 圧力勾配による補正
            grad_p = np.gradient(p_corr.data, velocity.dx, axis=i)
            component.data -= dt * grad_p / density

            if viscosity is not None:
                # 粘性による補正
                component.data += (
                    dt
                    * sum(
                        np.gradient(
                            viscosity
                            * np.gradient(component.data, velocity.dx, axis=j),
                            velocity.dx,
                            axis=j,
                        )
                        for j in range(velocity.ndim)
                    )
                    / density
                )

        # 圧力場の更新
        pressure_new = pressure.copy()
        pressure_new.data += p_corr.data

        # 非圧縮性の確認
        div_final = velocity_new.divergence()
        if np.max(np.abs(div_final)) > 1e-10:
            # 追加の補正が必要な場合は再投影
            velocity_new, pressure_new = self.project(
                velocity_new, pressure_new, dt, levelset, properties
            )

        return velocity_new, pressure_new

```

### physics/navier_stokes/solvers/basic_solver.py

```
"""基本的なNavier-Stokesソルバーを提供するモジュール

このモジュールは、Navier-Stokes方程式の基本的なソルバーを実装します。
時間発展と圧力投影を組み合わせて非圧縮性流れを解きます。
"""

from typing import Dict, Any, List, Optional
import numpy as np

from core.field import VectorField, ScalarField
from physics.levelset import LevelSetField, LevelSetPropertiesManager
from physics.poisson import PoissonSolver, SORSolver
from ..core.base_solver import NavierStokesBase
from ..core.interfaces import NavierStokesTerm, TimeIntegrator
from ..utils.time_integration import RungeKutta4


class BasicNavierStokesSolver(NavierStokesBase):
    """基本的なNavier-Stokesソルバー

    時間発展と圧力投影を組み合わせて非圧縮性流れを解きます。
    """

    def __init__(
        self,
        terms: List[NavierStokesTerm],
        properties: Optional[LevelSetPropertiesManager] = None,
        time_integrator: Optional[TimeIntegrator] = None,
        poisson_solver: Optional[PoissonSolver] = None,
        logger=None,
    ):
        """ソルバーを初期化

        Args:
            terms: NS方程式の各項
            properties: 物性値マネージャー
            time_integrator: 時間積分スキーム
            poisson_solver: 圧力ポアソンソルバー
            logger: ロガー
        """
        time_integrator = time_integrator or RungeKutta4()
        super().__init__(time_integrator, terms, properties, logger)

        # 圧力ポアソンソルバーの設定
        self.poisson_solver = poisson_solver or SORSolver(
            omega=1.5,
            tolerance=1e-6,
            max_iterations=1000,
            use_redblack=True,
            auto_tune=True,
        )

    def compute_derivative(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> VectorField:
        """速度場の時間微分を計算

        Args:
            velocity: 速度場
            levelset: レベルセット場
            properties: 物性値マネージャー
            **kwargs: 追加のパラメータ

        Returns:
            計算された時間微分のVectorField
        """
        # 結果を格納するベクトル場
        result = VectorField(velocity.shape, velocity.dx)

        # 各項の寄与を計算して合計
        for term in self.terms:
            if term.enabled:
                contributions = term.compute(velocity, levelset, properties, **kwargs)
                # 各成分に寄与を加算
                for i, contribution in enumerate(contributions):
                    result.components[i].data += contribution

        return result

    def solve_pressure_poisson(
        self,
        velocity: VectorField,
        pressure: ScalarField,
        levelset: LevelSetField,
        dt: float,
    ) -> ScalarField:
        """圧力ポアソン方程式を解く

        Args:
            velocity: 速度場
            pressure: 現在の圧力場（初期推定値として使用）
            levelset: レベルセット場
            dt: 時間刻み幅

        Returns:
            更新された圧力場
        """
        # 密度場の取得
        density = self.properties.get_density(levelset).data

        # 発散の計算
        div = velocity.divergence()

        # ポアソン方程式の右辺を設定
        rhs = ScalarField(velocity.shape, velocity.dx)
        rhs.data = -div / dt

        # 圧力補正値の計算
        p_corr = ScalarField(velocity.shape, velocity.dx)
        p_corr.data = self.poisson_solver.solve(
            initial_solution=np.zeros_like(pressure.data),
            rhs=rhs.data,
            dx=velocity.dx,
        )

        # 圧力場の更新
        pressure_new = pressure.copy()
        pressure_new.data += p_corr.data

        return pressure_new

    def project_velocity(
        self,
        velocity: VectorField,
        pressure: ScalarField,
        levelset: LevelSetField,
        dt: float,
    ) -> VectorField:
        """速度場を非圧縮に投影

        Args:
            velocity: 速度場
            pressure: 圧力場
            levelset: レベルセット場
            dt: 時間刻み幅

        Returns:
            投影された速度場
        """
        # 密度場の取得
        density = self.properties.get_density(levelset).data

        # 圧力勾配による速度補正
        velocity_new = velocity.copy()
        for i, component in enumerate(velocity_new.components):
            grad_p = np.gradient(pressure.data, velocity.dx, axis=i)
            component.data -= dt * grad_p / density

        return velocity_new

    def step_forward(self, dt: float, **kwargs) -> Dict[str, Any]:
        """1時間ステップを進める

        Args:
            dt: 時間刻み幅
            **kwargs: 追加のパラメータ
                - state: 現在のシミュレーション状態

        Returns:
            計算結果と診断情報を含む辞書
        """
        state = kwargs.get("state")
        if state is None:
            raise ValueError("stateが指定されていません")

        try:
            # 1. 速度場の時間発展（圧力項を除く）
            intermediate_state = super().step_forward(dt=dt, state=state)["state"]

            # 2. 圧力ポアソン方程式を解く
            pressure_new = self.solve_pressure_poisson(
                intermediate_state.velocity,
                state.pressure,
                state.levelset,
                dt,
            )

            # 3. 速度場の投影
            velocity_new = self.project_velocity(
                intermediate_state.velocity,
                pressure_new,
                state.levelset,
                dt,
            )

            # 診断情報を収集
            diagnostics = {
                "time": self.time,
                "dt": dt,
                "max_velocity": float(
                    max(np.max(np.abs(comp.data)) for comp in velocity_new.components)
                ),
                "pressure": {
                    "min": float(np.min(pressure_new.data)),
                    "max": float(np.max(pressure_new.data)),
                },
                "poisson_iterations": self.poisson_solver.iteration_count,
            }

            # 各項の診断情報を追加
            for term in self.terms:
                if term.enabled:
                    diagnostics[term.name] = term.get_diagnostics()

            return {
                "velocity": velocity_new,
                "pressure": pressure_new,
                "diagnostics": diagnostics,
            }

        except Exception as e:
            if self.logger:
                self.logger.error(f"NavierStokesソルバーの時間発展中にエラー: {e}")
            raise

```

### physics/navier_stokes/solvers/projection_solver.py

```
"""圧力投影法を使用したNavier-Stokesソルバーを提供するモジュール

このモジュールは、圧力投影法を使用した改良版のNavier-Stokesソルバーを実装します。
より高精度な圧力場の計算と厳密な非圧縮性の保証を提供します。
"""

from typing import Dict, Any, List, Optional, Tuple
import numpy as np

from core.field import VectorField, ScalarField
from physics.levelset import LevelSetField, LevelSetPropertiesManager
from physics.poisson import PoissonSolver, SORSolver
from ..core.base_solver import NavierStokesBase
from ..core.interfaces import NavierStokesTerm, TimeIntegrator
from ..utils.time_integration import RungeKutta4
from ..utils.projection import ClassicProjection, RotationalProjection


class ProjectionSolver(NavierStokesBase):
    """圧力投影法を用いたNavier-Stokesソルバー

    圧力投影法を使用して非圧縮性を厳密に満たすソルバーです。
    古典的な投影法と回転形式の投影法をサポートします。
    """

    def __init__(
        self,
        terms: List[NavierStokesTerm],
        properties: Optional[LevelSetPropertiesManager] = None,
        time_integrator: Optional[TimeIntegrator] = None,
        poisson_solver: Optional[PoissonSolver] = None,
        use_rotational: bool = False,
        logger=None,
    ):
        """ソルバーを初期化

        Args:
            terms: NS方程式の各項
            properties: 物性値マネージャー
            time_integrator: 時間積分スキーム
            poisson_solver: 圧力ポアソンソルバー
            use_rotational: 回転形式の投影法を使用するかどうか
            logger: ロガー
        """
        time_integrator = time_integrator or RungeKutta4()
        super().__init__(time_integrator, terms, properties, logger)

        # 圧力投影法の設定
        self.poisson_solver = poisson_solver or SORSolver(
            omega=1.5,
            tolerance=1e-6,
            max_iterations=1000,
            use_redblack=True,
            auto_tune=True,
        )

        # 投影法の選択
        self.projection = (
            RotationalProjection(self.poisson_solver)
            if use_rotational
            else ClassicProjection(self.poisson_solver)
        )

        # 診断情報の初期化
        self._projection_diagnostics: Dict[str, Any] = {}

    def compute_derivative(
        self,
        velocity: VectorField,
        levelset: LevelSetField,
        properties: LevelSetPropertiesManager,
        **kwargs,
    ) -> VectorField:
        """速度場の時間微分を計算

        Args:
            velocity: 速度場
            levelset: レベルセット場
            properties: 物性値マネージャー
            **kwargs: 追加のパラメータ

        Returns:
            計算された時間微分のVectorField
        """
        # 圧力項を除く全項の寄与を計算
        result = VectorField(velocity.shape, velocity.dx)

        # 各項の寄与を計算して合計（圧力項を除く）
        for term in self.terms:
            if term.enabled and term.name != "Pressure":
                contributions = term.compute(velocity, levelset, properties, **kwargs)
                # 各成分に寄与を加算
                for i, contribution in enumerate(contributions):
                    result.components[i].data += contribution

        return result

    def solve_pressure_poisson(
        self,
        velocity: VectorField,
        pressure: ScalarField,
        levelset: LevelSetField,
        dt: float,
    ) -> Tuple[VectorField, ScalarField]:
        """圧力ポアソン方程式を解き、速度場を投影

        Args:
            velocity: 速度場
            pressure: 現在の圧力場
            levelset: レベルセット場
            dt: 時間刻み幅

        Returns:
            (投影された速度場, 更新された圧力場)のタプル
        """
        return self.projection.project(
            velocity=velocity,
            pressure=pressure,
            dt=dt,
            levelset=levelset,
            properties=self.properties,
        )

    def step_forward(self, dt: float, **kwargs) -> Dict[str, Any]:
        """1時間ステップを進める

        Args:
            dt: 時間刻み幅
            **kwargs: 追加のパラメータ
                - state: 現在のシミュレーション状態

        Returns:
            計算結果と診断情報を含む辞書
        """
        state = kwargs.get("state")
        if state is None:
            raise ValueError("stateが指定されていません")

        try:
            # 1. 速度場の時間発展（圧力項を除く）
            intermediate_state = super().step_forward(dt=dt, state=state)["state"]

            # 2. 圧力投影による速度場の補正と圧力場の更新
            velocity_new, pressure_new = self.solve_pressure_poisson(
                intermediate_state.velocity,
                state.pressure,
                state.levelset,
                dt,
            )

            # 診断情報を収集
            diagnostics = self._collect_diagnostics(
                velocity_new, pressure_new, intermediate_state, dt
            )

            return {
                "velocity": velocity_new,
                "pressure": pressure_new,
                "diagnostics": diagnostics,
            }

        except Exception as e:
            if self.logger:
                self.logger.error(f"ProjectionSolverの時間発展中にエラー: {e}")
            raise

    def _collect_diagnostics(
        self,
        velocity: VectorField,
        pressure: ScalarField,
        intermediate_state: Any,
        dt: float,
    ) -> Dict[str, Any]:
        """診断情報を収集

        Args:
            velocity: 更新後の速度場
            pressure: 更新後の圧力場
            intermediate_state: 中間状態
            dt: 時間刻み幅

        Returns:
            診断情報を含む辞書
        """
        # 基本的な診断情報
        diag = {
            "time": self.time,
            "dt": dt,
            "iteration": self.iteration_count,
            "velocity": {
                "max": float(max(np.max(np.abs(c.data)) for c in velocity.components)),
                "divergence": float(np.max(np.abs(velocity.divergence()))),
                "energy": float(
                    sum(np.sum(c.data**2) for c in velocity.components)
                    * 0.5
                    * velocity.dx**3
                ),
            },
            "pressure": {
                "min": float(np.min(pressure.data)),
                "max": float(np.max(pressure.data)),
                "mean": float(np.mean(pressure.data)),
            },
            "projection": {
                "type": "rotational"
                if isinstance(self.projection, RotationalProjection)
                else "classic",
                "poisson_iterations": self.poisson_solver.iteration_count,
            },
        }

        # 各項の診断情報を追加
        for term in self.terms:
            if term.enabled:
                diag[term.name] = term.get_diagnostics()

        return diag

    def get_diagnostics(self) -> Dict[str, Any]:
        """ソルバーの診断情報を取得"""
        diag = super().get_diagnostics()
        diag.update(
            {
                "projection_type": "rotational"
                if isinstance(self.projection, RotationalProjection)
                else "classic",
                "terms": {
                    term.name: term.get_diagnostics()
                    for term in self.terms
                    if term.enabled
                },
                "poisson_solver": {
                    "iterations": self.poisson_solver.iteration_count,
                    "converged": getattr(self.poisson_solver, "converged", None),
                },
            }
        )
        return diag

```

### physics/navier_stokes/solvers/__init__.py

```
"""Navier-Stokesソルバーパッケージ

このパッケージは、Navier-Stokes方程式を解くための様々なソルバーを提供します。
基本的なソルバーと、圧力投影法を使用した改良版ソルバーを含みます。
"""

from .basic_solver import BasicNavierStokesSolver
from .projection_solver import ProjectionSolver

__all__ = [
    "BasicNavierStokesSolver",
    "ProjectionSolver",
]

```

### physics/navier_stokes/__init__.py

```
"""Navier-Stokes方程式の数値計算パッケージ

このパッケージは、Navier-Stokes方程式の数値解法に必要な各種機能を提供します。
主な機能には以下が含まれます：

- ソルバー (NavierStokesSolver, ProjectionSolver)
- 各種項の実装 (移流項、粘性項、圧力項、外力項)
- 時間積分スキーム (RK4, Adams-Bashforth等)
- 圧力投影法 (古典的投影法、回転形式投影法)
"""

# インターフェース
from .core.interfaces import (
    NavierStokesSolver,
    NavierStokesTerm,
    TimeIntegrator,
    PressureProjection,
)

# ソルバー
from .solvers import (
    BasicNavierStokesSolver,
    ProjectionSolver,
)

# 個別の項
from .terms import (
    AdvectionTerm,
    DiffusionTerm,
    PressureTerm,
    GravityForce,
    SurfaceTensionForce,
    ForceTerm,
)

# ユーティリティ
from .utils import (
    ForwardEuler,
    RungeKutta4,
    AdamsBashforth,
    create_integrator,
    ClassicProjection,
    RotationalProjection,
)

__version__ = "1.0.0"

__all__ = [
    # インターフェース
    "NavierStokesSolver",
    "NavierStokesTerm",
    "TimeIntegrator",
    "PressureProjection",
    # ソルバー
    "BasicNavierStokesSolver",
    "ProjectionSolver",
    # 個別の項
    "AdvectionTerm",
    "DiffusionTerm",
    "PressureTerm",
    "GravityForce",
    "SurfaceTensionForce",
    "ForceTerm",
    # ユーティリティ
    "ForwardEuler",
    "RungeKutta4",
    "AdamsBashforth",
    "create_integrator",
    "ClassicProjection",
    "RotationalProjection",
]

```

### physics/time_evolution/solver.py

```
"""時間発展ソルバーの基底クラスを提供するモジュール

このモジュールは、時間発展問題を解くためのソルバーの基底クラスを定義します。
"""

from typing import Dict, Any, Optional, List
import numpy as np

from .base import TimeEvolutionBase, TimeEvolutionTerm, TimeEvolutionConfig
from .integrator import create_integrator


class TimeEvolutionSolver(TimeEvolutionBase):
    """時間発展ソルバーの基底クラス"""

    def __init__(
        self,
        terms: Optional[List[TimeEvolutionTerm]] = None,
        integrator_type: str = "rk4",
        cfl: float = 0.5,
        min_dt: float = 1e-6,
        max_dt: float = 1.0,
        config: Optional[TimeEvolutionConfig] = None,
        logger=None,
    ):
        """ソルバーを初期化

        Args:
            terms: 時間発展方程式の各項
            integrator_type: 時間積分器の種類
            cfl: CFL数
            min_dt: 最小時間刻み幅
            max_dt: 最大時間刻み幅
            config: 時間発展設定
            logger: ロガー
        """
        super().__init__(config, logger)

        # 時間発展の項
        self.terms: List[TimeEvolutionTerm] = terms or []

        # 時間刻み幅の制限
        self.cfl = cfl
        self.min_dt = min_dt
        self.max_dt = max_dt

        # 時間積分器の設定
        self.integrator = create_integrator(integrator_type)

    def compute_timestep(self, **kwargs) -> float:
        """CFL条件に基づく時間刻み幅を計算

        Args:
            **kwargs: 時間刻み幅計算に必要なパラメータ

        Returns:
            計算された時間刻み幅
        """
        # 各項からの時間刻み幅制限を計算
        dt_limits = [self.max_dt]
        for term in self.terms:
            if hasattr(term, "compute_timestep"):
                try:
                    dt_limits.append(term.compute_timestep(**kwargs))
                except Exception as e:
                    if self.logger:
                        self.logger.warning(
                            f"項{term.name}の時間刻み幅計算でエラー: {e}"
                        )

        # CFL条件に基づく制限と項からの制限を統合
        dt = min(dt_limits)

        # 全体の制限を適用
        return np.clip(dt, self.min_dt, self.max_dt)

    def compute_derivative(self, state: Any, **kwargs) -> Any:
        """時間微分を計算

        Args:
            state: 現在の状態
            **kwargs: 追加のパラメータ

        Returns:
            計算された時間微分
        """
        # 各項の寄与を計算
        contributions = []
        for term in self.terms:
            try:
                contrib = term.compute(state, **kwargs)
                contributions.append(contrib)
            except Exception as e:
                if self.logger:
                    self.logger.error(f"項{term.name}の計算中にエラー: {e}")
                raise

        return sum(contributions)

    def step_forward(self, dt: float, **kwargs) -> Dict[str, Any]:
        """1時間ステップを進める

        Args:
            dt: 時間刻み幅
            **kwargs: 追加のパラメータ

        Returns:
            計算結果と診断情報を含む辞書
        """
        try:
            # 状態の取得
            state = kwargs.get("state")
            if state is None:
                raise ValueError("stateが指定されていません")

            # 時間刻み幅の更新
            self._dt = dt

            # 時間積分の実行
            new_state = self.integrator.integrate(
                dt=dt, derivative_fn=self.compute_derivative, state=state, **kwargs
            )

            # 反復回数と時刻の更新
            self._iteration_count += 1
            self._time += dt
            self._time_history.append(self._time)

            # 診断情報の収集
            diagnostics: Dict[str, Any] = {
                "time": self._time,
                "dt": dt,
                "iteration": self._iteration_count,
                "integrator_info": (
                    self.integrator.get_diagnostics()
                    if hasattr(self.integrator, "get_diagnostics")
                    else {}
                ),
            }

            # 各項の診断情報を追加
            for term in self.terms:
                try:
                    diagnostics[term.name] = term.get_diagnostics(
                        state=new_state, previous_state=state, dt=dt
                    )
                except Exception as e:
                    if self.logger:
                        self.logger.warning(f"項{term.name}の診断情報取得でエラー: {e}")

            return {"state": new_state, "time": self._time, "diagnostics": diagnostics}

        except Exception as e:
            if self.logger:
                self.logger.error(f"時間発展計算中にエラー: {e}")
            raise

    def get_diagnostics(self) -> Dict[str, Any]:
        """ソルバーの診断情報を取得

        Returns:
            診断情報の辞書
        """
        diag = super().get_diagnostics()
        diag.update(
            {
                "active_terms": len(self.terms),
                "integrator": self.integrator.__class__.__name__,
                "cfl": self.cfl,
                "min_dt": self.min_dt,
                "max_dt": self.max_dt,
            }
        )
        return diag

```

### physics/time_evolution/base.py

```
"""時間積分スキームを提供するモジュール

このモジュールは、微分方程式の時間積分を行うための数値スキームを提供します。
前進Euler法やRunge-Kutta法など、様々な時間積分手法を実装します。
"""

from typing import Any, Callable, Dict, Protocol


class TimeIntegratorBase(Protocol):
    """時間積分のプロトコル"""

    def integrate(
        self,
        dt: float,
        derivative_fn: Callable[[Any, float], Any],
        state: Any,
        **kwargs,
    ) -> Any:
        """時間積分を実行

        Args:
            dt: 時間刻み幅
            derivative_fn: 時間微分を計算する関数
            state: 現在の状態
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        ...

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        ...

```

### physics/time_evolution/integrator.py

```
"""時間積分スキームを提供するモジュール

このモジュールは、微分方程式の時間積分を行うための数値スキームを実装します。
前進Euler法やRunge-Kutta法など、様々な時間積分手法を実装します。
"""

from typing import Any, Callable, Dict, Protocol, Union


class TimeIntegratorBase(Protocol):
    """時間積分のプロトコル"""

    def integrate(
        self,
        dt: float,
        derivative_fn: Callable[[Any, float], Any],
        state: Any,
        **kwargs,
    ) -> Any:
        """時間積分を実行

        Args:
            dt: 時間刻み幅
            derivative_fn: 時間微分を計算する関数
            state: 現在の状態
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        ...

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        ...


class ForwardEuler:
    """前進Euler法による時間積分"""

    def integrate(
        self,
        dt: float,
        derivative_fn: Callable[[Any, float], Any],
        state: Any,
        **kwargs,
    ) -> Any:
        """前進Euler法で時間積分を実行

        Args:
            dt: 時間刻み幅
            derivative_fn: 時間微分を計算する関数
            state: 現在の状態
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        derivative = derivative_fn(state, **kwargs)
        return state + dt * derivative

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {"method": "Forward Euler", "order": 1, "error_estimate": 0.5}


class RungeKutta4:
    """4次のRunge-Kutta法による時間積分"""

    def integrate(
        self,
        dt: float,
        derivative_fn: Callable[[Any, float], Any],
        state: Any,
        **kwargs,
    ) -> Any:
        """4次のRunge-Kutta法で時間積分を実行

        Args:
            dt: 時間刻み幅
            derivative_fn: 時間微分を計算する関数
            state: 現在の状態
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        # 各ステージでの微分計算に必要な追加パラメータを保持
        common_kwargs = {**kwargs, "state": state}

        # ステージの微分計算
        k1 = derivative_fn(state, **common_kwargs)
        k2 = derivative_fn(state + 0.5 * dt * k1, **common_kwargs)
        k3 = derivative_fn(state + 0.5 * dt * k2, **common_kwargs)
        k4 = derivative_fn(state + dt * k3, **common_kwargs)

        # 状態の更新
        return state + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "method": "Runge-Kutta 4",
            "order": 4,
            "error_estimate": 1 / 30,
        }


def create_integrator(
    integrator_type: str, **kwargs
) -> Union[ForwardEuler, RungeKutta4]:
    """時間積分器を生成

    Args:
        integrator_type: 積分器の種類（"euler", "rk4"）
        **kwargs: 追加のキーワード引数

    Returns:
        生成された時間積分器

    Raises:
        ValueError: 未対応の積分器が指定された場合
    """
    integrators = {
        "euler": ForwardEuler,
        "rk4": RungeKutta4,
    }

    if integrator_type.lower() not in integrators:
        raise ValueError(f"未対応の積分器です: {integrator_type}")

    return integrators[integrator_type.lower()](**kwargs)

```

### physics/time_evolution/__init__.py

```
"""時間発展計算パッケージ

このパッケージは、時間発展計算に必要な基底クラスとユーティリティを提供します。
"""

from .base import TimeEvolutionBase, TimeEvolutionTerm, TimeEvolutionConfig
from .solver import TimeEvolutionSolver
from .integrator import TimeIntegratorBase, create_integrator
from .methods.euler import ForwardEuler
from .methods.runge_kutta import RungeKutta4

__all__ = [
    # 基底クラスとインターフェース
    "TimeEvolutionBase",
    "TimeEvolutionTerm",
    "TimeEvolutionConfig",
    "TimeIntegratorBase",
    # ソルバー
    "TimeEvolutionSolver",
    # 積分器関連
    "create_integrator",
    "ForwardEuler",
    "RungeKutta4",
]

```

### physics/time_evolution/methods/runge_kutta.py

```
"""Runge-Kutta 4次法による時間積分を提供するモジュール"""

from typing import Any, Callable, Dict
from ..base import TimeIntegratorBase


class RungeKutta4(TimeIntegratorBase):
    """4次のRunge-Kutta法による時間積分"""

    def integrate(
        self,
        dt: float,
        derivative_fn: Callable[[Any, float], Any],
        state: Any,
        **kwargs,
    ) -> Any:
        """4次のRunge-Kutta法で時間積分を実行

        Args:
            dt: 時間刻み幅
            derivative_fn: 時間微分を計算する関数
            state: 現在の状態
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        # 各ステージでの微分計算に必要な追加パラメータを保持
        common_kwargs = {**kwargs, "state": state}

        # ステージの微分計算
        k1 = derivative_fn(state, **common_kwargs)
        k2 = derivative_fn(state + 0.5 * dt * k1, **common_kwargs)
        k3 = derivative_fn(state + 0.5 * dt * k2, **common_kwargs)
        k4 = derivative_fn(state + dt * k3, **common_kwargs)

        # 状態の更新
        return state + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "method": "Runge-Kutta 4",
            "order": 4,
            "error_estimate": 1 / 30,
            "stability": "無条件安定",
        }

```

### physics/time_evolution/methods/euler.py

```
"""前進Euler法による時間積分を提供するモジュール"""

from typing import Any, Callable, Dict
from ..integrator import TimeIntegratorBase


class ForwardEuler(TimeIntegratorBase):
    """前進Euler法による時間積分"""

    def integrate(
        self, state: Any, dt: float, derivative_fn: Callable[[Any], Any], **kwargs
    ) -> Any:
        """前進Euler法で時間積分を実行

        Args:
            state: 現在の状態
            dt: 時間刻み幅
            derivative_fn: 時間微分を計算する関数
            **kwargs: 追加のパラメータ

        Returns:
            更新された状態
        """
        derivative = derivative_fn(state, **kwargs)
        return state + dt * derivative

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得"""
        return {
            "method": "Forward Euler",
            "order": 1,
            "error_estimate": 0.5,
            "stability": "条件付き安定",
        }

```

### physics/poisson/solver.py

```
"""Poisson方程式のソルバーを提供するモジュール

このモジュールは、Poisson方程式 ∇²φ = f を解くための反復法ソルバーを実装します。
"""

import numpy as np
from typing import Optional, List, Dict, Any, Union

from core.solver import IterativeSolver
from core.boundary import BoundaryCondition
from .base import PoissonSolverBase, PoissonSolverConfig, PoissonSolverTerm
from .config import PoissonSolverConfig


class PoissonSolver(PoissonSolverBase, IterativeSolver):
    """Poisson方程式の基底ソルバークラス

    このクラスは、Poisson方程式を解くための基本機能を提供します。
    具体的な反復法は派生クラスで実装します。
    """

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        boundary_conditions: Optional[List[BoundaryCondition]] = None,
        terms: Optional[List[PoissonSolverTerm]] = None,
        **kwargs,
    ):
        """Poissonソルバーを初期化

        Args:
            config: ソルバー設定
            boundary_conditions: 各方向の境界条件
            terms: 追加の項
            **kwargs: 基底クラスに渡すパラメータ
        """
        # デフォルト設定の処理
        config = config or PoissonSolverConfig()
        kwargs.setdefault("name", "Poisson")
        kwargs.setdefault("tolerance", config.convergence.get("tolerance", 1e-6))
        kwargs.setdefault(
            "max_iterations", config.convergence.get("max_iterations", 1000)
        )

        # 基底クラスの初期化
        PoissonSolverBase.__init__(
            self,
            config=config,
            boundary_conditions=boundary_conditions,
            logger=kwargs.get("logger"),
        )
        IterativeSolver.__init__(self, **kwargs)

        # 追加の項
        self.terms = terms or []

        # 収束判定フラグ
        self._converged = False

    def solve(
        self,
        rhs: np.ndarray,
        initial_solution: Optional[np.ndarray] = None,
        dx: Union[float, np.ndarray] = 1.0,
        **kwargs,
    ) -> np.ndarray:
        """Poisson方程式を解く

        Args:
            rhs: 右辺ベクトル
            initial_solution: 初期推定解
            dx: グリッド間隔
            **kwargs: 追加のパラメータ

        Returns:
            計算された解
        """
        try:
            # 初期解のセットアップ
            if initial_solution is None:
                initial_solution = np.zeros_like(rhs)

            # dx の正規化
            if np.isscalar(dx):
                dx = np.full(rhs.ndim, dx)
            elif len(dx) != rhs.ndim:
                raise ValueError(f"dxは{rhs.ndim}次元である必要があります")

            # 初期化処理
            self.reset()
            self._converged = False

            # 反復解法の実行
            solution = initial_solution.copy()
            residual = float("inf")  # 初期残差

            diagnostics_config = self.config.get_config_for_component("diagnostics")
            log_frequency = diagnostics_config.get("log_frequency", 10)

            while self._iteration_count < self.max_iterations:
                # 1回の反復
                new_solution = self.iterate(solution, rhs, dx)

                # 残差の計算
                residual = self.compute_residual(new_solution, rhs, dx)
                self._residual_history.append(residual)

                # 反復回数の更新
                self._iteration_count += 1

                # ログ出力
                if self._iteration_count % log_frequency == 0 and self.logger:
                    self.logger.info(
                        f"反復 {self._iteration_count}: 残差 = {residual:.3e}"
                    )

                # 収束判定
                if self.check_convergence(residual):
                    self._converged = True
                    break

                solution = new_solution

            # 結果の後処理
            if not self._converged and self.logger:
                self.logger.warning(
                    f"最大反復回数に到達: 残差 = {residual:.3e}, "
                    f"相対残差 = {residual / self._residual_history[0]:.3e}"
                )

            return solution

        except Exception as e:
            if self.logger:
                self.logger.error(f"Poissonソルバー実行中にエラー: {e}")
            raise

    def compute_residual(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> float:
        """残差を計算

        Args:
            solution: 現在の解
            rhs: 右辺
            dx: グリッド間隔（スカラーまたは配列）

        Returns:
            L2ノルムで測った残差
        """
        # dx の正規化
        if np.isscalar(dx):
            dx = np.full(solution.ndim, dx)
        elif len(dx) != solution.ndim:
            raise ValueError(f"dxは{solution.ndim}次元である必要があります")

        # ラプラシアンの計算
        laplacian = np.zeros_like(solution)
        for axis in range(solution.ndim):
            # 2次精度中心差分
            # 各方向のグリッド間隔を考慮
            forward = np.roll(solution, 1, axis=axis)
            backward = np.roll(solution, -1, axis=axis)
            laplacian += (forward + backward - 2 * solution) / (dx[axis] ** 2)

        # 残差の計算と境界条件の適用
        residual = laplacian - rhs

        # 境界条件の適用
        if self.boundary_conditions:
            for i, bc in enumerate(self.boundary_conditions):
                if bc is not None:
                    residual = bc.apply_all(residual, i)

        # L2ノルムを計算（ゼロ除算を防ぐ）
        residual_norm = np.sqrt(np.mean(residual**2))
        return max(residual_norm, 1e-15)  # 最小値を保証

    def iterate(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> np.ndarray:
        """デフォルトの反復計算（サブクラスでオーバーライド）

        Args:
            solution: 現在の解
            rhs: 右辺
            dx: グリッド間隔

        Raises:
            NotImplementedError: サブクラスで実装する必要がある
        """
        raise NotImplementedError("具体的な反復法はサブクラスで実装する必要があります")

    def check_convergence(self, residual: float) -> bool:
        """収束判定

        Args:
            residual: 現在の残差

        Returns:
            収束したかどうか
        """
        # 収束判定設定の取得
        convergence_config = self.config.get_config_for_component("convergence")
        relative_tolerance = convergence_config.get("relative_tolerance", False)

        # 初期残差の記録（最初の呼び出し時）
        if not self._residual_history:
            return False

        # 絶対残差または相対残差による収束判定
        if relative_tolerance:
            # 相対残差
            return (
                residual / self._residual_history[0] < self.tolerance
                and residual < self.tolerance
            )
        else:
            # 絶対残差
            return residual < self.tolerance

    def get_status(self) -> Dict[str, Any]:
        """ソルバーの状態を取得

        Returns:
            ソルバーの状態を表す辞書
        """
        status = super().get_status()
        status.update(
            {
                "terms_count": len(self.terms),
                "boundary_conditions_count": len(self.boundary_conditions),
                "config": {
                    "convergence": self.config.get_config_for_component("convergence"),
                    "solver_specific": self.config.get_config_for_component(
                        "solver_specific"
                    ),
                },
            }
        )
        return status

```

### physics/poisson/base.py

```
"""Poisson方程式ソルバーの基底クラスとプロトコル

このモジュールは、Poisson方程式を解くためのインターフェースと基底クラスを定義します。
"""

from abc import ABC, abstractmethod
from typing import Protocol, Optional, List, Dict, Any, Union
import numpy as np

from core.boundary import BoundaryCondition


class PoissonSolverConfig(Protocol):
    """Poissonソルバーの設定プロトコル"""

    def validate(self) -> None:
        """設定値の妥当性を検証"""
        ...

    def get_config_for_component(self, component: str) -> Dict[str, Any]:
        """特定のコンポーネントの設定を取得"""
        ...


class PoissonSolverTerm(Protocol):
    """Poisson方程式の項のプロトコル"""

    @property
    def name(self) -> str:
        """項の名前"""
        ...

    def compute(self, solution: np.ndarray, **kwargs) -> np.ndarray:
        """項の寄与を計算"""
        ...

    def get_diagnostics(self, solution: np.ndarray, **kwargs) -> Dict[str, Any]:
        """診断情報を取得"""
        ...


class PoissonSolverBase(ABC):
    """Poisson方程式ソルバーの基底抽象クラス"""

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        boundary_conditions: Optional[List[BoundaryCondition]] = None,
        logger=None,
    ):
        """ソルバーを初期化

        Args:
            config: ソルバー設定
            boundary_conditions: 境界条件
            logger: ロガー
        """
        self.config = config
        self.boundary_conditions = boundary_conditions or []
        self.logger = logger

        # 計算状態の追跡
        self._iteration_count = 0
        self._residual_history: List[float] = []
        self._converged = False

    @abstractmethod
    def solve(
        self, rhs: np.ndarray, initial_solution: Optional[np.ndarray] = None, **kwargs
    ) -> np.ndarray:
        """Poisson方程式を解く"""
        pass

    @abstractmethod
    def compute_residual(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> float:
        """残差を計算"""
        pass

    def initialize(self, **kwargs):
        """ソルバーを初期化

        デフォルトの実装では基本的な状態をリセット
        サブクラスでオーバーライド可能
        """
        # 計算状態のリセット
        self._iteration_count = 0
        self._residual_history = []
        self._converged = False

        # ロギング
        if self.logger:
            self.logger.info(f"{self.__class__.__name__}ソルバーを初期化")

    def get_diagnostics(self) -> Dict[str, Any]:
        """ソルバーの診断情報を取得

        Returns:
            診断情報の辞書
        """
        return {
            "iteration_count": self._iteration_count,
            "converged": self._converged,
            "residual_history": self._residual_history,
            "final_residual": (
                self._residual_history[-1] if self._residual_history else None
            ),
        }

    def reset(self):
        """ソルバーの状態をリセット"""
        self._iteration_count = 0
        self._residual_history = []
        self._converged = False

    def log_diagnostics(self):
        """診断情報をログ出力"""
        if self.logger:
            diag = self.get_diagnostics()
            self.logger.info(f"Poissonソルバー診断情報: {diag}")

```

### physics/poisson/config.py

```
"""Poisson方程式ソルバーの設定を管理するモジュール

このモジュールは、Poisson方程式の数値計算パラメータを定義・管理します。
"""

from dataclasses import dataclass, field
from typing import Dict, Any
import yaml


@dataclass
class PoissonSolverConfig:
    """Poisson方程式ソルバーの数値計算パラメータ"""

    # 収束判定パラメータ
    convergence: Dict[str, Any] = field(
        default_factory=lambda: {
            "tolerance": 1e-6,
            "max_iterations": 1000,
            "relative_tolerance": False,
        }
    )

    # ソルバー固有のパラメータ
    solver_specific: Dict[str, Any] = field(
        default_factory=lambda: {
            "relaxation_parameter": 1.5,  # SORなどで使用
            "auto_tune": False,
            "method": "sor",
        }
    )

    # 診断情報の保存設定
    diagnostics: Dict[str, Any] = field(
        default_factory=lambda: {"save_residual_history": True, "log_frequency": 10}
    )

    def validate(self):
        """設定値の妥当性を検証"""
        # 収束判定パラメータの検証
        if not 0 < self.convergence.get("tolerance", 1e-6) < 1:
            raise ValueError("許容誤差は0から1の間である必要があります")

        if not isinstance(self.convergence.get("max_iterations", 1000), int):
            raise ValueError("最大反復回数は整数である必要があります")

        # ソルバー固有のパラメータ検証
        if not 0 < self.solver_specific.get("relaxation_parameter", 1.5) <= 2:
            raise ValueError("緩和パラメータは0から2の間である必要があります")

        # 有効なソルバー方法のチェック
        valid_methods = ["sor", "jacobi", "gauss_seidel"]
        if self.solver_specific.get("method") not in valid_methods:
            raise ValueError(f"無効なソルバー方法。選択肢: {valid_methods}")

    def get_config_for_component(self, component: str) -> Dict[str, Any]:
        """特定のコンポーネントの設定を取得

        Args:
            component: 設定を取得するコンポーネント名

        Returns:
            コンポーネント固有の設定
        """
        component_configs = {
            "convergence": self.convergence,
            "solver_specific": self.solver_specific,
            "diagnostics": self.diagnostics,
        }
        return component_configs.get(component, {})

    def save(self, filepath: str):
        """設定をYAMLファイルに保存

        Args:
            filepath: 保存先のパス
        """
        with open(filepath, "w", encoding="utf-8") as f:
            yaml.dump(
                {
                    "convergence": self.convergence,
                    "solver_specific": self.solver_specific,
                    "diagnostics": self.diagnostics,
                },
                f,
                default_flow_style=False,
            )

    @classmethod
    def from_yaml(cls, filepath: str) -> "PoissonSolverConfig":
        """YAMLファイルから設定を読み込む

        Args:
            filepath: 読み込むYAMLファイルのパス

        Returns:
            読み込まれた設定インスタンス
        """
        with open(filepath, "r", encoding="utf-8") as f:
            config_dict = yaml.safe_load(f)

        # 設定の検証を含めた初期化
        config = cls(
            convergence=config_dict.get("convergence", {}),
            solver_specific=config_dict.get("solver_specific", {}),
            diagnostics=config_dict.get("diagnostics", {}),
        )
        config.validate()
        return config

```

### physics/poisson/__init__.py

```
"""Poisson方程式のソルバーパッケージ

このパッケージは、Poisson方程式を解くための各種ソルバーを提供します。
"""

from .base import (
    PoissonSolverBase,
    PoissonSolverConfig as PoissonConfig,
    PoissonSolverTerm,
)
from .solver import PoissonSolver
from .methods.sor import SORSolver

__all__ = [
    # ベースクラスとインターフェース
    "PoissonSolverBase",
    "PoissonConfig",
    "PoissonSolverTerm",
    # ソルバー
    "PoissonSolver",
    "SORSolver",
]

```

### physics/poisson/methods/sor.py

```
"""SOR法によるPoissonソルバーを提供するモジュール

このモジュールは、Successive Over-Relaxation (SOR)法による
Poisson方程式のソルバーを実装します。
"""

import numpy as np
from typing import Optional, List, Dict, Any, Union

from physics.poisson.solver import PoissonSolver
from physics.poisson.config import PoissonSolverConfig
from core.boundary import BoundaryCondition
from ..base import PoissonSolverTerm


class SORSolver(PoissonSolver):
    """SOR法によるPoissonソルバー"""

    def __init__(
        self,
        config: Optional[PoissonSolverConfig] = None,
        boundary_conditions: Optional[List[BoundaryCondition]] = None,
        terms: Optional[List[PoissonSolverTerm]] = None,
        **kwargs,
    ):
        """SORソルバーを初期化

        Args:
            config: ソルバー設定
            boundary_conditions: 境界条件のリスト
            terms: 追加の項
            **kwargs: 追加のパラメータ
        """
        # デフォルト設定の取得
        solver_config = config or PoissonSolverConfig()
        solver_specific = solver_config.get_config_for_component("solver_specific")

        # 緩和パラメータの取得
        self.omega = kwargs.get(
            "omega", solver_specific.get("relaxation_parameter", 1.5)
        )

        # 赤黒順序付けの設定
        self.use_redblack = kwargs.get(
            "use_redblack", solver_specific.get("use_redblack", True)
        )

        # 自動調整の設定
        self.auto_tune = kwargs.get(
            "auto_tune", solver_specific.get("auto_tune", False)
        )

        # スペクトル半径の追跡
        self._spectral_radius = None
        self._update_interval = 10
        self._previous_diff = None

        # 親クラスの初期化
        super().__init__(
            config=solver_config,
            boundary_conditions=boundary_conditions,
            terms=terms,
            **kwargs,
        )

    def initialize(self, **kwargs):
        """ソルバーを初期化

        Args:
            **kwargs: 初期化に必要なパラメータ
        """
        # 基本的な初期化処理
        self.reset()  # 基底クラスのリセットメソッド

        # オプションでより詳細な初期化が必要な場合はここに追加可能
        if self.logger:
            self.logger.info("SORソルバーを初期化")

        # スペクトル半径などの追跡変数もリセット
        self._spectral_radius = None
        self._previous_diff = None

    def iterate(
        self, solution: np.ndarray, rhs: np.ndarray, dx: Union[float, np.ndarray]
    ) -> np.ndarray:
        """1回のSOR反復を実行

        Args:
            solution: 現在の解
            rhs: 右辺ベクトル
            dx: グリッド間隔

        Returns:
            更新された解
        """
        result = solution.copy()

        # dx配列の正規化と設定
        if np.isscalar(dx):
            dx = np.full(result.ndim, dx)
        elif len(dx) != result.ndim:
            raise ValueError(f"dxは{result.ndim}次元である必要があります")

        # グリッド間隔の2乗を計算
        dx_squared = np.prod(dx) ** 2

        if self.use_redblack:
            # 赤黒順序付けによる更新
            for color in [0, 1]:  # 0: 赤, 1: 黒
                # 赤黒マスクの生成
                mask = np.ones_like(result, dtype=bool)
                for axis in range(result.ndim):
                    # 各軸で交互のインデックスを選択
                    axis_indices = np.arange(result.shape[axis]) % 2 == color
                    # ブロードキャスト可能な形に変換
                    broadcast_shape = [1] * result.ndim
                    broadcast_shape[axis] = -1
                    axis_mask = axis_indices.reshape(broadcast_shape)
                    # 論理積で絞り込み
                    mask &= axis_mask

                # 近傍点の和を計算
                neighbors_sum = np.zeros_like(result)
                for axis in range(result.ndim):
                    # 各軸で前後の点を取得
                    forward = np.roll(result, 1, axis=axis)
                    backward = np.roll(result, -1, axis=axis)
                    neighbors_sum += forward + backward

                # SOR更新
                gauss_seidel = (dx_squared * rhs[mask] + neighbors_sum[mask]) / (
                    2 * result.ndim
                )
                result[mask] = (1 - self.omega) * result[
                    mask
                ] + self.omega * gauss_seidel

        else:
            # 通常のSOR反復
            for axis in range(result.ndim):
                neighbors_sum = np.roll(result, 1, axis=axis) + np.roll(
                    result, -1, axis=axis
                )
                gauss_seidel = (dx_squared * rhs + neighbors_sum) / (2 * result.ndim)
                result = (1 - self.omega) * result + self.omega * gauss_seidel

        # 境界条件の適用
        if self.boundary_conditions:
            for i, bc in enumerate(self.boundary_conditions):
                if bc is not None:
                    result = bc.apply_all(result, i)

        # 必要に応じて緩和係数を調整
        if self.auto_tune and self._iteration_count % self._update_interval == 0:
            self._update_omega(solution, result)

        return result

    def _update_omega(self, old_solution: np.ndarray, new_solution: np.ndarray):
        """緩和係数を自動調整

        Args:
            old_solution: 前回の解
            new_solution: 新しい解
        """
        # 解の変化から反復行列のスペクトル半径を推定
        diff = new_solution - old_solution
        if self._iteration_count > self._update_interval:
            old_diff = self._previous_diff
            numerator = np.sum(diff * diff)
            denominator = np.sum(old_diff * old_diff)

            if denominator > 1e-10:
                new_radius = np.sqrt(numerator / denominator)

                if self._spectral_radius is None:
                    self._spectral_radius = new_radius
                else:
                    # 指数移動平均で更新
                    alpha = 0.2
                    self._spectral_radius = (
                        1 - alpha
                    ) * self._spectral_radius + alpha * new_radius

                # 最適な緩和係数を計算
                self.omega = 2 / (1 + np.sqrt(1 - self._spectral_radius**2))

        # 現在の差分を保存
        self._previous_diff = diff.copy()

    def get_diagnostics(self) -> Dict[str, Any]:
        """診断情報を取得

        Returns:
            診断情報の辞書
        """
        diag = super().get_diagnostics()
        diag.update(
            {
                "method": "SOR",
                "omega": self.omega,
                "spectral_radius": self._spectral_radius,
                "redblack_ordering": self.use_redblack,
                "auto_tune": self.auto_tune,
            }
        )
        return diag

```

### logger/formatters.py

```
"""ログフォーマッタを提供するモジュール

このモジュールは、ログメッセージの書式設定を行うフォーマッタクラスを提供します。
"""

import logging
import datetime


class DefaultFormatter(logging.Formatter):
    """標準的なログフォーマッタ

    基本的なタイムスタンプ、ログレベル、メッセージを含むフォーマットを提供します。
    """

    def __init__(self, fmt: str = None):
        """フォーマッタを初期化

        Args:
            fmt: フォーマット文字列（Noneの場合はデフォルト使用）
        """
        if fmt is None:
            fmt = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        super().__init__(fmt)


class DetailedFormatter(logging.Formatter):
    """詳細なログフォーマッタ

    ファイル名、行番号、関数名などの詳細情報を含むフォーマットを提供します。
    """

    def __init__(self, fmt: str = None):
        """フォーマッタを初期化

        Args:
            fmt: フォーマット文字列（Noneの場合はデフォルト使用）
        """
        if fmt is None:
            fmt = (
                "%(asctime)s - %(name)s - %(levelname)s - "
                "[%(filename)s:%(lineno)d] - %(message)s"
            )
        super().__init__(fmt)

    def formatTime(self, record: logging.LogRecord, datefmt: str = None) -> str:
        """時刻のフォーマット

        ミリ秒単位の精度を提供します。

        Args:
            record: ログレコード
            datefmt: 日付フォーマット文字列

        Returns:
            フォーマットされた時刻文字列
        """
        ct = datetime.datetime.fromtimestamp(record.created)
        if datefmt:
            s = ct.strftime(datefmt)
        else:
            s = ct.strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        return s


class ColoredFormatter(logging.Formatter):
    """カラー対応のログフォーマッタ

    ログレベルに応じて異なる色でメッセージを表示します。
    """

    # ANSIエスケープシーケンス
    COLORS = {
        "DEBUG": "\033[36m",  # シアン
        "INFO": "\033[32m",  # 緑
        "WARNING": "\033[33m",  # 黄
        "ERROR": "\033[31m",  # 赤
        "CRITICAL": "\033[35m",  # マゼンタ
        "RESET": "\033[0m",  # リセット
    }

    def __init__(self, fmt: str = None, use_color: bool = True):
        """フォーマッタを初期化

        Args:
            fmt: フォーマット文字列（Noneの場合はデフォルト使用）
            use_color: 色付けを使用するかどうか
        """
        if fmt is None:
            fmt = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        super().__init__(fmt)
        self.use_color = use_color

    def format(self, record: logging.LogRecord) -> str:
        """ログレコードをフォーマット

        Args:
            record: ログレコード

        Returns:
            フォーマットされたログメッセージ
        """
        if not self.use_color:
            return super().format(record)

        color = self.COLORS.get(record.levelname, self.COLORS["RESET"])
        record.levelname = f"{color}{record.levelname}{self.COLORS['RESET']}"

        return super().format(record)

```

### logger/config.py

```
"""ロギング設定を管理するモジュール

このモジュールは、ロギングシステムの設定を管理するためのクラスを提供します。
"""

from dataclasses import dataclass, field
from typing import Dict, Any, Optional
from pathlib import Path


@dataclass
class LogConfig:
    """ロギング設定を管理するクラス

    Attributes:
        level: 基本ログレベル
        log_dir: ログファイル出力ディレクトリ
        file_logging: ファイルへのログ出力設定
        console_logging: コンソールへのログ出力設定
        formatters: 各ハンドラ用のフォーマット設定
    """

    level: str = "info"
    log_dir: Path = Path("logs")
    file_logging: Dict[str, Any] = field(
        default_factory=lambda: {
            "enabled": True,
            "filename": "simulation.log",
            "level": "info",
            "max_bytes": 10_000_000,  # 10MB
            "backup_count": 5,
        }
    )
    console_logging: Dict[str, Any] = field(
        default_factory=lambda: {"enabled": True, "level": "info", "color": True}
    )
    formatters: Dict[str, str] = field(
        default_factory=lambda: {
            "default": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
            "detailed": "%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s",
        }
    )

    def __post_init__(self):
        """初期化後の処理

        ディレクトリパスの正規化とバリデーションを行います。
        """
        if isinstance(self.log_dir, str):
            self.log_dir = Path(self.log_dir)

    def validate(self):
        """設定の妥当性を検証

        Raises:
            ValueError: 無効な設定値が検出された場合
        """
        valid_levels = {"debug", "info", "warning", "error", "critical"}
        if self.level.lower() not in valid_levels:
            raise ValueError(f"Invalid log level: {self.level}")

        if not self.file_logging["enabled"] and not self.console_logging["enabled"]:
            raise ValueError("At least one logging handler must be enabled")

    def get_file_path(self, filename: Optional[str] = None) -> Path:
        """ログファイルのパスを取得

        Args:
            filename: 指定されたファイル名（Noneの場合はデフォルト使用）

        Returns:
            ログファイルの完全パス
        """
        filename = filename or self.file_logging["filename"]
        return self.log_dir / filename

    def create_directories(self):
        """必要なディレクトリを作成"""
        self.log_dir.mkdir(parents=True, exist_ok=True)

```

### logger/handlers.py

```
"""ログハンドラを提供するモジュール

このモジュールは、ログの出力先を管理するハンドラクラスを提供します。
"""

import logging
import logging.handlers
from pathlib import Path
from typing import Optional
from .formatters import DefaultFormatter, ColoredFormatter


class FileLogHandler(logging.handlers.RotatingFileHandler):
    """ファイルログハンドラ

    ログをファイルに出力し、ファイルのローテーションを管理します。
    """

    def __init__(
        self,
        filename: Path,
        formatter: Optional[logging.Formatter] = None,
        max_bytes: int = 10_000_000,
        backup_count: int = 5,
        encoding: str = "utf-8",
        level: str = "INFO",
    ):
        """ハンドラを初期化

        Args:
            filename: ログファイルのパス
            formatter: ログフォーマッタ
            max_bytes: 1ファイルの最大サイズ（バイト）
            backup_count: 保持する過去ログの数
            encoding: ファイルのエンコーディング
            level: ログレベル
        """
        super().__init__(
            filename=str(filename),
            maxBytes=max_bytes,
            backupCount=backup_count,
            encoding=encoding,
        )

        self.setFormatter(formatter or DefaultFormatter())
        self.setLevel(getattr(logging, level.upper()))


class ConsoleLogHandler(logging.StreamHandler):
    """コンソールログハンドラ

    ログを標準出力に出力します。
    """

    def __init__(
        self,
        formatter: Optional[logging.Formatter] = None,
        level: str = "INFO",
        use_color: bool = True,
    ):
        """ハンドラを初期化

        Args:
            formatter: ログフォーマッタ
            level: ログレベル
            use_color: 色付きログを使用するかどうか
        """
        super().__init__()

        if use_color:
            self.setFormatter(formatter or ColoredFormatter(use_color=True))
        else:
            self.setFormatter(formatter or DefaultFormatter())

        self.setLevel(getattr(logging, level.upper()))


class BufferedLogHandler(logging.Handler):
    """バッファ付きログハンドラ

    ログメッセージをメモリ上にバッファリングし、必要に応じて一括出力します。
    デバッグやテスト時に便利です。
    """

    def __init__(self, capacity: int = 1000):
        """ハンドラを初期化

        Args:
            capacity: バッファの最大容量
        """
        super().__init__()
        self.capacity = capacity
        self.buffer = []

    def emit(self, record: logging.LogRecord):
        """ログレコードをバッファに追加

        Args:
            record: ログレコード
        """
        if len(self.buffer) >= self.capacity:
            self.buffer.pop(0)
        self.buffer.append(self.format(record))

    def get_logs(self) -> list:
        """バッファ内のログを取得"""
        return self.buffer.copy()

    def clear(self):
        """バッファをクリア"""
        self.buffer.clear()


class MultiProcessLogHandler(logging.handlers.SocketHandler):
    """マルチプロセス対応ログハンドラ

    複数のプロセスからのログを安全に処理します。
    """

    def __init__(self, host: str = "localhost", port: int = 9020):
        """ハンドラを初期化

        Args:
            host: ログサーバーのホスト
            port: ログサーバーのポート
        """
        super().__init__(host, port)
        self.setFormatter(DefaultFormatter())

    def emit(self, record: logging.LogRecord):
        """ログレコードを送信

        Args:
            record: ログレコード
        """
        try:
            super().emit(record)
        except Exception:
            self.handleError(record)

```

### logger/logger.py

```
import logging
from pathlib import Path
from typing import Optional, Dict, Any, Union
from .config import LogConfig
from .handlers import FileLogHandler, ConsoleLogHandler, BufferedLogHandler
from .formatters import DetailedFormatter


class SimulationLogger:
    """シミュレーション用ロガークラス"""

    def __init__(
        self,
        name: str,
        config: Optional[LogConfig] = None,
        parent: Optional["SimulationLogger"] = None,
    ):
        """ロガーを初期化"""
        self.name = name
        self.config = config or LogConfig()
        self.parent = parent

        # 基本設定の検証
        self.config.validate()
        self.config.create_directories()

        # Pythonの標準ロガーを作成
        self._logger = self._create_logger()

        # デバッグ情報の記録用バッファ
        self._debug_buffer = BufferedLogHandler()
        self._logger.addHandler(self._debug_buffer)

        if parent is None:  # ルートロガーの場合のみ初期ログを出力
            self.info(f"ロギングシステムを初期化: {name}")

    def _create_logger(self) -> logging.Logger:
        """ロガーを生成して設定"""
        logger = logging.getLogger(self.name)
        logger.setLevel(getattr(logging, self.config.level.upper()))

        # 既存のハンドラをクリア
        logger.handlers.clear()

        # ファイルハンドラの設定
        if self.config.file_logging["enabled"]:
            file_handler = FileLogHandler(
                filename=self.config.get_file_path(),
                formatter=DetailedFormatter(),
                max_bytes=self.config.file_logging["max_bytes"],
                backup_count=self.config.file_logging["backup_count"],
                level=self.config.file_logging["level"],
            )
            logger.addHandler(file_handler)

        # コンソールハンドラの設定
        if self.config.console_logging["enabled"]:
            console_handler = ConsoleLogHandler(
                level=self.config.console_logging["level"],
                use_color=self.config.console_logging["color"],
            )
            logger.addHandler(console_handler)

        return logger

    # 基本的なロギングメソッドを直接実装
    def debug(self, msg: str, *args, **kwargs):
        """デバッグレベルのログを出力"""
        self._logger.debug(msg, *args, **kwargs)

    def info(self, msg: str, *args, **kwargs):
        """情報レベルのログを出力"""
        self._logger.info(msg, *args, **kwargs)

    def warning(self, msg: str, *args, **kwargs):
        """警告レベルのログを出力"""
        self._logger.warning(msg, *args, **kwargs)

    def error(self, msg: str, *args, **kwargs):
        """エラーレベルのログを出力"""
        self._logger.error(msg, *args, **kwargs)

    def critical(self, msg: str, *args, **kwargs):
        """クリティカルレベルのログを出力"""
        self._logger.critical(msg, *args, **kwargs)

    def start_section(self, name: str) -> "SimulationLogger":
        """新しいログセクションを開始"""
        section_name = f"{self.name}.{name}"
        return SimulationLogger(section_name, self.config, self)

    def get_recent_logs(self, n: int = 100) -> list:
        """最近のログメッセージを取得"""
        return self._debug_buffer.get_logs()[-n:]

    def save_debug_info(self, path: Union[str, Path]):
        """デバッグ情報をファイルに保存"""
        path = Path(path)
        with path.open("w", encoding="utf-8") as f:
            for log in self._debug_buffer.get_logs():
                f.write(f"{log}\n")

    def log_error_with_context(
        self, msg: str, error: Exception, context: Optional[Dict[str, Any]] = None
    ):
        """エラー情報をコンテキスト付きでログ出力"""
        error_info = {
            "message": msg,
            "error_type": type(error).__name__,
            "error_msg": str(error),
            "context": context or {},
        }
        self._logger.error(f"Error occurred: {error_info}", exc_info=True)

    def log_performance(self, section: str, elapsed: float):
        """パフォーマンス情報をログ出力"""
        self._logger.info(f"Performance - {section}: {elapsed:.3f} seconds")

    def log_simulation_state(self, state: Dict[str, Any], level: str = "info"):
        """シミュレーション状態をログ出力"""
        log_func = getattr(self._logger, level.lower())
        log_func(f"Simulation State: {state}")

    def __enter__(self):
        """コンテキストマネージャのエントリー"""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """コンテキストマネージャのイグジット"""
        if exc_type is not None:
            self.log_error_with_context(
                "Error in simulation section", exc_val, {"section": self.name}
            )
        return False  # 例外を伝播させる

    @property
    def level(self) -> int:
        """ログレベルを取得

        Returns:
            logging モジュールのログレベル定数
        """
        # 文字列のログレベルを対応する数値に変換
        level_map = {
            "debug": logging.DEBUG,
            "info": logging.INFO,
            "warning": logging.WARNING,
            "error": logging.ERROR,
            "critical": logging.CRITICAL,
        }

        # configのレベルを数値に変換
        str_level = self.config.level.lower()
        return level_map.get(str_level, logging.INFO)  # デフォルトはINFO

```

### logger/__init__.py

```
"""シミュレーション用ロギングパッケージ

このパッケージは、シミュレーション全体で使用される統一的なロギング機能を提供します。
"""

from .logger import SimulationLogger
from .handlers import FileLogHandler, ConsoleLogHandler
from .formatters import DefaultFormatter, DetailedFormatter
from .config import LogConfig

__all__ = [
    "SimulationLogger",
    "FileLogHandler",
    "ConsoleLogHandler",
    "DefaultFormatter",
    "DetailedFormatter",
    "LogConfig",
]

```

### main2.py

```
"""二相流シミュレーションの実行スクリプト"""

import sys
import argparse
from pathlib import Path

from logger import SimulationLogger, LogConfig
from simulations import TwoPhaseFlowSimulator, SimulationConfig
from visualization import visualize_simulation_state
from typing import Optional


def parse_args():
    """コマンドライン引数をパース"""
    parser = argparse.ArgumentParser(
        description="Level Set法による二相流シミュレーション"
    )
    parser.add_argument("--config", type=str, required=True, help="設定ファイルのパス")
    parser.add_argument("--checkpoint", type=str, help="チェックポイントファイルのパス")
    parser.add_argument("--debug", action="store_true", help="デバッグモードを有効化")
    return parser.parse_args()


def setup_logging(config: SimulationConfig, debug: bool) -> SimulationLogger:
    """ロギングを設定"""
    log_level = "debug" if debug else "info"
    log_dir = Path(config.output_dir) / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    return SimulationLogger("TwoPhaseFlow", LogConfig(level=log_level, log_dir=log_dir))


def initialize_simulation(
    config: SimulationConfig,
    logger: SimulationLogger,
    checkpoint: Optional[Path] = None,
) -> TwoPhaseFlowSimulator:
    """シミュレーションを初期化"""
    # 出力ディレクトリの作成
    output_dir = Path(config.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    if checkpoint:
        logger.info(f"チェックポイントから再開: {checkpoint}")
        sim = TwoPhaseFlowSimulator(config, logger)
        sim.initialize(state=sim.load_checkpoint(str(checkpoint)))
        return sim
    else:
        logger.info("新規シミュレーションを開始")
        sim = TwoPhaseFlowSimulator(config, logger)
        sim.initialize()
        return sim


def main():
    """メイン関数"""
    # コマンドライン引数の解析
    args = parse_args()

    # 設定ファイルの読み込み
    config = SimulationConfig.from_yaml(args.config)

    # ロガーの設定
    logger = setup_logging(config, args.debug)

    # チェックポイントファイルのパス
    checkpoint = Path(args.checkpoint) if args.checkpoint else None

    try:
        # シミュレーションの初期化
        sim = initialize_simulation(config, logger, checkpoint)

        # 初期状態の可視化と保存
        state, _ = sim.get_state()
        visualize_simulation_state(state, config, timestamp=0.0)

        # 初期チェックポイントを保存（オプション）
        output_dir = Path(config.output_dir) / "checkpoints"
        output_dir.mkdir(parents=True, exist_ok=True)
        initial_checkpoint = output_dir / "initial_checkpoint.npz"
        sim.save_checkpoint(str(initial_checkpoint))

        # シミュレーションパラメータ
        save_interval = config.time.save_interval
        max_time = config.time.max_time
        next_save_time = save_interval

        # 最初の時間刻み幅を計算
        current_dt = sim._time_solver.compute_timestep(state=state)

        logger.info(
            f"シミュレーション開始:\n"
            f"  最大時間: {max_time} [s]\n"
            f"  保存間隔: {save_interval} [s]\n"
            f"  初期時間刻み幅: {current_dt:.3e} [s]"
        )

        while next_save_time <= max_time:
            try:
                # 時間発展の実行（時間刻み幅を明示的に渡す）
                result = sim._time_solver.step_forward(dt=current_dt, state=state)
                state = result["state"]
                step_info = result.get("diagnostics", {})

                # 結果の保存
                if step_info.get("time", 0.0) >= next_save_time:
                    visualize_simulation_state(
                        state, config, timestamp=step_info["time"]
                    )

                    # チェックポイントを保存
                    output_dir = Path(config.output_dir) / "checkpoints"
                    output_dir.mkdir(parents=True, exist_ok=True)
                    checkpoint_filename = f"checkpoint_{step_info['time']:.4f}.npz"
                    checkpoint_path = output_dir / checkpoint_filename
                    sim.save_checkpoint(str(checkpoint_path))

                    next_save_time += save_interval

                # 次のステップの時間刻み幅を計算
                current_dt = sim._time_solver.compute_timestep(state=state)

                # 進捗の出力
                logger.info(
                    f"Time: {step_info.get('time', 0.0):.3f}/{max_time:.1f} "
                    f"(dt={current_dt:.3e}), "
                    f"Diagnostics: {step_info}"
                )

            except Exception as e:
                logger.error(f"シミュレーションステップ中にエラー: {e}")
                import traceback

                traceback.print_exc()
                break

        logger.info("シミュレーション正常終了")
        return 0

    except Exception as e:
        logger.error(f"実行中にエラーが発生: {e}")
        import traceback

        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())

```

### .vscode/launch.json

```
{
    // IntelliSense を使用して利用可能な属性を学べます。
    // 既存の属性の説明をホバーして表示します。
    // 詳細情報は次を確認してください: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        
        {
            "name": "Python デバッガー: 現在のファイル",
            "type": "debugpy",
            "request": "launch",
            "program": "main2.py",
            "console": "integratedTerminal",
            "args": ["--config", "config.yaml"]
        }
    ]
}
```

